
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>admin: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">sanctum/cmd/admin/main.go (0.0%)</option>
				
				<option value="file1">sanctum/cmd/chattest/main.go (0.0%)</option>
				
				<option value="file2">sanctum/cmd/migrate/main.go (0.0%)</option>
				
				<option value="file3">sanctum/cmd/openapi-compat/main.go (0.0%)</option>
				
				<option value="file4">sanctum/cmd/seed/main.go (0.0%)</option>
				
				<option value="file5">sanctum/cmd/server/main.go (0.0%)</option>
				
				<option value="file6">sanctum/docs/docs.go (0.0%)</option>
				
				<option value="file7">sanctum/internal/cache/helper.go (0.0%)</option>
				
				<option value="file8">sanctum/internal/cache/inventory.go (0.0%)</option>
				
				<option value="file9">sanctum/internal/cache/redis.go (0.0%)</option>
				
				<option value="file10">sanctum/internal/config/config.go (0.0%)</option>
				
				<option value="file11">sanctum/internal/database/database.go (0.0%)</option>
				
				<option value="file12">sanctum/internal/featureflags/manager.go (87.2%)</option>
				
				<option value="file13">sanctum/internal/middleware/auth.go (80.7%)</option>
				
				<option value="file14">sanctum/internal/middleware/logging.go (59.4%)</option>
				
				<option value="file15">sanctum/internal/middleware/metrics.go (0.0%)</option>
				
				<option value="file16">sanctum/internal/middleware/ratelimit.go (53.6%)</option>
				
				<option value="file17">sanctum/internal/models/errors.go (0.0%)</option>
				
				<option value="file18">sanctum/internal/models/friendship.go (0.0%)</option>
				
				<option value="file19">sanctum/internal/models/game.go (0.0%)</option>
				
				<option value="file20">sanctum/internal/notifications/chat_hub.go (35.4%)</option>
				
				<option value="file21">sanctum/internal/notifications/client.go (10.0%)</option>
				
				<option value="file22">sanctum/internal/notifications/game_hub.go (24.3%)</option>
				
				<option value="file23">sanctum/internal/notifications/hub.go (0.0%)</option>
				
				<option value="file24">sanctum/internal/notifications/notifier.go (7.5%)</option>
				
				<option value="file25">sanctum/internal/notifications/videochat_hub.go (47.9%)</option>
				
				<option value="file26">sanctum/internal/repository/chat.go (60.0%)</option>
				
				<option value="file27">sanctum/internal/repository/comment.go (100.0%)</option>
				
				<option value="file28">sanctum/internal/repository/friend.go (43.2%)</option>
				
				<option value="file29">sanctum/internal/repository/game.go (0.0%)</option>
				
				<option value="file30">sanctum/internal/repository/post.go (61.4%)</option>
				
				<option value="file31">sanctum/internal/repository/stream.go (0.0%)</option>
				
				<option value="file32">sanctum/internal/repository/user.go (62.0%)</option>
				
				<option value="file33">sanctum/internal/seed/factories.go (0.0%)</option>
				
				<option value="file34">sanctum/internal/seed/sanctums.go (62.5%)</option>
				
				<option value="file35">sanctum/internal/seed/seed.go (0.0%)</option>
				
				<option value="file36">sanctum/internal/server/auth_handlers.go (60.0%)</option>
				
				<option value="file37">sanctum/internal/server/chat_handlers.go (7.9%)</option>
				
				<option value="file38">sanctum/internal/server/comment_handlers.go (0.0%)</option>
				
				<option value="file39">sanctum/internal/server/example_handlers.go (0.0%)</option>
				
				<option value="file40">sanctum/internal/server/feature_flag_handlers.go (0.0%)</option>
				
				<option value="file41">sanctum/internal/server/friend_handlers.go (0.0%)</option>
				
				<option value="file42">sanctum/internal/server/game_handlers.go (3.2%)</option>
				
				<option value="file43">sanctum/internal/server/helpers.go (92.3%)</option>
				
				<option value="file44">sanctum/internal/server/post_handlers.go (13.5%)</option>
				
				<option value="file45">sanctum/internal/server/realtime_events.go (18.8%)</option>
				
				<option value="file46">sanctum/internal/server/sanctum_handlers.go (17.1%)</option>
				
				<option value="file47">sanctum/internal/server/server.go (26.1%)</option>
				
				<option value="file48">sanctum/internal/server/stream_handlers.go (0.0%)</option>
				
				<option value="file49">sanctum/internal/server/user_handlers.go (24.1%)</option>
				
				<option value="file50">sanctum/internal/server/websocket_handlers.go (4.8%)</option>
				
				<option value="file51">sanctum/internal/server/websocket_videochat.go (0.0%)</option>
				
				<option value="file52">sanctum/internal/server/ws_ticket_handlers.go (0.0%)</option>
				
				<option value="file53">sanctum/internal/service/chat_service.go (75.6%)</option>
				
				<option value="file54">sanctum/internal/service/comment_service.go (0.0%)</option>
				
				<option value="file55">sanctum/internal/service/friend_service.go (16.9%)</option>
				
				<option value="file56">sanctum/internal/service/game_service.go (38.6%)</option>
				
				<option value="file57">sanctum/internal/service/post_service.go (0.0%)</option>
				
				<option value="file58">sanctum/internal/service/user_service.go (0.0%)</option>
				
				<option value="file59">sanctum/internal/validation/password.go (92.5%)</option>
				
				<option value="file60">sanctum/internal/validation/sanctum.go (100.0%)</option>
				
				<option value="file61">sanctum/test/testkit_sanctum.go (82.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main provides admin management utilities for Sanctum.
package main

import (
        "errors"
        "fmt"
        "log"
        "os"

        "sanctum/internal/config"
        "sanctum/internal/database"
        "sanctum/internal/models"

        "gorm.io/gorm"
)

// AdminSetup provides a utility to promote a user to admin or create admin accounts
func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Println("Usage:")
                fmt.Println("  go run ./cmd/admin/main.go promote &lt;user_id&gt;     - Promote user to admin")
                fmt.Println("  go run ./cmd/admin/main.go demote &lt;user_id&gt;       - Demote user from admin")
                fmt.Println("  go run ./cmd/admin/main.go list-admins            - List all admins")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        <span class="cov0" title="0">db, err := database.Connect(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>

        <span class="cov0" title="0">command := os.Args[1]

        switch command </span>{
        case "promote":<span class="cov0" title="0">
                if len(os.Args) &lt; 3 </span><span class="cov0" title="0">{
                        fmt.Println("Usage: go run ./cmd/admin/main.go promote &lt;user_id&gt;")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">promoteToAdmin(db, os.Args[2])</span>

        case "demote":<span class="cov0" title="0">
                if len(os.Args) &lt; 3 </span><span class="cov0" title="0">{
                        fmt.Println("Usage: go run ./cmd/admin/main.go demote &lt;user_id&gt;")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">demoteFromAdmin(db, os.Args[2])</span>

        case "list-admins":<span class="cov0" title="0">
                listAdmins(db)</span>

        default:<span class="cov0" title="0">
                fmt.Printf("Unknown command: %s\n", command)
                os.Exit(1)</span>
        }
}

func promoteToAdmin(db *gorm.DB, userID string) <span class="cov0" title="0">{
        var user models.User
        if err := db.First(&amp;user, userID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        fmt.Printf("User with ID %s not found\n", userID)
                }</span> else<span class="cov0" title="0"> {
                        log.Fatalf("Database error: %v", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if user.IsAdmin </span><span class="cov0" title="0">{
                fmt.Printf("User %s (ID: %d) is already an admin\n", user.Username, user.ID)
                return
        }</span>

        <span class="cov0" title="0">user.IsAdmin = true
        if err := db.Save(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to promote user: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Successfully promoted %s (ID: %d) to admin\n", user.Username, user.ID)</span>
}

func demoteFromAdmin(db *gorm.DB, userID string) <span class="cov0" title="0">{
        var user models.User
        if err := db.First(&amp;user, userID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        fmt.Printf("User with ID %s not found\n", userID)
                }</span> else<span class="cov0" title="0"> {
                        log.Fatalf("Database error: %v", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if !user.IsAdmin </span><span class="cov0" title="0">{
                fmt.Printf("User %s (ID: %d) is not an admin\n", user.Username, user.ID)
                return
        }</span>

        <span class="cov0" title="0">user.IsAdmin = false
        if err := db.Save(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to demote user: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Successfully demoted %s (ID: %d) from admin\n", user.Username, user.ID)</span>
}

func listAdmins(db *gorm.DB) <span class="cov0" title="0">{
        var admins []models.User
        if err := db.Where("is_admin = ?", true).Find(&amp;admins).Error; err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to fetch admins: %v", err)
        }</span>

        <span class="cov0" title="0">if len(admins) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No admins found in the system")
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("\nüìã Current Admins:")
        fmt.Println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
        for _, admin := range admins </span><span class="cov0" title="0">{
                fmt.Printf("ID: %d | Username: %s | Email: %s\n", admin.ID, admin.Username, admin.Email)
        }</span>
        <span class="cov0" title="0">fmt.Println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package main provides a stress testing tool for the chat WebSocket server.
package main

import (
        "flag"
        "fmt"
        "log"
        "net/url"
        "os"
        "os/signal"
        "sync"
        "sync/atomic"
        "syscall"
        "time"

        "github.com/gorilla/websocket"
)

// Metrics tracks the test results
type Metrics struct {
        ConnectionsAttempted int64
        ConnectionsSuccess   int64
        ConnectionsFailed    int64
        MessagesSent         int64
        MessagesReceived     int64
        Errors               int64
}

var metrics Metrics

func main() <span class="cov0" title="0">{
        host := flag.String("host", "localhost:8080", "WebSocket server host")
        clients := flag.Int("clients", 50, "Number of concurrent clients")
        duration := flag.Duration("duration", 30*time.Second, "Test duration")
        flag.Parse()

        log.Printf("üöÄ Starting Chat Stress Test")
        log.Printf("Target: %s", *host)
        log.Printf("Clients: %d", *clients)
        log.Printf("Duration: %v", *duration)

        interrupt := make(chan os.Signal, 1)
        signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM)

        var wg sync.WaitGroup
        stopChan := make(chan struct{})

        // Start clients
        for i := 0; i &lt; *clients; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go runClient(*host, i, stopChan, &amp;wg)
                time.Sleep(10 * time.Millisecond) // Stagger connections slightly
        }</span>

        // Wait for duration or interrupt
        <span class="cov0" title="0">select </span>{
        case &lt;-time.After(*duration):<span class="cov0" title="0">
                log.Println("‚è±Ô∏è  Test duration reached")</span>
        case &lt;-interrupt:<span class="cov0" title="0">
                log.Println("üõë Interrupted by user")</span>
        }

        <span class="cov0" title="0">close(stopChan)
        log.Println("Waiting for clients to disconnect...")
        wg.Wait()

        printMetrics()</span>
}

func runClient(host string, id int, stopChan &lt;-chan struct{}, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()
        atomic.AddInt64(&amp;metrics.ConnectionsAttempted, 1)

        // Build URL
        u := url.URL{Scheme: "ws", Host: host, Path: "/ws/1"} // Connecting to room 1 (General)
        // Add dummy token query param if your auth middleware roughly checks for it,
        // or you might need a real login flow if strict auth is on.
        // For this test, we assume we might need to bypass auth or the server accepts a test token?
        // Based on previous code, the server might require a JWT in cookie or header.
        // Let's assume dev mode might verify but maybe we need a real token.
        // NOTE: If strict auth is enabled, this will fail without a valid token.
        // For now, let's try connecting without one, or maybe add a "token" param if needed later.

        c, resp, err := websocket.DefaultDialer.Dial(u.String(), nil)
        if resp != nil </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;metrics.ConnectionsFailed, 1)
                // log.Printf("Client %d connect error: %v", id, err)
                atomic.AddInt64(&amp;metrics.Errors, 1)
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = c.Close() }</span>()

        <span class="cov0" title="0">atomic.AddInt64(&amp;metrics.ConnectionsSuccess, 1)

        // Read loop
        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{ _ = c.Close() }</span>()
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        _, _, err := c.ReadMessage()
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">atomic.AddInt64(&amp;metrics.MessagesReceived, 1)</span>
                }
        }()

        <span class="cov0" title="0">ticker := time.NewTicker(time.Second * 2)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-stopChan:<span class="cov0" title="0">
                        // Send close message
                        _ = c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""))
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Send a test message
                        msg := fmt.Sprintf("Test message from client %d at %v", id, time.Now().Format(time.Kitchen))
                        // Current backend expects JSON probably?
                        // Or simple text handling?
                        // Based on previous contexts, likely JSON with content/type.
                        // Let's send a simple JSON structure if we knew it, but plain text might echo or error depending on backend.
                        // For stress testing the connection, even a ping is good.
                        err := c.WriteMessage(websocket.TextMessage, []byte(msg))
                        if err != nil </span><span class="cov0" title="0">{
                                atomic.AddInt64(&amp;metrics.Errors, 1)
                                return
                        }</span>
                        <span class="cov0" title="0">atomic.AddInt64(&amp;metrics.MessagesSent, 1)</span>
                }
        }
}

func printMetrics() <span class="cov0" title="0">{
        log.Println("\nüìä Test Results")
        log.Println("===============")
        log.Printf("Connections Attempted: %d", atomic.LoadInt64(&amp;metrics.ConnectionsAttempted))
        log.Printf("Connections Successful: %d", atomic.LoadInt64(&amp;metrics.ConnectionsSuccess))
        log.Printf("Connections Failed: %d", atomic.LoadInt64(&amp;metrics.ConnectionsFailed))
        log.Printf("Messages Sent: %d", atomic.LoadInt64(&amp;metrics.MessagesSent))
        log.Printf("Messages Received: %d", atomic.LoadInt64(&amp;metrics.MessagesReceived))
        log.Printf("Total Errors: %d", atomic.LoadInt64(&amp;metrics.Errors))
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Command migrate runs database migrations for the backend.
package main

import (
        "errors"
        "flag"
        "fmt"
        "log"
        "path/filepath"

        "sanctum/internal/config"

        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
)

func main() <span class="cov0" title="0">{
        if err := run(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func run() error <span class="cov0" title="0">{
        flag.Parse()
        if flag.NArg() &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("usage: go run ./cmd/migrate/main.go &lt;up|down|force|version&gt; [force_version]")
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load config: %w", err)
        }</span>

        <span class="cov0" title="0">sslMode := cfg.DBSSLMode
        if sslMode == "" </span><span class="cov0" title="0">{
                sslMode = "disable"
        }</span>
        <span class="cov0" title="0">dsn := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=%s", cfg.DBUser, cfg.DBPassword, cfg.DBHost, cfg.DBPort, cfg.DBName, sslMode)
        migrationsPath, err := filepath.Abs("migrations")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("resolve migrations path: %w", err)
        }</span>

        <span class="cov0" title="0">m, err := migrate.New("file://"+migrationsPath, dsn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create migrate client: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _, _ = m.Close()
        }</span>()

        <span class="cov0" title="0">switch flag.Arg(0) </span>{
        case "up":<span class="cov0" title="0">
                err = m.Up()
                if err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                        return fmt.Errorf("migrate up failed: %w", err)
                }</span>
                <span class="cov0" title="0">log.Println("migrations applied")</span>
        case "down":<span class="cov0" title="0">
                err = m.Steps(-1)
                if err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                        return fmt.Errorf("migrate down failed: %w", err)
                }</span>
                <span class="cov0" title="0">log.Println("rolled back one migration")</span>
        case "force":<span class="cov0" title="0">
                if flag.NArg() &lt; 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("usage: go run ./cmd/migrate/main.go force &lt;version&gt;")
                }</span>
                <span class="cov0" title="0">var version int
                if _, err := fmt.Sscanf(flag.Arg(1), "%d", &amp;version); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid force version: %w", err)
                }</span>
                <span class="cov0" title="0">if err := m.Force(version); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("force failed: %w", err)
                }</span>
                <span class="cov0" title="0">log.Printf("forced migration version to %d", version)</span>
        case "version":<span class="cov0" title="0">
                version, dirty, err := m.Version()
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, migrate.ErrNilVersion) </span><span class="cov0" title="0">{
                                log.Println("version: none")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("read version failed: %w", err)</span>
                }
                <span class="cov0" title="0">log.Printf("version=%d dirty=%t", version, dirty)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown command %q", flag.Arg(0))</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "errors"
        "flag"
        "fmt"
        "os"
        "sort"
        "strings"

        "gopkg.in/yaml.v3"
)

var supportedMethods = map[string]struct{}{
        "get":     {},
        "put":     {},
        "post":    {},
        "delete":  {},
        "patch":   {},
        "head":    {},
        "options": {},
}

type operation struct {
        Responses map[string]struct{}
}

type parsedSpec struct {
        Paths map[string]map[string]operation
}

func main() <span class="cov0" title="0">{
        basePath := flag.String("base", "", "base OpenAPI swagger.yaml path")
        revisionPath := flag.String("revision", "", "revision OpenAPI swagger.yaml path")
        flag.Parse()

        if strings.TrimSpace(*basePath) == "" || strings.TrimSpace(*revisionPath) == "" </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "usage: openapi-compat -base &lt;path&gt; -revision &lt;path&gt;")
                os.Exit(2)
        }</span>

        <span class="cov0" title="0">baseSpec, err := loadSpec(*basePath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "failed to load base spec: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">revisionSpec, err := loadSpec(*revisionPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "failed to load revision spec: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">issues := compare(baseSpec, revisionSpec)
        if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "backward compatibility check failed:")
                for _, issue := range issues </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "- %s\n", issue)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">fmt.Println("openapi compatibility check passed")</span>
}

func loadSpec(path string) (parsedSpec, error) <span class="cov0" title="0">{
        raw, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return parsedSpec{}, err
        }</span>

        <span class="cov0" title="0">doc := map[string]interface{}{}
        if err := yaml.Unmarshal(raw, &amp;doc); err != nil </span><span class="cov0" title="0">{
                return parsedSpec{}, err
        }</span>

        <span class="cov0" title="0">pathsRaw, ok := doc["paths"]
        if !ok </span><span class="cov0" title="0">{
                return parsedSpec{}, errors.New("missing top-level paths field")
        }</span>

        <span class="cov0" title="0">pathsMap, ok := toMap(pathsRaw)
        if !ok </span><span class="cov0" title="0">{
                return parsedSpec{}, errors.New("paths is not an object")
        }</span>

        <span class="cov0" title="0">spec := parsedSpec{Paths: make(map[string]map[string]operation)}

        for pathKey, pathEntry := range pathsMap </span><span class="cov0" title="0">{
                pathOpsRaw, ok := toMap(pathEntry)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ops := make(map[string]operation)
                for methodKey, methodEntry := range pathOpsRaw </span><span class="cov0" title="0">{
                        methodLower := strings.ToLower(strings.TrimSpace(methodKey))
                        if _, supported := supportedMethods[methodLower]; !supported </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">methodMap, ok := toMap(methodEntry)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">responseSet := make(map[string]struct{})
                        if responsesRaw, exists := methodMap["responses"]; exists </span><span class="cov0" title="0">{
                                if responsesMap, ok := toMap(responsesRaw); ok </span><span class="cov0" title="0">{
                                        for code := range responsesMap </span><span class="cov0" title="0">{
                                                normalized := strings.ToLower(strings.TrimSpace(code))
                                                if normalized != "" </span><span class="cov0" title="0">{
                                                        responseSet[normalized] = struct{}{}
                                                }</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">ops[methodLower] = operation{Responses: responseSet}</span>
                }

                <span class="cov0" title="0">if len(ops) &gt; 0 </span><span class="cov0" title="0">{
                        spec.Paths[pathKey] = ops
                }</span>
        }

        <span class="cov0" title="0">return spec, nil</span>
}

func toMap(v interface{}) (map[string]interface{}, bool) <span class="cov0" title="0">{
        switch t := v.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                return t, true</span>
        case map[interface{}]interface{}:<span class="cov0" title="0">
                out := make(map[string]interface{}, len(t))
                for k, val := range t </span><span class="cov0" title="0">{
                        ks, ok := k.(string)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">out[ks] = val</span>
                }
                <span class="cov0" title="0">return out, true</span>
        default:<span class="cov0" title="0">
                return nil, false</span>
        }
}

func compare(base, revision parsedSpec) []string <span class="cov0" title="0">{
        var issues []string

        for path, baseOps := range base.Paths </span><span class="cov0" title="0">{
                revOps, ok := revision.Paths[path]
                if !ok </span><span class="cov0" title="0">{
                        issues = append(issues, fmt.Sprintf("removed path: %s", path))
                        continue</span>
                }

                <span class="cov0" title="0">for method, baseOp := range baseOps </span><span class="cov0" title="0">{
                        revOp, ok := revOps[method]
                        if !ok </span><span class="cov0" title="0">{
                                issues = append(issues, fmt.Sprintf("removed operation: %s %s", strings.ToUpper(method), path))
                                continue</span>
                        }

                        <span class="cov0" title="0">for responseCode := range baseOp.Responses </span><span class="cov0" title="0">{
                                if _, ok := revOp.Responses[responseCode]; !ok </span><span class="cov0" title="0">{
                                        issues = append(issues, fmt.Sprintf(
                                                "removed response code: %s %s -&gt; %s",
                                                strings.ToUpper(method), path, strings.ToUpper(responseCode),
                                        ))
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">sort.Strings(issues)
        return issues</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Command main runs the database seeder for Sanctum.
package main

import (
        "flag"
        "log"

        "sanctum/internal/config"
        "sanctum/internal/database"
        "sanctum/internal/seed"
)

func main() <span class="cov0" title="0">{
        // Parse command line flags
        numUsers := flag.Int("users", 50, "Number of users to create")
        numPosts := flag.Int("posts", 200, "Number of posts to create")
        shouldClean := flag.Bool("clean", true, "Clean database before seeding")
        preset := flag.String("preset", "", "Apply a specific seeder preset (e.g., MegaPopulated)")
        flag.Parse()

        log.Println("üå± Database Seeder")
        log.Println("==================")

        if *preset != "" </span><span class="cov0" title="0">{
                log.Printf("Applying preset: %s (ignoring other flags)\n", *preset)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Target: %d users, %d posts, clean=%v\n", *numUsers, *numPosts, *shouldClean)
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Connect to database
        <span class="cov0" title="0">_, err = database.Connect(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>

        // Run seeder
        <span class="cov0" title="0">s := seed.NewSeeder(database.DB)

        if *shouldClean </span><span class="cov0" title="0">{
                if err := s.ClearAll(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("‚ùå Cleanup failed: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if err := seed.Sanctums(database.DB); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Built-in sanctum seeding failed: %v", err)
        }</span>

        <span class="cov0" title="0">if *preset != "" </span><span class="cov0" title="0">{
                if err := s.ApplyPreset(*preset); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("‚ùå Preset seeding failed: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                users, err := s.SeedSocialMesh(*numUsers)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("‚ùå User seeding failed: %v", err)
                }</span>
                <span class="cov0" title="0">_, err = s.SeedEngagement(users, *numPosts)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("‚ùå Engagement seeding failed: %v", err)
                }</span>
        }

        <span class="cov0" title="0">log.Println("‚ú® All done! Your database is now populated with test data.")
        log.Println("üìß All test users have the password: password123")</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Command main is the entry point for the Sanctum backend server.
package main

import (
        "context"
        "log"
        "os"
        "os/signal"
        "syscall"
        "time"

        "sanctum/internal/config"
        "sanctum/internal/server"

        "github.com/gofiber/fiber/v2"
)

// @title Sanctum API
// @version 1.0
// @description Social media platform API with posts, comments, messaging, and friends
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.email support@sanctum.dev

// @license.name MIT
// @license.url https://opensource.org/licenses/MIT

// @host localhost:8375
// @BasePath /api
// @schemes http https

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Create server with dependency injection
        <span class="cov0" title="0">srv, err := server.NewServer(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create server: %v", err)
        }</span>

        // Initialize Fiber app
        <span class="cov0" title="0">app := fiber.New(fiber.Config{
                AppName:   "Social Media API",
                BodyLimit: 10 * 1024 * 1024, // 10MB limit
        })

        // Setup middleware and routes
        srv.SetupMiddleware(app)
        srv.SetupRoutes(app)

        // Graceful shutdown
        go func() </span><span class="cov0" title="0">{
                sigChan := make(chan os.Signal, 1)
                signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
                &lt;-sigChan

                log.Println("Shutting down server...")
                ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                defer cancel()

                if err := app.ShutdownWithContext(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Server shutdown error: %v", err)
                }</span>

                // Shutdown server resources
                <span class="cov0" title="0">if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Server resource shutdown error: %v", err)
                }</span>
        }()

        // Start server
        <span class="cov0" title="0">log.Printf("Server starting on port %s...", cfg.Port)
        log.Fatal(app.Listen(":" + cfg.Port))</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by swaggo/swag. DO NOT EDIT.

package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "email": "support@sanctum.dev"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/admin/sanctum-requests": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "List sanctum requests by status. Defaults to pending.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "sanctums-admin"
                ],
                "summary": "List sanctum requests for admins",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter status",
                        "name": "status",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.SanctumRequest"
                            }
                        }
                    }
                }
            }
        },
        "/admin/sanctum-requests/{id}/approve": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Approve a pending sanctum request and create sanctum, owner membership, and default chat room.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "sanctums-admin"
                ],
                "summary": "Approve sanctum request",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Request ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Optional review notes",
                        "name": "request",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "review_notes": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "request": {
                                    "$ref": "#/definitions/models.SanctumRequest"
                                },
                                "sanctum": {
                                    "$ref": "#/definitions/server.SanctumDTO"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/admin/sanctum-requests/{id}/reject": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Reject a pending sanctum request.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "sanctums-admin"
                ],
                "summary": "Reject sanctum request",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Request ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Optional review notes",
                        "name": "request",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "review_notes": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.SanctumRequest"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/login": {
            "post": {
                "description": "Authenticate user and return JWT tokens",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "Login credentials",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "properties": {
                                "email": {
                                    "type": "string"
                                },
                                "password": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "refresh_token": {
                                    "type": "string"
                                },
                                "token": {
                                    "type": "string"
                                },
                                "user": {
                                    "$ref": "#/definitions/models.User"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "description": "Revoke refresh token and blacklist current access token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "User logout",
                "parameters": [
                    {
                        "description": "Logout request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "properties": {
                                "refresh_token": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "message": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "/auth/refresh": {
            "post": {
                "description": "Get a new access token using a refresh token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Refresh JWT token",
                "parameters": [
                    {
                        "description": "Refresh request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "properties": {
                                "refresh_token": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "refresh_token": {
                                    "type": "string"
                                },
                                "token": {
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "/auth/signup": {
            "post": {
                "description": "Register a new user account",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "User signup",
                "parameters": [
                    {
                        "description": "Signup request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "properties": {
                                "email": {
                                    "type": "string"
                                },
                                "password": {
                                    "type": "string"
                                },
                                "username": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "refresh_token": {
                                    "type": "string"
                                },
                                "token": {
                                    "type": "string"
                                },
                                "user": {
                                    "$ref": "#/definitions/models.User"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "/sanctums": {
            "get": {
                "description": "List active sanctums.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "sanctums"
                ],
                "summary": "List sanctums",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/server.SanctumDTO"
                            }
                        }
                    }
                }
            }
        },
        "/sanctums/memberships/bulk": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Upsert current user's followed sanctums by slug and keep owner/mod memberships intact.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "sanctums"
                ],
                "summary": "Save sanctums I follow",
                "parameters": [
                    {
                        "description": "Sanctum follow list",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "properties": {
                                "sanctum_slugs": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/server.SanctumMembershipDTO"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/sanctums/memberships/me": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "List sanctum memberships for the current user.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "sanctums"
                ],
                "summary": "Get my sanctum memberships",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/server.SanctumMembershipDTO"
                            }
                        }
                    }
                }
            }
        },
        "/sanctums/requests": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Submit a request for a new sanctum.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "sanctums"
                ],
                "summary": "Create sanctum request",
                "parameters": [
                    {
                        "description": "Sanctum request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "properties": {
                                "reason": {
                                    "type": "string"
                                },
                                "requested_name": {
                                    "type": "string"
                                },
                                "requested_slug": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.SanctumRequest"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/sanctums/requests/me": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "List sanctum requests submitted by the current user.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "sanctums"
                ],
                "summary": "Get my sanctum requests",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.SanctumRequest"
                            }
                        }
                    }
                }
            }
        },
        "/sanctums/{slug}": {
            "get": {
                "description": "Fetch active sanctum detail by slug.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "sanctums"
                ],
                "summary": "Get sanctum by slug",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Sanctum slug",
                        "name": "slug",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/server.SanctumDTO"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/streams": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Streams"
                ],
                "summary": "Get live streams",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter by category",
                        "name": "category",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 20,
                        "description": "Limit results",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 0,
                        "description": "Offset for pagination",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Streams"
                ],
                "summary": "Create a new stream",
                "parameters": [
                    {
                        "description": "Stream data",
                        "name": "stream",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/server.CreateStreamRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.Stream"
                        }
                    }
                }
            }
        },
        "/streams/categories": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Streams"
                ],
                "summary": "Get stream categories",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/streams/me": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Streams"
                ],
                "summary": "Get my streams",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.Stream"
                            }
                        }
                    }
                }
            }
        },
        "/streams/{id}": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Streams"
                ],
                "summary": "Get stream by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Stream ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Stream"
                        }
                    }
                }
            },
            "put": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Streams"
                ],
                "summary": "Update a stream",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Stream ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Stream data",
                        "name": "stream",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/server.UpdateStreamRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Stream"
                        }
                    }
                }
            },
            "delete": {
                "tags": [
                    "Streams"
                ],
                "summary": "Delete a stream",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Stream ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    }
                }
            }
        },
        "/streams/{id}/end": {
            "post": {
                "tags": [
                    "Streams"
                ],
                "summary": "End streaming",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Stream ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Stream"
                        }
                    }
                }
            }
        },
        "/streams/{id}/go-live": {
            "post": {
                "tags": [
                    "Streams"
                ],
                "summary": "Start streaming (go live)",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Stream ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Stream"
                        }
                    }
                }
            }
        },
        "/streams/{id}/messages": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Streams"
                ],
                "summary": "Get stream chat messages",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Stream ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "default": 50,
                        "description": "Limit results",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 0,
                        "description": "Offset for pagination",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.StreamMessage"
                            }
                        }
                    }
                }
            },
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Streams"
                ],
                "summary": "Send stream chat message",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Stream ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Message content",
                        "name": "message",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.StreamMessage"
                        }
                    }
                }
            }
        },
        "/ws/ticket": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Generates a short-lived (60s), single-use ticket for WebSocket authentication to avoid sending JWTs in query parameters.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "websocket"
                ],
                "summary": "Issue WebSocket ticket",
                "responses": {
                    "200": {
                        "description": "ticket: string, expires_in: int",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "401": {
                        "description": "error: unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "503": {
                        "description": "error: Redis not available",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.ErrorResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "details": {
                    "type": "string"
                },
                "error": {
                    "type": "string"
                },
                "request_id": {
                    "type": "string"
                }
            }
        },
        "models.Post": {
            "type": "object",
            "properties": {
                "comments_count": {
                    "description": "CommentsCount is not persisted; computed at query time",
                    "type": "integer"
                },
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "image_url": {
                    "type": "string"
                },
                "liked": {
                    "description": "Liked indicates whether the current requesting user liked this post (computed)",
                    "type": "boolean"
                },
                "likes_count": {
                    "description": "LikesCount is not persisted; computed at query time",
                    "type": "integer"
                },
                "sanctum": {
                    "$ref": "#/definitions/models.Sanctum"
                },
                "sanctum_id": {
                    "type": "integer"
                },
                "title": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                },
                "user": {
                    "$ref": "#/definitions/models.User"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "models.Sanctum": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "created_by_user": {
                    "$ref": "#/definitions/models.User"
                },
                "created_by_user_id": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "slug": {
                    "type": "string"
                },
                "status": {
                    "$ref": "#/definitions/models.SanctumStatus"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "models.SanctumMembershipRole": {
            "type": "string",
            "enum": [
                "owner",
                "mod",
                "member"
            ],
            "x-enum-varnames": [
                "SanctumMembershipRoleOwner",
                "SanctumMembershipRoleMod",
                "SanctumMembershipRoleMember"
            ]
        },
        "models.SanctumRequest": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "reason": {
                    "type": "string"
                },
                "requested_by_user": {
                    "$ref": "#/definitions/models.User"
                },
                "requested_by_user_id": {
                    "type": "integer"
                },
                "requested_name": {
                    "type": "string"
                },
                "requested_slug": {
                    "type": "string"
                },
                "review_notes": {
                    "type": "string"
                },
                "reviewed_by_user": {
                    "$ref": "#/definitions/models.User"
                },
                "reviewed_by_user_id": {
                    "type": "integer"
                },
                "status": {
                    "$ref": "#/definitions/models.SanctumRequestStatus"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "models.SanctumRequestStatus": {
            "type": "string",
            "enum": [
                "pending",
                "approved",
                "rejected"
            ],
            "x-enum-varnames": [
                "SanctumRequestStatusPending",
                "SanctumRequestStatusApproved",
                "SanctumRequestStatusRejected"
            ]
        },
        "models.SanctumStatus": {
            "type": "string",
            "enum": [
                "active",
                "pending",
                "rejected",
                "banned"
            ],
            "x-enum-varnames": [
                "SanctumStatusActive",
                "SanctumStatusPending",
                "SanctumStatusRejected",
                "SanctumStatusBanned"
            ]
        },
        "models.Stream": {
            "type": "object",
            "properties": {
                "category": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "ended_at": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "is_live": {
                    "type": "boolean"
                },
                "started_at": {
                    "type": "string"
                },
                "stream_type": {
                    "description": "\"youtube\", \"twitch\", \"hls\", \"iframe\"",
                    "type": "string"
                },
                "stream_url": {
                    "type": "string"
                },
                "tags": {
                    "description": "JSON array of tags",
                    "type": "string"
                },
                "thumbnail_url": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                },
                "user": {
                    "$ref": "#/definitions/models.User"
                },
                "user_id": {
                    "type": "integer"
                },
                "viewer_count": {
                    "type": "integer"
                }
            }
        },
        "models.StreamMessage": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "stream_id": {
                    "type": "integer"
                },
                "user": {
                    "$ref": "#/definitions/models.User"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "models.User": {
            "type": "object",
            "properties": {
                "avatar": {
                    "type": "string"
                },
                "bio": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "is_admin": {
                    "type": "boolean"
                },
                "posts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Post"
                    }
                },
                "updated_at": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "server.CreateStreamRequest": {
            "type": "object",
            "required": [
                "stream_type",
                "stream_url",
                "title"
            ],
            "properties": {
                "category": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "stream_type": {
                    "type": "string",
                    "enum": [
                        "youtube",
                        "twitch",
                        "hls",
                        "iframe"
                    ]
                },
                "stream_url": {
                    "type": "string"
                },
                "tags": {
                    "type": "string"
                },
                "thumbnail_url": {
                    "type": "string"
                },
                "title": {
                    "type": "string",
                    "maxLength": 255,
                    "minLength": 1
                }
            }
        },
        "server.SanctumDTO": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "created_by_user_id": {
                    "type": "integer"
                },
                "default_chat_room_id": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "slug": {
                    "type": "string"
                },
                "status": {
                    "$ref": "#/definitions/models.SanctumStatus"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "server.SanctumMembershipDTO": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "role": {
                    "$ref": "#/definitions/models.SanctumMembershipRole"
                },
                "sanctum": {
                    "$ref": "#/definitions/server.SanctumDTO"
                },
                "sanctum_id": {
                    "type": "integer"
                },
                "updated_at": {
                    "type": "string"
                },
                "user_id": {
                    "type": "integer"
                }
            }
        },
        "server.UpdateStreamRequest": {
            "type": "object",
            "properties": {
                "category": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "stream_type": {
                    "type": "string"
                },
                "stream_url": {
                    "type": "string"
                },
                "tags": {
                    "type": "string"
                },
                "thumbnail_url": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8375",
        BasePath:         "/api",
        Schemes:          []string{"http", "https"},
        Title:            "Sanctum API",
        Description:      "Social media platform API with posts, comments, messaging, and friends",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package cache provides Redis caching utilities for the application.
package cache

import (
        "context"
        "encoding/json"
        "errors"
        "time"

        "github.com/redis/go-redis/v9"
)

// GetJSON attempts to get the key from Redis and unmarshal into dest.
// Returns (true, nil) if found and unmarshaled, (false, nil) if not found.
func GetJSON(ctx context.Context, key string, dest any) (bool, error) <span class="cov0" title="0">{
        if client == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">s, err := client.Get(ctx, key).Result()
        if errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal([]byte(s), dest); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

// SetJSON marshals v and sets the key with TTL.
func SetJSON(ctx context.Context, key string, v any, ttl time.Duration) error <span class="cov0" title="0">{
        if client == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return client.Set(ctx, key, b, ttl).Err()</span>
}

// Aside tries Redis first, on miss it calls fetch (which should populate dest),
// then stores the result in Redis with ttl. fetch must write into dest.
// Aside tries Redis first, on miss it calls fetch (which should populate dest),
// then stores the result in Redis with ttl. fetch must write into dest.
func Aside(ctx context.Context, key string, dest any, ttl time.Duration, fetch func() error) (err error) <span class="cov0" title="0">{
        found, err := GetJSON(ctx, key, dest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Fetch from source (DB)
        <span class="cov0" title="0">if err := fetch(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Store into cache (best-effort) - we intentionally ignore cache failures
        <span class="cov0" title="0">if err := SetJSON(ctx, key, dest, ttl); err != nil </span><span class="cov0" title="0">{
                // Best-effort caching: log but don't fail the operation
                return nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cache

import (
        "context"
        "fmt"
        "time"
)

// Cache Keys
const (
        UserKeyPrefix    = "user:%d"
        PostKeyPrefix    = "post:%d"
        SanctumKeyPrefix = "sanctum:%s"
)

// TTLs
const (
        UserTTL    = 1 * time.Hour
        PostTTL    = 30 * time.Minute
        SanctumTTL = 24 * time.Hour
)

// UserKey returns the cache key for a user by ID
func UserKey(userID uint) string <span class="cov0" title="0">{
        return fmt.Sprintf(UserKeyPrefix, userID)
}</span>

// PostKey returns the cache key for a post by ID
func PostKey(postID uint) string <span class="cov0" title="0">{
        return fmt.Sprintf(PostKeyPrefix, postID)
}</span>

// SanctumKey returns the cache key for a sanctum by slug
func SanctumKey(slug string) string <span class="cov0" title="0">{
        return fmt.Sprintf(SanctumKeyPrefix, slug)
}</span>

// Invalidate removes a key from Redis
func Invalidate(ctx context.Context, key string) <span class="cov0" title="0">{
        if client != nil </span><span class="cov0" title="0">{
                client.Del(ctx, key)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package cache provides Redis caching utilities for the application.
package cache

import (
        "context"
        "log"
        "time"

        "sanctum/internal/middleware"

        "github.com/redis/go-redis/v9"
)

var client *redis.Client

type metricsHook struct{}

func (h metricsHook) DialHook(next redis.DialHook) redis.DialHook <span class="cov0" title="0">{
        return next
}</span>

func (h metricsHook) ProcessHook(next redis.ProcessHook) redis.ProcessHook <span class="cov0" title="0">{
        return func(ctx context.Context, cmd redis.Cmder) error </span><span class="cov0" title="0">{
                err := next(ctx, cmd)
                if err != nil &amp;&amp; err != redis.Nil </span><span class="cov0" title="0">{
                        middleware.RedisErrors.WithLabelValues(cmd.Name()).Inc()
                }</span>
                <span class="cov0" title="0">return err</span>
        }
}

func (h metricsHook) ProcessPipelineHook(next redis.ProcessPipelineHook) redis.ProcessPipelineHook <span class="cov0" title="0">{
        return func(ctx context.Context, cmds []redis.Cmder) error </span><span class="cov0" title="0">{
                err := next(ctx, cmds)
                if err != nil &amp;&amp; err != redis.Nil </span><span class="cov0" title="0">{
                        middleware.RedisErrors.WithLabelValues("pipeline").Inc()
                }</span>
                <span class="cov0" title="0">return err</span>
        }
}

// InitRedis initializes the Redis client with the given address.
func InitRedis(addr string) <span class="cov0" title="0">{
        client = redis.NewClient(&amp;redis.Options{
                Addr: addr,
        })
        client.AddHook(metricsHook{})

        // Test connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Redis connection warning: %v (continuing without cache)", err)
                client = nil
        }</span> else<span class="cov0" title="0"> {
                log.Println("Redis connected successfully")
        }</span>
}

// GetClient returns the current Redis client instance.
func GetClient() *redis.Client <span class="cov0" title="0">{
        return client
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package config provides application configuration loading and management.
package config

import (
        "errors"
        "fmt"
        "log"

        "github.com/spf13/viper"
)

// Config holds application configuration values loaded from file or environment variables.
type Config struct {
        JWTSecret      string `mapstructure:"JWT_SECRET"`
        Port           string `mapstructure:"PORT"`
        DBHost         string `mapstructure:"DB_HOST"`
        DBPort         string `mapstructure:"DB_PORT"`
        DBUser         string `mapstructure:"DB_USER"`
        DBPassword     string `mapstructure:"DB_PASSWORD"`
        DBName         string `mapstructure:"DB_NAME"`
        DBSSLMode      string `mapstructure:"DB_SSLMODE"`
        RedisURL       string `mapstructure:"REDIS_URL"`
        AllowedOrigins string `mapstructure:"ALLOWED_ORIGINS"`
        FeatureFlags   string `mapstructure:"FEATURE_FLAGS"`
        Env            string `mapstructure:"APP_ENV"`
        TURNURL        string `mapstructure:"TURN_URL"`
        TURNUsername   string `mapstructure:"TURN_USERNAME"`
        TURNPassword   string `mapstructure:"TURN_PASSWORD"`
}

// LoadConfig loads application configuration from file and environment variables.
func LoadConfig() (*Config, error) <span class="cov0" title="0">{
        viper.AddConfigPath(".")
        viper.AddConfigPath("..")
        viper.AddConfigPath("../..")
        viper.SetConfigName("config")
        viper.SetConfigType("yml")
        viper.AutomaticEnv()

        // Initial read to get APP_ENV if set in base config
        // We intentionally ignore this error as the config file may not exist yet
        _ = viper.ReadInConfig()

        env := viper.GetString("APP_ENV")
        if env == "" </span><span class="cov0" title="0">{
                env = "development"
        }</span>

        <span class="cov0" title="0">if env != "development" &amp;&amp; env != "" </span><span class="cov0" title="0">{
                viper.SetConfigName("config." + env)
                if err := viper.MergeInConfig(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("required profile-specific config 'config.%s.yml' not found: %w", env, err)
                }</span>
                <span class="cov0" title="0">log.Printf("Loaded profile-specific configuration: config.%s.yml", env)</span>
        }

        // Set default values for development
        <span class="cov0" title="0">viper.SetDefault("PORT", "8375")
        viper.SetDefault("DB_HOST", "localhost")
        viper.SetDefault("DB_PORT", "5432")
        viper.SetDefault("DB_USER", "user")
        viper.SetDefault("DB_PASSWORD", "password")
        viper.SetDefault("DB_NAME", "social_media")
        viper.SetDefault("REDIS_URL", "localhost:6379")
        viper.SetDefault("JWT_SECRET", "your-secret-key-change-in-production")
        viper.SetDefault("ALLOWED_ORIGINS", "http://localhost:5173,http://localhost:3000,http://127.0.0.1:5173")
        viper.SetDefault("FEATURE_FLAGS", "")
        viper.SetDefault("APP_ENV", "development")
        viper.SetDefault("DB_SSLMODE", "disable")

        var config Config
        if err := viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to decode config into struct: %w", err)
        }</span>

        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// Validate ensures that required configuration values are present and meet security standards.
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.Port == "" </span><span class="cov0" title="0">{
                return errors.New("PORT is required")
        }</span>
        <span class="cov0" title="0">if c.JWTSecret == "" </span><span class="cov0" title="0">{
                return errors.New("JWT_SECRET is required")
        }</span>

        <span class="cov0" title="0">isProduction := c.Env == "production" || c.Env == "prod"

        // Strict checks for production
        if isProduction </span><span class="cov0" title="0">{
                if c.JWTSecret == "your-secret-key-change-in-production" </span><span class="cov0" title="0">{
                        return errors.New("JWT_SECRET must be changed from the default value in production")
                }</span>
                <span class="cov0" title="0">if len(c.JWTSecret) &lt; 32 </span><span class="cov0" title="0">{
                        return errors.New("JWT_SECRET must be at least 32 characters in production")
                }</span>
                <span class="cov0" title="0">if c.DBPassword == "password" || c.DBPassword == "" </span><span class="cov0" title="0">{
                        return errors.New("a strong DB_PASSWORD is required in production")
                }</span>
                <span class="cov0" title="0">if c.DBSSLMode == "disable" || c.DBSSLMode == "" </span><span class="cov0" title="0">{
                        log.Println("WARNING: DB_SSLMODE is 'disable' in production. It is highly recommended to use SSL for database connections.")
                }</span>
                <span class="cov0" title="0">if c.AllowedOrigins == "*" </span><span class="cov0" title="0">{
                        log.Println("WARNING: ALLOWED_ORIGINS is set to '*' in production. This is insecure.")
                }</span>
        } else<span class="cov0" title="0"> {
                // Development/Test warnings
                if len(c.JWTSecret) &lt; 32 </span><span class="cov0" title="0">{
                        log.Println("WARNING: JWT_SECRET is shorter than 32 characters. Consider using a stronger secret for production.")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package database handles database connections and migrations.
package database

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "time"

        "sanctum/internal/config"
        "sanctum/internal/middleware"
        "sanctum/internal/models"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

// DB is the global database connection instance.
var DB *gorm.DB

// CustomGormLogger integrates GORM with slog
type CustomGormLogger struct {
        logger *slog.Logger
        Config logger.Config
}

// LogMode sets the logging level and returns a new interface instance.
func (l *CustomGormLogger) LogMode(level logger.LogLevel) logger.Interface <span class="cov0" title="0">{
        newlogger := *l
        newlogger.Config.LogLevel = level
        return &amp;newlogger
}</span>

// Info logs an informational message with context.
func (l *CustomGormLogger) Info(ctx context.Context, msg string, data ...interface{}) <span class="cov0" title="0">{
        if l.Config.LogLevel &gt;= logger.Info </span><span class="cov0" title="0">{
                l.logger.InfoContext(ctx, fmt.Sprintf(msg, data...))
        }</span>
}

// Warn logs a warning message with context.
func (l *CustomGormLogger) Warn(ctx context.Context, msg string, data ...interface{}) <span class="cov0" title="0">{
        if l.Config.LogLevel &gt;= logger.Warn </span><span class="cov0" title="0">{
                l.logger.WarnContext(ctx, fmt.Sprintf(msg, data...))
        }</span>
}

func (l *CustomGormLogger) Error(ctx context.Context, msg string, data ...interface{}) <span class="cov0" title="0">{
        if l.Config.LogLevel &gt;= logger.Error </span><span class="cov0" title="0">{
                l.logger.ErrorContext(ctx, fmt.Sprintf(msg, data...))
        }</span>
}

// Trace logs trace-level information including SQL queries and execution time.
func (l *CustomGormLogger) Trace(ctx context.Context, begin time.Time, fc func() (string, int64), err error) <span class="cov0" title="0">{
        if l.Config.LogLevel &lt;= logger.Silent </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">elapsed := time.Since(begin)
        sql, rows := fc()

        switch </span>{
        case err != nil &amp;&amp; l.Config.LogLevel &gt;= logger.Error &amp;&amp; !errors.Is(err, gorm.ErrRecordNotFound):<span class="cov0" title="0">
                middleware.DatabaseErrors.WithLabelValues("query").Inc()
                l.logger.ErrorContext(ctx, "GORM query error",
                        slog.String("sql", sql),
                        slog.Int64("rows", rows),
                        slog.Duration("elapsed", elapsed),
                        slog.String("error", err.Error()),
                )</span>
        case elapsed &gt; l.Config.SlowThreshold &amp;&amp; l.Config.SlowThreshold != 0 &amp;&amp; l.Config.LogLevel &gt;= logger.Warn:<span class="cov0" title="0">
                l.logger.WarnContext(ctx, "GORM slow query",
                        slog.String("sql", sql),
                        slog.Int64("rows", rows),
                        slog.Duration("elapsed", elapsed),
                )</span>
        case l.Config.LogLevel &gt;= logger.Info:<span class="cov0" title="0">
                l.logger.InfoContext(ctx, "GORM query",
                        slog.String("sql", sql),
                        slog.Int64("rows", rows),
                        slog.Duration("elapsed", elapsed),
                )</span>
        }
}

// Connect opens a database connection using the provided configuration and returns the gorm DB instance.
func Connect(cfg *config.Config) (*gorm.DB, error) <span class="cov0" title="0">{
        var err error

        // Build PostgreSQL connection string
        sslMode := cfg.DBSSLMode
        if sslMode == "" </span><span class="cov0" title="0">{
                sslMode = "disable"
        }</span>
        <span class="cov0" title="0">dsn := fmt.Sprintf(
                "host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
                cfg.DBHost,
                cfg.DBPort,
                cfg.DBUser,
                cfg.DBPassword,
                cfg.DBName,
                sslMode,
        )

        // Custom GORM logger that uses slog and ignores ErrRecordNotFound
        gormLogger := &amp;CustomGormLogger{
                logger: middleware.Logger,
                Config: logger.Config{
                        SlowThreshold:             200 * time.Millisecond,
                        LogLevel:                  logger.Warn,
                        IgnoreRecordNotFoundError: true,
                        Colorful:                  false,
                },
        }

        dbInstance, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                Logger: gormLogger,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">middleware.Logger.Info("Database connected successfully")

        isProduction := cfg.Env == "production" || cfg.Env == "prod"
        if !isProduction </span><span class="cov0" title="0">{
                // Keep AutoMigrate in non-production for developer/test ergonomics.
                err = dbInstance.AutoMigrate(
                        &amp;models.User{},
                        &amp;models.Post{},
                        &amp;models.Comment{},
                        &amp;models.Like{},
                        &amp;models.Conversation{},
                        &amp;models.Message{},
                        &amp;models.ConversationParticipant{},
                        &amp;models.Friendship{},
                        &amp;models.GameRoom{},
                        &amp;models.GameMove{},
                        &amp;models.GameStats{},
                        &amp;models.Stream{},
                        &amp;models.StreamMessage{},
                        &amp;models.Sanctum{},
                        &amp;models.SanctumRequest{},
                        &amp;models.SanctumMembership{},
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to migrate database: %w", err)
                }</span>

                // Manual migration: Ensure opponent_id is nullable (GORM sometimes misses dropping NOT NULL)
                <span class="cov0" title="0">if migrateErr := dbInstance.Exec("ALTER TABLE game_rooms ALTER COLUMN opponent_id DROP NOT NULL").Error; migrateErr != nil </span><span class="cov0" title="0">{
                        middleware.Logger.Warn("Failed to drop NOT NULL constraint on game_rooms.opponent_id (ignoring as it likely already is dropped)", slog.String("error", migrateErr.Error()))
                }</span>

                <span class="cov0" title="0">middleware.Logger.Info("Database migration completed")</span>
        }

        // Set connection pooling parameters
        <span class="cov0" title="0">sqlDB, err := dbInstance.DB()
        if err == nil </span><span class="cov0" title="0">{
                sqlDB.SetMaxOpenConns(25)
                sqlDB.SetMaxIdleConns(5)
                sqlDB.SetConnMaxLifetime(5 * time.Minute)
        }</span>

        <span class="cov0" title="0">DB = dbInstance
        return DB, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package featureflags

import (
        "fmt"
        "hash/fnv"
        "strconv"
        "strings"
)

// Manager evaluates feature flags defined in a simple key=value list.
// Example: "new_chat=on,new_feed=25%,legacy_ui=off"
type Manager struct {
        flags map[string]string
}

// NewManager creates a feature-flag manager from a comma-separated config string.
func NewManager(raw string) *Manager <span class="cov3" title="3">{
        out := make(map[string]string)

        for _, pair := range strings.Split(raw, ",") </span><span class="cov6" title="13">{
                pair = strings.TrimSpace(pair)
                if pair == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="13">parts := strings.SplitN(pair, "=", 2)
                if len(parts) != 2 </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov6" title="12">key := normalize(parts[0])
                value := normalize(parts[1])
                if key == "" || value == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="12">out[key] = value</span>
        }

        <span class="cov3" title="3">return &amp;Manager{flags: out}</span>
}

// Enabled returns whether a flag is enabled for a given user.
// Supported values:
// - on/true/1
// - off/false/0
// - N% (deterministic user rollout, e.g. 25%)
func (m *Manager) Enabled(name string, userID uint) bool <span class="cov7" title="18">{
        if m == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov7" title="18">value, ok := m.flags[normalize(name)]
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov7" title="18">switch value </span>{
        case "on", "true", "1":<span class="cov4" title="4">
                return true</span>
        case "off", "false", "0":<span class="cov4" title="4">
                return false</span>
        }

        <span class="cov6" title="10">if strings.HasSuffix(value, "%") </span><span class="cov6" title="10">{
                pctRaw := strings.TrimSuffix(value, "%")
                pct, err := strconv.Atoi(pctRaw)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov6" title="10">if pct &lt;= 0 </span><span class="cov1" title="1">{
                        return false
                }</span>
                <span class="cov6" title="9">if pct &gt;= 100 </span><span class="cov1" title="1">{
                        return true
                }</span>
                <span class="cov5" title="8">if userID == 0 </span><span class="cov1" title="1">{
                        return false
                }</span>
                <span class="cov5" title="7">return rolloutBucket(name, userID) &lt; pct</span>
        }

        <span class="cov0" title="0">return false</span>
}

// Raw returns a copy of configured flags.
func (m *Manager) Raw() map[string]string <span class="cov1" title="1">{
        out := make(map[string]string, len(m.flags))
        for k, v := range m.flags </span><span class="cov3" title="3">{
                out[k] = v
        }</span>
        <span class="cov1" title="1">return out</span>
}

// Snapshot returns evaluated flag status for one user.
func (m *Manager) Snapshot(userID uint) map[string]bool <span class="cov1" title="1">{
        out := make(map[string]bool, len(m.flags))
        for name := range m.flags </span><span class="cov3" title="3">{
                out[name] = m.Enabled(name, userID)
        }</span>
        <span class="cov1" title="1">return out</span>
}

func normalize(s string) string <span class="cov10" title="49">{
        return strings.ToLower(strings.TrimSpace(s))
}</span>

func rolloutBucket(name string, userID uint) int <span class="cov5" title="7">{
        h := fnv.New32a()
        _, _ = h.Write([]byte(fmt.Sprintf("%s:%d", normalize(name), userID)))
        return int(h.Sum32() % 100)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package middleware provides authentication and authorization middleware for the application.
package middleware

import (
        "strconv"
        "strings"

        "sanctum/internal/config"

        "github.com/gofiber/fiber/v2"
        "github.com/golang-jwt/jwt/v5"
)

var cfg *config.Config

// InitMiddleware initializes authentication middleware with the given config.
func InitMiddleware(c *config.Config) <span class="cov4" title="2">{
        cfg = c
}</span>

// AuthRequired is a middleware that enforces authentication for protected routes.
func AuthRequired(c *fiber.Ctx) error <span class="cov10" title="5">{
        authHeader := c.Get("Authorization")
        if authHeader == "" </span><span class="cov1" title="1">{
                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                        "error": "Authorization header required",
                })
        }</span>

        // Extract token from "Bearer &lt;token&gt;"
        <span class="cov8" title="4">parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov1" title="1">{
                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                        "error": "Invalid authorization header format",
                })
        }</span>

        <span class="cov7" title="3">tokenString := parts[1]

        // Parse and validate token
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov4" title="2">{
                // Validate signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fiber.NewError(fiber.StatusUnauthorized, "Invalid signing method")
                }</span>
                <span class="cov4" title="2">return []byte(cfg.JWTSecret), nil</span>
        })

        <span class="cov7" title="3">if err != nil || !token.Valid </span><span class="cov4" title="2">{
                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                        "error": "Invalid or expired token",
                })
        }</span>

        // Extract claims
        <span class="cov1" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                        "error": "Invalid token claims",
                })
        }</span>

        // Extract user ID from "sub" claim (subject claim per RFC 7519)
        <span class="cov1" title="1">subClaim, ok := claims["sub"]
        if !ok </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                        "error": "Invalid token structure - missing subject",
                })
        }</span>

        // Type assertion from interface to string
        <span class="cov1" title="1">subStr, ok := subClaim.(string)
        if !ok </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                        "error": "Invalid token subject type",
                })
        }</span>

        // Parse user ID from string to uint
        <span class="cov1" title="1">userIDVal, err := strconv.ParseUint(subStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                        "error": "Invalid user ID in token",
                })
        }</span>

        // Store user ID in context
        <span class="cov1" title="1">c.Locals("userID", uint(userIDVal))

        return c.Next()</span>
}

// WebSocketAuthRequired is middleware that validates JWT tokens from query parameters for WebSocket connections.
func WebSocketAuthRequired(c *fiber.Ctx) error <span class="cov8" title="4">{
        // Try to get token from query parameter first (for WebSocket)
        token := c.Query("token")
        if token == "" </span><span class="cov4" title="2">{
                // Fall back to Authorization header (for regular HTTP)
                authHeader := c.Get("Authorization")
                if authHeader == "" </span><span class="cov1" title="1">{
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                "error": "Token required",
                        })
                }</span>
                <span class="cov1" title="1">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                "error": "Invalid authorization header format",
                        })
                }</span>
                <span class="cov1" title="1">token = parts[1]</span>
        }

        // Parse and validate token
        <span class="cov7" title="3">parsedToken, err := jwt.Parse(token, func(t *jwt.Token) (interface{}, error) </span><span class="cov4" title="2">{
                if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fiber.NewError(fiber.StatusUnauthorized, "Invalid signing method")
                }</span>
                <span class="cov4" title="2">return []byte(cfg.JWTSecret), nil</span>
        })

        <span class="cov7" title="3">if err != nil || !parsedToken.Valid </span><span class="cov1" title="1">{
                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                        "error": "Invalid or expired token",
                })
        }</span>

        // Extract claims
        <span class="cov4" title="2">claims, ok := parsedToken.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                        "error": "Invalid token claims",
                })
        }</span>

        // Extract user ID from "sub" claim (subject claim per RFC 7519)
        <span class="cov4" title="2">subClaim, ok := claims["sub"]
        if !ok </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                        "error": "Invalid token structure - missing subject",
                })
        }</span>

        // Type assertion from interface to string
        <span class="cov4" title="2">subStr, ok := subClaim.(string)
        if !ok </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                        "error": "Invalid token subject type",
                })
        }</span>

        // Parse user ID from string to uint
        <span class="cov4" title="2">userIDVal, err := strconv.ParseUint(subStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                        "error": "Invalid user ID in token",
                })
        }</span>

        // Store user ID in context
        <span class="cov4" title="2">c.Locals("userID", uint(userIDVal))

        return c.Next()</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "os"
        "time"

        "github.com/gofiber/fiber/v2"
)

// Logger is the global structured logger instance used throughout the application.
var Logger *slog.Logger

type contextKey string

const (
        RequestIDKey contextKey = "request_id"
        UserIDKey    contextKey = "user_id"
)

// ctxHandler is a slog.Handler that adds context values to the log record.
type ctxHandler struct {
        slog.Handler
}

// Handle adds context values to the record before passing it to the underlying handler.
func (h *ctxHandler) Handle(ctx context.Context, r slog.Record) error <span class="cov10" title="2">{
        if rid, ok := ctx.Value(RequestIDKey).(string); ok </span><span class="cov0" title="0">{
                r.AddAttrs(slog.String("request_id", rid))
        }</span>
        <span class="cov10" title="2">if uid, ok := ctx.Value(UserIDKey).(uint); ok </span><span class="cov0" title="0">{
                r.AddAttrs(slog.Any("user_id", uid))
        }</span>
        <span class="cov10" title="2">return h.Handler.Handle(ctx, r)</span>
}

func init() <span class="cov1" title="1">{
        // Initialize a structured logger based on environment
        var handler slog.Handler
        level := slog.LevelInfo

        if os.Getenv("APP_ENV") == "production" </span><span class="cov0" title="0">{
                handler = slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: level})
        }</span> else<span class="cov1" title="1"> {
                // Pretty text output for local development
                handler = slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{Level: level})
        }</span>

        // Wrap with our context-aware handler
        <span class="cov1" title="1">Logger = slog.New(&amp;ctxHandler{handler})</span>
}

// ContextMiddleware injects request ID and user ID from Fiber locals into the request context.
// This allows these values to be picked up by the context-aware logger even in deep service layers.
func ContextMiddleware() fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                ctx := c.UserContext()

                // Extract Request ID
                if rid := c.Locals("requestid"); rid != nil </span><span class="cov0" title="0">{
                        if ridStr, ok := rid.(string); ok </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, RequestIDKey, ridStr)
                        }</span>
                }

                // Extract User ID (may be set later by Auth middleware, so this should ideally run after Auth for user_id)
                // but since we want it for logging all requests, we can just check if it's there.
                <span class="cov0" title="0">if uid := c.Locals("userID"); uid != nil </span><span class="cov0" title="0">{
                        if uidUint, ok := uid.(uint); ok </span><span class="cov0" title="0">{
                                ctx = context.WithValue(ctx, UserIDKey, uidUint)
                        }</span>
                }

                <span class="cov0" title="0">c.SetUserContext(ctx)
                return c.Next()</span>
        }
}

// StructuredLogger returns a Fiber middleware for logging requests using slog
func StructuredLogger() fiber.Handler <span class="cov1" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov10" title="2">{
                start := time.Now()

                // Process request
                err := c.Next()

                // Log details after request is handled
                status := c.Response().StatusCode()
                latency := time.Since(start)

                fields := []any{
                        slog.Int("status", status),
                        slog.String("method", c.Method()),
                        slog.String("path", c.Path()),
                        slog.String("ip", c.IP()),
                        slog.Duration("latency", latency),
                        slog.String("user_agent", c.Get("User-Agent")),
                }

                // We use InfoContext/ErrorContext so that the ctxHandler can pick up the rid/uid
                if err != nil </span><span class="cov1" title="1">{
                        fields = append(fields, slog.String("error", err.Error()))
                        Logger.ErrorContext(c.UserContext(), "request failed", fields...)
                }</span> else<span class="cov1" title="1"> {
                        Logger.InfoContext(c.UserContext(), "request processed", fields...)
                }</span>

                <span class="cov10" title="2">return err</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middleware

import (
        "github.com/ansrivas/fiberprometheus/v2"
        "github.com/gofiber/fiber/v2"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        // ActiveWebSockets tracks the number of currently active WebSocket connections
        ActiveWebSockets = promauto.NewGauge(prometheus.GaugeOpts{
                Name: "sanctum_active_websockets",
                Help: "The total number of active WebSocket connections",
        })

        // DatabaseErrors tracks the number of database operation errors
        DatabaseErrors = promauto.NewCounterVec(prometheus.CounterOpts{
                Name: "sanctum_database_errors_total",
                Help: "The total number of database errors",
        }, []string{"operation"})

        // RedisErrors tracks the number of Redis operation errors
        RedisErrors = promauto.NewCounterVec(prometheus.CounterOpts{
                Name: "sanctum_redis_errors_total",
                Help: "The total number of redis errors",
        }, []string{"operation"})
)

// InitMetrics initializes and returns the Prometheus middleware
func InitMetrics(appName string) *fiberprometheus.FiberPrometheus <span class="cov0" title="0">{
        prometheus := fiberprometheus.New(appName)
        return prometheus
}</span>

// MetricsMiddleware returns a middleware that registers the Prometheus metrics
func MetricsMiddleware(p *fiberprometheus.FiberPrometheus) fiber.Handler <span class="cov0" title="0">{
        return p.Middleware
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package middleware provides authentication and authorization middleware for the application.
package middleware

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/redis/go-redis/v9"
)

// CheckRateLimit checks if a resource has exceeded its rate limit.
// Returns true if allowed, false if limit exceeded.
func CheckRateLimit(ctx context.Context, rdb *redis.Client, resource, id string, limit int, window time.Duration) (bool, error) <span class="cov10" title="3">{
        if os.Getenv("APP_ENV") == "test" </span><span class="cov6" title="2">{
                return true, nil
        }</span>

        <span class="cov1" title="1">if rdb == nil </span><span class="cov1" title="1">{
                return true, nil // Fail-open if Redis is not available
        }</span>

        <span class="cov0" title="0">key := fmt.Sprintf("rl:%s:%s", resource, id)

        // INCR and set EXPIRE if new
        cnt, err := rdb.Incr(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return true, err // Fail-open on Redis error
        }</span>
        <span class="cov0" title="0">if cnt == 1 </span><span class="cov0" title="0">{
                rdb.Expire(ctx, key, window)
        }</span>
        <span class="cov0" title="0">if cnt &gt; int64(limit) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

// RateLimit returns a Fiber middleware enforcing `limit` requests per `window`.
// It keys by authenticated userID (if set in c.Locals("userID")) otherwise by remote IP.
// The optional `name` parameter allows grouping different routes under the same rate limit.
func RateLimit(rdb *redis.Client, limit int, window time.Duration, name ...string) fiber.Handler <span class="cov1" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov1" title="1">{
                ctx := context.Background()

                var id string
                if uid := c.Locals("userID"); uid != nil </span><span class="cov0" title="0">{
                        id = fmt.Sprintf("user:%v", uid)
                }</span> else<span class="cov1" title="1"> {
                        id = fmt.Sprintf("ip:%s", c.IP())
                }</span>

                // Use the provided name or the request path as the resource identifier
                <span class="cov1" title="1">resource := c.Path()
                if len(name) &gt; 0 </span><span class="cov0" title="0">{
                        resource = name[0]
                }</span>

                <span class="cov1" title="1">allowed, err := CheckRateLimit(ctx, rdb, resource, id, limit, window)
                if err != nil </span><span class="cov0" title="0">{
                        // Fail-open
                        return c.Next()
                }</span>

                <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                        // Too many requests
                        return c.Status(fiber.StatusTooManyRequests).JSON(fiber.Map{
                                "error": "rate limit exceeded",
                        })
                }</span>
                <span class="cov1" title="1">return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package models contains data structures for the application's domain models.
package models

import (
        "errors"
        "fmt"

        "github.com/gofiber/fiber/v2"
)

// ErrorResponse represents a standardized API error response
type ErrorResponse struct {
        Error     string `json:"error"`
        Code      string `json:"code,omitempty"`
        Details   string `json:"details,omitempty"`
        RequestID string `json:"request_id,omitempty"`
}

// AppError represents a custom application error
type AppError struct {
        Code    string
        Message string
        Err     error
}

func (e *AppError) Error() string <span class="cov0" title="0">{
        if e.Err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %v", e.Message, e.Err)
        }</span>
        <span class="cov0" title="0">return e.Message</span>
}

func (e *AppError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewNotFoundError creates a new not found error for the given resource.
func NewNotFoundError(resource string, id interface{}) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Code:    "NOT_FOUND",
                Message: fmt.Sprintf("%s with ID %v not found", resource, id),
        }
}</span>

// NewValidationError creates a new validation error with the given message.
func NewValidationError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Code:    "VALIDATION_ERROR",
                Message: message,
        }
}</span>

// NewUnauthorizedError creates a new unauthorized error with the given message.
func NewUnauthorizedError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Code:    "UNAUTHORIZED",
                Message: message,
        }
}</span>

// NewInternalError creates a new internal error wrapping the given error.
func NewInternalError(err error) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Code:    "INTERNAL_ERROR",
                Message: "Internal server error",
                Err:     err,
        }
}</span>

// NewForbiddenError creates a new forbidden error with the given message.
func NewForbiddenError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                Code:    "FORBIDDEN",
                Message: message,
        }
}</span>

// RespondWithError creates a standardized error response
func RespondWithError(c *fiber.Ctx, status int, err error) error <span class="cov0" title="0">{
        var response ErrorResponse
        var appErr *AppError

        rid := ""
        if val := c.Locals("requestid"); val != nil </span><span class="cov0" title="0">{
                rid = fmt.Sprintf("%v", val)
        }</span>

        <span class="cov0" title="0">if errors.As(err, &amp;appErr) </span><span class="cov0" title="0">{
                response = ErrorResponse{
                        Error:     appErr.Message,
                        Code:      appErr.Code,
                        RequestID: rid,
                }
                if appErr.Err != nil </span><span class="cov0" title="0">{
                        response.Details = appErr.Err.Error()
                }</span>
        } else<span class="cov0" title="0"> {
                response = ErrorResponse{
                        Error:     err.Error(),
                        RequestID: rid,
                }
        }</span>
        <span class="cov0" title="0">return c.Status(status).JSON(response)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package models contains data structures for the application's domain models.
package models

import (
        "time"

        "gorm.io/gorm"
)

// FriendshipStatus represents the status of a friendship request.
type FriendshipStatus string

const (
        // FriendshipStatusPending indicates a pending friendship request.
        FriendshipStatusPending FriendshipStatus = "pending"
        // FriendshipStatusAccepted indicates an accepted friendship request.
        FriendshipStatusAccepted FriendshipStatus = "accepted"
        // FriendshipStatusBlocked indicates a blocked friendship.
        FriendshipStatusBlocked FriendshipStatus = "blocked"
)

// Friendship represents a friendship relationship between two users.
type Friendship struct {
        ID          uint             `gorm:"primaryKey" json:"id"`
        RequesterID uint             `gorm:"not null;index:idx_friendship_users" json:"requester_id"`
        AddresseeID uint             `gorm:"not null;index:idx_friendship_users" json:"addressee_id"`
        Status      FriendshipStatus `gorm:"type:varchar(20);default:'pending';index" json:"status"`
        CreatedAt   time.Time        `json:"created_at"`
        UpdatedAt   time.Time        `json:"updated_at"`

        // Relationships
        Requester User `gorm:"foreignKey:RequesterID" json:"requester,omitempty"`
        Addressee User `gorm:"foreignKey:AddresseeID" json:"addressee,omitempty"`
}

// TableName specifies the table name for GORM
func (Friendship) TableName() string <span class="cov0" title="0">{
        return "friendships"
}</span>

// BeforeCreate preserves requester/addressee direction.
// Direction is required to distinguish sent vs received pending requests.
func (f *Friendship) BeforeCreate(_ *gorm.DB) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package models

import (
        "encoding/json"
        "time"

        "gorm.io/gorm"
)

// GameType defines the type of game
type GameType string

const (
        // TicTacToe game type constant
        TicTacToe GameType = "tictactoe"
        // ConnectFour game type constant
        ConnectFour GameType = "connect4"
)

// GameStatus defines the current state of a game
type GameStatus string

const (
        // GamePending indicates game is waiting for players to join
        GamePending GameStatus = "pending"
        // GameActive indicates game is currently being played
        GameActive GameStatus = "active"
        // GameFinished indicates game has ended
        GameFinished GameStatus = "finished"
        // GameCancelled indicates game was aborted
        GameCancelled GameStatus = "cancelled"
)

// GameRoom represents a specific instance of a game
type GameRoom struct {
        ID            uint           `gorm:"primaryKey" json:"id"`
        CreatedAt     time.Time      `json:"created_at"`
        UpdatedAt     time.Time      `json:"updated_at"`
        DeletedAt     gorm.DeletedAt `gorm:"index" json:"-"`
        Type          GameType       `gorm:"not null" json:"type"`
        Status        GameStatus     `gorm:"default:'pending'" json:"status"`
        CreatorID     uint           `gorm:"not null" json:"creator_id"`
        OpponentID    *uint          `json:"opponent_id,omitempty"`
        WinnerID      *uint          `json:"winner_id,omitempty"`
        IsDraw        bool           `gorm:"default:false" json:"is_draw"`
        Configuration string         `gorm:"type:json" json:"configuration,omitempty"` // e.g., board size, game-specific rules
        CurrentState  string         `gorm:"type:json" json:"current_state"`           // Current board state
        NextTurnID    uint           `json:"next_turn_id"`                             // ID of user whose turn it is

        Creator  User `gorm:"foreignKey:CreatorID" json:"creator,omitempty"`
        Opponent User `gorm:"foreignKey:OpponentID" json:"opponent,omitempty"`
        Winner   User `gorm:"foreignKey:WinnerID" json:"winner,omitempty"`
}

// SetState sets the board state (abstracted as JSON)
func (r *GameRoom) SetState(board interface{}) <span class="cov0" title="0">{
        bytes, _ := json.Marshal(board)
        r.CurrentState = string(bytes)
}</span>

// GetTicTacToeState returns the board state as a 3x3 array
func (r *GameRoom) GetTicTacToeState() [3][3]string <span class="cov0" title="0">{
        var board [3][3]string
        if r.CurrentState == "" || r.CurrentState == "{}" </span><span class="cov0" title="0">{
                return board
        }</span>
        <span class="cov0" title="0">_ = json.Unmarshal([]byte(r.CurrentState), &amp;board)
        return board</span>
}

// GetConnectFourState returns the board state as a 6x7 array (rows x cols)
func (r *GameRoom) GetConnectFourState() [6][7]string <span class="cov0" title="0">{
        var board [6][7]string
        if r.CurrentState == "" || r.CurrentState == "{}" </span><span class="cov0" title="0">{
                return board
        }</span>
        <span class="cov0" title="0">_ = json.Unmarshal([]byte(r.CurrentState), &amp;board)
        return board</span>
}

// CheckWin checks if there is a winner based on game type
func (r *GameRoom) CheckWin() (string, bool) <span class="cov0" title="0">{
        switch r.Type </span>{
        case TicTacToe:<span class="cov0" title="0">
                return r.CheckTicTacToeWin()</span>
        case ConnectFour:<span class="cov0" title="0">
                return r.CheckConnectFourWin()</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

// CheckTicTacToeWin checks for a winner in Tic-Tac-Toe
func (r *GameRoom) CheckTicTacToeWin() (string, bool) <span class="cov0" title="0">{
        board := r.GetTicTacToeState()

        // Rows
        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                if board[i][0] != "" &amp;&amp; board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] </span><span class="cov0" title="0">{
                        return board[i][0], true
                }</span>
        }

        // Columns
        <span class="cov0" title="0">for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                if board[0][i] != "" &amp;&amp; board[0][i] == board[1][i] &amp;&amp; board[1][i] == board[2][i] </span><span class="cov0" title="0">{
                        return board[0][i], true
                }</span>
        }

        // Diagonals
        <span class="cov0" title="0">if board[0][0] != "" &amp;&amp; board[0][0] == board[1][1] &amp;&amp; board[1][1] == board[2][2] </span><span class="cov0" title="0">{
                return board[0][0], true
        }</span>
        <span class="cov0" title="0">if board[0][2] != "" &amp;&amp; board[0][2] == board[1][1] &amp;&amp; board[1][1] == board[2][0] </span><span class="cov0" title="0">{
                return board[0][2], true
        }</span>

        // Check Draw
        <span class="cov0" title="0">isDraw := true
        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; 3; j++ </span><span class="cov0" title="0">{
                        if board[i][j] == "" </span><span class="cov0" title="0">{
                                isDraw = false
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if isDraw </span><span class="cov0" title="0">{
                return "", true
        }</span>

        <span class="cov0" title="0">return "", false</span>
}

// CheckConnectFourWin checks for a winner in Connect Four
func (r *GameRoom) CheckConnectFourWin() (string, bool) <span class="cov0" title="0">{
        board := r.GetConnectFourState()
        rows := 6
        cols := 7

        // Check Horizontal
        for r := 0; r &lt; rows; r++ </span><span class="cov0" title="0">{
                for c := 0; c &lt;= cols-4; c++ </span><span class="cov0" title="0">{
                        if board[r][c] != "" &amp;&amp;
                                board[r][c] == board[r][c+1] &amp;&amp;
                                board[r][c+1] == board[r][c+2] &amp;&amp;
                                board[r][c+2] == board[r][c+3] </span><span class="cov0" title="0">{
                                return board[r][c], true
                        }</span>
                }
        }

        // Check Vertical
        <span class="cov0" title="0">for r := 0; r &lt;= rows-4; r++ </span><span class="cov0" title="0">{
                for c := 0; c &lt; cols; c++ </span><span class="cov0" title="0">{
                        if board[r][c] != "" &amp;&amp;
                                board[r][c] == board[r+1][c] &amp;&amp;
                                board[r+1][c] == board[r+2][c] &amp;&amp;
                                board[r+2][c] == board[r+3][c] </span><span class="cov0" title="0">{
                                return board[r][c], true
                        }</span>
                }
        }

        // Check Diagonal (down-right)
        <span class="cov0" title="0">for r := 0; r &lt;= rows-4; r++ </span><span class="cov0" title="0">{
                for c := 0; c &lt;= cols-4; c++ </span><span class="cov0" title="0">{
                        if board[r][c] != "" &amp;&amp;
                                board[r][c] == board[r+1][c+1] &amp;&amp;
                                board[r+1][c+1] == board[r+2][c+2] &amp;&amp;
                                board[r+2][c+2] == board[r+3][c+3] </span><span class="cov0" title="0">{
                                return board[r][c], true
                        }</span>
                }
        }

        // Check Diagonal (up-right)
        <span class="cov0" title="0">for r := 3; r &lt; rows; r++ </span><span class="cov0" title="0">{
                for c := 0; c &lt;= cols-4; c++ </span><span class="cov0" title="0">{
                        if board[r][c] != "" &amp;&amp;
                                board[r][c] == board[r-1][c+1] &amp;&amp;
                                board[r-1][c+1] == board[r-2][c+2] &amp;&amp;
                                board[r-2][c+2] == board[r-3][c+3] </span><span class="cov0" title="0">{
                                return board[r][c], true
                        }</span>
                }
        }

        // Check Draw
        <span class="cov0" title="0">isDraw := true
        for c := 0; c &lt; cols; c++ </span><span class="cov0" title="0">{
                if board[0][c] == "" </span><span class="cov0" title="0">{ // Top row has space
                        isDraw = false
                        break</span>
                }
        }

        <span class="cov0" title="0">if isDraw </span><span class="cov0" title="0">{
                return "", true
        }</span>

        <span class="cov0" title="0">return "", false</span>
}

// GameMove represents a single move made in a game
type GameMove struct {
        ID         uint      `gorm:"primaryKey" json:"id"`
        GameRoomID uint      `gorm:"index" json:"game_room_id"`
        UserID     uint      `json:"user_id"`
        MoveData   string    `gorm:"type:json" json:"move_data"` // JSON representation of the move (e.g., coordinates)
        MoveNumber int       `json:"move_number"`
        CreatedAt  time.Time `json:"created_at"`
}

// GameStats tracks overall performance for a user
type GameStats struct {
        ID         uint     `gorm:"primaryKey" json:"id"`
        UserID     uint     `gorm:"uniqueIndex:idx_user_game" json:"user_id"`
        GameType   GameType `gorm:"uniqueIndex:idx_user_game" json:"game_type"`
        Wins       int      `gorm:"default:0" json:"wins"`
        Losses     int      `gorm:"default:0" json:"losses"`
        Draws      int      `gorm:"default:0" json:"draws"`
        TotalGames int      `gorm:"default:0" json:"total_games"`
        Points     int      `gorm:"default:0" json:"points"`
}

// TicTacToeMove represents a move in Tic-Tac-Toe game.
type TicTacToeMove struct {
        X int `json:"x"`
        Y int `json:"y"`
}

// ConnectFourMove represents a move in Connect Four game.
type ConnectFourMove struct {
        Column int `json:"column"`
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package notifications provides real-time notification delivery and management.
package notifications

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "sync"

        "github.com/gofiber/websocket/v2"
)

// ChatHub manages WebSocket connections for chat conversations.
// Unlike Hub (which is user-centric), ChatHub is conversation-centric.
type ChatHub struct {
        mu sync.RWMutex

        // Map: conversationID -&gt; userID -&gt; Client
        conversations map[uint]map[uint]*Client

        // Map: userID -&gt; set of conversationIDs they're actively viewing
        userActiveConvs map[uint]map[uint]struct{}

        // Map: userID -&gt; set of active Clients (Multi-Device Support)
        userConns map[uint]map[*Client]bool
}

// Name returns a human-readable identifier for this hub.
func (h *ChatHub) Name() string <span class="cov0" title="0">{ return "chat hub" }</span>

// ChatMessage represents a message broadcast to a conversation
type ChatMessage struct {
        Type           string      `json:"type"` // "message", "typing", "presence", "read", "room_message", "user_status", "connected_users"
        ConversationID uint        `json:"conversation_id"`
        RoomID         uint        `json:"room_id,omitempty"`
        UserID         uint        `json:"user_id,omitempty"`
        Username       string      `json:"username,omitempty"`
        Payload        interface{} `json:"payload"`
}

// NewChatHub creates a new ChatHub instance
func NewChatHub() *ChatHub <span class="cov7" title="4">{
        return &amp;ChatHub{
                conversations:   make(map[uint]map[uint]*Client),
                userActiveConvs: make(map[uint]map[uint]struct{}),
                userConns:       make(map[uint]map[*Client]bool),
        }
}</span>

// Register registers a user's websocket connection. Returns Client or error if limits exceeded.
func (h *ChatHub) Register(userID uint, conn *websocket.Conn) (*Client, error) <span class="cov0" title="0">{
        h.mu.Lock()

        // Initialize user connection set if needed
        if h.userConns[userID] == nil </span><span class="cov0" title="0">{
                h.userConns[userID] = make(map[*Client]bool)
        }</span>

        // Enforce per-user limit
        <span class="cov0" title="0">if len(h.userConns[userID]) &gt;= maxConnsPerUser </span><span class="cov0" title="0">{
                h.mu.Unlock()
                return nil, fmt.Errorf("user connection limit reached")
        }</span>

        // Create new client
        <span class="cov0" title="0">client := NewClient(h, conn, userID)
        h.userConns[userID][client] = true

        // Collect online users
        onlineIDs := make([]uint, 0, len(h.userConns))
        for id := range h.userConns </span><span class="cov0" title="0">{
                if id != userID </span><span class="cov0" title="0">{
                        onlineIDs = append(onlineIDs, id)
                }</span>
        }
        <span class="cov0" title="0">h.mu.Unlock()

        log.Printf("ChatHub: Registered user %d (Active clients: %d)", userID, len(h.userConns[userID]))

        // Send initial snapshot
        if len(onlineIDs) &gt; 0 </span><span class="cov0" title="0">{
                snapshotMsg := ChatMessage{
                        Type:    "connected_users",
                        Payload: map[string]interface{}{"user_ids": onlineIDs},
                }
                if jsonMsg, err := json.Marshal(snapshotMsg); err == nil </span><span class="cov0" title="0">{
                        client.TrySend(jsonMsg)
                }</span>
        }

        <span class="cov0" title="0">h.BroadcastGlobalStatus(userID, "online")
        return client, nil</span>
}

// RegisterUser is a legacy wrapper for Register. Deprecated: use Register instead.
func (h *ChatHub) RegisterUser(client *Client) <span class="cov8" title="5">{
        h.mu.Lock()
        if h.userConns[client.UserID] == nil </span><span class="cov7" title="4">{
                h.userConns[client.UserID] = make(map[*Client]bool)
        }</span>
        <span class="cov8" title="5">h.userConns[client.UserID][client] = true
        h.mu.Unlock()
        h.BroadcastGlobalStatus(client.UserID, "online")</span>
}

// UnregisterUser is a legacy wrapper for UnregisterClient.
func (h *ChatHub) UnregisterUser(client *Client) <span class="cov4" title="2">{
        h.UnregisterClient(client)
}</span>

// UnregisterClient removes a user's websocket connection and cleans up all their conversation subscriptions
func (h *ChatHub) UnregisterClient(client *Client) <span class="cov4" title="2">{
        h.mu.Lock()

        // Remove from connection set
        if clients, ok := h.userConns[client.UserID]; ok </span><span class="cov4" title="2">{
                delete(clients, client)
                // If NO more connections for this user, then they are offline
                if len(clients) == 0 </span><span class="cov4" title="2">{
                        delete(h.userConns, client.UserID)
                        // Proceed to cleanup conversation subscriptions
                }</span> else<span class="cov0" title="0"> {
                        // User still has other connections, so just close this one and return
                        h.mu.Unlock()
                        log.Printf("ChatHub: Unregistered client for user %d (Remaining clients: %d)", client.UserID, len(clients))
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // Client not found (already removed)
                h.mu.Unlock()
                return
        }</span>

        // Logic below only runs if ALL connections for this user are gone

        // Remove from all conversations
        <span class="cov4" title="2">if convs, ok := h.userActiveConvs[client.UserID]; ok </span><span class="cov1" title="1">{
                for convID := range convs </span><span class="cov1" title="1">{
                        if users, ok := h.conversations[convID]; ok </span><span class="cov1" title="1">{
                                delete(users, client.UserID)
                                if len(users) == 0 </span><span class="cov1" title="1">{
                                        delete(h.conversations, convID)
                                }</span>
                        }
                }
                <span class="cov1" title="1">delete(h.userActiveConvs, client.UserID)</span>
        }

        <span class="cov4" title="2">h.mu.Unlock()

        log.Printf("ChatHub: Unregistered user %d (All connections closed)", client.UserID)

        // Broadcast "User X is Offline" to everyone else
        h.BroadcastGlobalStatus(client.UserID, "offline")</span>
}

// IsUserOnline returns true when the user has at least one active chat websocket client.
func (h *ChatHub) IsUserOnline(userID uint) bool <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        clients, ok := h.userConns[userID]
        return ok &amp;&amp; len(clients) &gt; 0
}</span>

// JoinConversation subscribes a user to a conversation's messages
func (h *ChatHub) JoinConversation(userID, conversationID uint) <span class="cov6" title="3">{
        h.mu.Lock()
        defer h.mu.Unlock()

        // Get user's client
        // Get user's client set
        clients, ok := h.userConns[userID]
        if !ok </span><span class="cov0" title="0">{
                log.Printf("ChatHub: User %d not connected, cannot join conversation %d", userID, conversationID)
                return
        }</span>

        // Add to conversation map (Just simple user presence in room)
        <span class="cov6" title="3">if h.conversations[conversationID] == nil </span><span class="cov6" title="3">{
                h.conversations[conversationID] = make(map[uint]*Client) // Note: Map value type *Client is legacy, we actually just need boolean presence here
                // But changing `conversations` map type requires more refactoring.
                // For now, we store nil or just any client. It doesn't matter because BroadcastToConversation should iterate userConns.
                // Wait, BroadcastToConversation uses `users := h.conversations[conversationID]`.
                // It iterates `for _, client := range users`.
                // This OLD logic assumes 1 Client per User.
                // We need to FIX `BroadcastToConversation` too.
                // For now, let's keep the map type but ignore the value in new logic.
        }</span>
        // We just mark presence:
        // We just mark presence:
        // We need to provide a single *Client to satisfy the map type for now.
        // Since BroadcastToConversation ignores this value (it uses userConns), any valid client works.
        <span class="cov6" title="3">var anyClient *Client
        for c := range clients </span><span class="cov6" title="3">{
                anyClient = c
                break</span>
        }
        <span class="cov6" title="3">h.conversations[conversationID][userID] = anyClient

        // Track active conversation for user
        if h.userActiveConvs[userID] == nil </span><span class="cov6" title="3">{
                h.userActiveConvs[userID] = make(map[uint]struct{})
        }</span>
        <span class="cov6" title="3">h.userActiveConvs[userID][conversationID] = struct{}{}

        log.Printf("ChatHub: User %d joined conversation %d", userID, conversationID)</span>
}

// LeaveConversation unsubscribes a user from a conversation
func (h *ChatHub) LeaveConversation(userID, conversationID uint) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        // Remove from conversation
        if users, ok := h.conversations[conversationID]; ok </span><span class="cov0" title="0">{
                delete(users, userID)
                if len(users) == 0 </span><span class="cov0" title="0">{
                        delete(h.conversations, conversationID)
                }</span>
        }

        // Remove from user's active conversations
        <span class="cov0" title="0">if convs, ok := h.userActiveConvs[userID]; ok </span><span class="cov0" title="0">{
                delete(convs, conversationID)
        }</span>

        <span class="cov0" title="0">log.Printf("ChatHub: User %d left conversation %d", userID, conversationID)</span>
}

// BroadcastToConversation sends a message to all users in a conversation
func (h *ChatHub) BroadcastToConversation(conversationID uint, message ChatMessage) <span class="cov4" title="2">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        users, ok := h.conversations[conversationID]
        if !ok </span><span class="cov0" title="0">{
                log.Printf("ChatHub: No active users in conversation %d", conversationID)
                return
        }</span>

        <span class="cov4" title="2">messageJSON, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ChatHub: Failed to marshal message: %v", err)
                return
        }</span>

        // Send to all connected users in this conversation
        // Iterate UserIDs in the conversation
        <span class="cov4" title="2">for userID := range users </span><span class="cov4" title="2">{
                // For each user, send to ALL their active clients
                if clients, ok := h.userConns[userID]; ok </span><span class="cov4" title="2">{
                        for client := range clients </span><span class="cov6" title="3">{
                                client.TrySend(messageJSON)
                        }</span>
                }
        }

        <span class="cov4" title="2">log.Printf("ChatHub: Broadcast to conversation %d (%d users)", conversationID, len(users))</span>
}

// BroadcastToAllUsers sends a message to every connected websocket client.
func (h *ChatHub) BroadcastToAllUsers(message ChatMessage) <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        messageJSON, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ChatHub: Failed to marshal global message: %v", err)
                return
        }</span>

        <span class="cov0" title="0">for _, clients := range h.userConns </span><span class="cov0" title="0">{
                for client := range clients </span><span class="cov0" title="0">{
                        client.TrySend(messageJSON)
                }</span>
        }
}

// GetActiveUsers returns the list of userIDs currently viewing a conversation
func (h *ChatHub) GetActiveUsers(conversationID uint) []uint <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        users, ok := h.conversations[conversationID]
        if !ok </span><span class="cov0" title="0">{
                return []uint{}
        }</span>

        <span class="cov0" title="0">result := make([]uint, 0, len(users))
        for userID := range users </span><span class="cov0" title="0">{
                result = append(result, userID)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// IsUserActive checks if a user is currently viewing a conversation
func (h *ChatHub) IsUserActive(userID, conversationID uint) bool <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        if convs, ok := h.userActiveConvs[userID]; ok </span><span class="cov0" title="0">{
                _, active := convs[conversationID]
                return active
        }</span>
        <span class="cov0" title="0">return false</span>
}

// StartWiring connects the ChatHub to Redis pub/sub for conversation messages
func (h *ChatHub) StartWiring(ctx context.Context, n *Notifier) error <span class="cov0" title="0">{
        return n.StartChatSubscriber(ctx, func(channel, payload string) </span><span class="cov0" title="0">{
                // channel format: chat:conv:&lt;id&gt; or typing:conv:&lt;id&gt; or presence:conv:&lt;id&gt;
                var conversationID uint
                var msgType string

                // Parse channel to determine type and conversation ID
                if _, err := fmt.Sscanf(channel, "chat:conv:%d", &amp;conversationID); err == nil </span><span class="cov0" title="0">{
                        msgType = "message"
                }</span> else<span class="cov0" title="0"> if _, err := fmt.Sscanf(channel, "typing:conv:%d", &amp;conversationID); err == nil </span><span class="cov0" title="0">{
                        msgType = "typing"
                }</span> else<span class="cov0" title="0"> if _, err := fmt.Sscanf(channel, "presence:conv:%d", &amp;conversationID); err == nil </span><span class="cov0" title="0">{
                        msgType = "presence"
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("ChatHub: Invalid channel format: %s", channel)
                        return
                }</span>

                // Parse the payload
                <span class="cov0" title="0">var message ChatMessage
                if err := json.Unmarshal([]byte(payload), &amp;message); err != nil </span><span class="cov0" title="0">{
                        log.Printf("ChatHub: Failed to parse message from channel %s: %v", channel, err)
                        return
                }</span>

                // Ensure type is set
                <span class="cov0" title="0">if message.Type == "" </span><span class="cov0" title="0">{
                        message.Type = msgType
                }</span>
                <span class="cov0" title="0">message.ConversationID = conversationID

                // Broadcast to all users in the conversation
                h.BroadcastToConversation(conversationID, message)</span>
        })
}

// BroadcastGlobalStatus sends a "user_status" event (online/offline) to ALL connected users
func (h *ChatHub) BroadcastGlobalStatus(userID uint, status string) <span class="cov10" title="7">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        message := ChatMessage{
                Type:    "user_status",
                UserID:  userID,
                Payload: map[string]interface{}{"status": status, "user_id": userID},
        }

        jsonMsg, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ChatHub: Failed to marshal status message: %v", err)
                return
        }</span>

        <span class="cov10" title="7">for id, clients := range h.userConns </span><span class="cov8" title="5">{
                // Don't echo back to the user who triggered it (optional, but good for noise reduction)
                if id == userID </span><span class="cov8" title="5">{
                        continue</span>
                }

                <span class="cov0" title="0">for client := range clients </span><span class="cov0" title="0">{
                        client.TrySend(jsonMsg)
                }</span>
        }
}

// Shutdown gracefully closes all websocket connections
func (h *ChatHub) Shutdown(_ context.Context) error <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        // Close all user connections
        for userID, clients := range h.userConns </span><span class="cov0" title="0">{
                for client := range clients </span><span class="cov0" title="0">{
                        if err := client.Conn.WriteMessage(1, // TextMessage
                                []byte(`{"type":"server_shutdown","message":"Server is shutting down"}`)); err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to write shutdown message for user %d: %v", userID, err)
                        }</span>
                        <span class="cov0" title="0">if err := client.Conn.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to close websocket for user %d: %v", userID, err)
                        }</span>
                }
        }

        // Clear all state
        <span class="cov0" title="0">h.conversations = make(map[uint]map[uint]*Client)
        h.userActiveConvs = make(map[uint]map[uint]struct{})
        h.userConns = make(map[uint]map[*Client]bool)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package notifications

import (
        "log"
        "time"

        "github.com/gofiber/websocket/v2"
)

const (
        // Time allowed to write a message to the peer.
        writeWait = 10 * time.Second

        // Time allowed to read the next pong message from the peer.
        pongWait = 60 * time.Second

        // Send pings to peer with this period. Must be less than pongWait.
        pingPeriod = (pongWait * 9) / 10

        // Maximum message size allowed from peer.
        maxMessageSize = 16384
)

// WSHub is an interface for hubs that manage generic clients
type WSHub interface {
        UnregisterClient(c *Client)
}

// Client is a generic middleman between the websocket connection and a hub.
type Client struct {
        Hub WSHub

        // The websocket connection.
        Conn *websocket.Conn

        // Buffered channel of outbound messages.
        Send chan []byte

        // UserID for this client
        UserID uint

        // Callback for handling incoming messages
        IncomingHandler func(*Client, []byte)
}

// NewClient creates a new Client instance
func NewClient(hub WSHub, conn *websocket.Conn, userID uint) *Client <span class="cov6" title="11">{
        return &amp;Client{
                Hub:    hub,
                Conn:   conn,
                UserID: userID,
                Send:   make(chan []byte, 256),
        }
}</span>

// ReadPump pumps messages from the websocket connection to the hub.
func (c *Client) ReadPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.Hub.UnregisterClient(c)
                _ = c.Conn.Close()
        }</span>()

        <span class="cov0" title="0">c.Conn.SetReadLimit(maxMessageSize)
        _ = c.Conn.SetReadDeadline(time.Now().Add(pongWait))
        c.Conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{ _ = c.Conn.SetReadDeadline(time.Now().Add(pongWait)); return nil }</span>)

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, message, err := c.Conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("ReadPump Error (User %d): %v", c.UserID, err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov0" title="0">if c.IncomingHandler != nil </span><span class="cov0" title="0">{
                        c.IncomingHandler(c, message)
                }</span>
        }
}

// WritePump pumps messages from the hub to the websocket connection.
func (c *Client) WritePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(pingPeriod)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                _ = c.Conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.Send:<span class="cov0" title="0">
                        _ = c.Conn.SetWriteDeadline(time.Now().Add(writeWait))
                        if !ok </span><span class="cov0" title="0">{
                                // The hub closed the channel.
                                _ = c.Conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">w, err := c.Conn.NextWriter(websocket.TextMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">_, _ = w.Write(message)

                        if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        _ = c.Conn.SetWriteDeadline(time.Now().Add(writeWait))
                        if err := c.Conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// TrySend attempts to send a message to the client, handling closed channels and full buffers
func (c *Client) TrySend(message []byte) <span class="cov10" title="59">{
        defer func() </span><span class="cov10" title="59">{
                _ = recover() // Recover from panic if channel is closed
        }</span>()

        <span class="cov10" title="59">select </span>{
        case c.Send &lt;- message:<span class="cov10" title="59"></span>
        default:<span class="cov0" title="0">
                // Buffer full, drop message
                log.Printf("Client %d: Buffer full, dropped message", c.UserID)</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package notifications

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "sync"

        "sanctum/internal/models"

        "gorm.io/gorm"
)

// GameAction represents a message sent via WebSocket for games
type GameAction struct {
        Type    string      `json:"type"` // "create_room", "join_room", "make_move", "chat", "game_state", "error"
        RoomID  uint        `json:"room_id,omitempty"`
        UserID  uint        `json:"user_id,omitempty"`
        Payload interface{} `json:"payload"`
}

// GameHub manages real-time game interaction
type GameHub struct {
        mu sync.RWMutex

        // Map: roomID -&gt; userID -&gt; client
        rooms map[uint]map[uint]*Client

        // Map: userID -&gt; set of rooms they are in
        userRooms map[uint]map[uint]struct{}

        db       *gorm.DB
        notifier *Notifier
}

// Name returns a human-readable identifier for this hub.
func (h *GameHub) Name() string <span class="cov0" title="0">{ return "game hub" }</span>

// NewGameHub creates a new GameHub instance
func NewGameHub(db *gorm.DB, notifier *Notifier) *GameHub <span class="cov10" title="3">{
        return &amp;GameHub{
                rooms:     make(map[uint]map[uint]*Client),
                userRooms: make(map[uint]map[uint]struct{}),
                db:        db,
                notifier:  notifier,
        }
}</span>

// RegisterClient registers a user's client in a room
func (h *GameHub) RegisterClient(roomID uint, client *Client) <span class="cov10" title="3">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if h.rooms[roomID] == nil </span><span class="cov6" title="2">{
                h.rooms[roomID] = make(map[uint]*Client)
        }</span>
        <span class="cov10" title="3">h.rooms[roomID][client.UserID] = client

        if h.userRooms[client.UserID] == nil </span><span class="cov6" title="2">{
                h.userRooms[client.UserID] = make(map[uint]struct{})
        }</span>
        <span class="cov10" title="3">h.userRooms[client.UserID][roomID] = struct{}{}

        log.Printf("GameHub: User %d registered in room %d", client.UserID, roomID)</span>
}

// UnregisterClient removes a user's client from all rooms
func (h *GameHub) UnregisterClient(client *Client) <span class="cov10" title="3">{
        h.mu.Lock()
        defer h.mu.Unlock()

        userID := client.UserID
        rooms, ok := h.userRooms[userID]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        // Remove only the rooms for which this exact client is registered.
        // This avoids deleting tracking when a newer socket replaced an old one.
        <span class="cov10" title="3">for roomID := range rooms </span><span class="cov10" title="3">{
                if room, ok := h.rooms[roomID]; ok </span><span class="cov10" title="3">{
                        if c, ok := room[userID]; ok &amp;&amp; c == client </span><span class="cov6" title="2">{
                                // Remove this client's registration for the room
                                delete(room, userID)
                                // If room is now empty, remove it entirely
                                if len(room) == 0 </span><span class="cov6" title="2">{
                                        delete(h.rooms, roomID)
                                }</span>

                                // Also remove the room from the user's tracked set
                                <span class="cov6" title="2">delete(h.userRooms[userID], roomID)

                                // Database cleanup: If the creator leaves a pending room, cancel it
                                var gRoom models.GameRoom
                                if err := h.db.First(&amp;gRoom, roomID).Error; err == nil </span><span class="cov6" title="2">{
                                        if gRoom.Status == models.GamePending &amp;&amp; gRoom.CreatorID == userID </span><span class="cov0" title="0">{
                                                gRoom.Status = models.GameCancelled
                                                h.db.Save(&amp;gRoom)
                                                log.Printf("GameHub: Pending room %d cancelled because creator (User %d) disconnected", roomID, userID)
                                        }</span>
                                }
                        }
                }
        }

        // If the user has no remaining tracked rooms, remove the entry entirely
        <span class="cov10" title="3">if len(h.userRooms[userID]) == 0 </span><span class="cov6" title="2">{
                delete(h.userRooms, userID)
        }</span>
}

// BroadcastToRoom sends a message to all users in a game room
func (h *GameHub) BroadcastToRoom(roomID uint, action GameAction) <span class="cov1" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        users, ok := h.rooms[roomID]
        if !ok </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov0" title="0">actionJSON, err := json.Marshal(action)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("GameHub: Failed to marshal action: %v", err)
                return
        }</span>

        <span class="cov0" title="0">for _, client := range users </span><span class="cov0" title="0">{
                client.TrySend(actionJSON)
        }</span>
}

// HandleAction processes an incoming game action
func (h *GameHub) HandleAction(userID uint, action GameAction) <span class="cov0" title="0">{
        switch action.Type </span>{
        case "join_room":<span class="cov0" title="0">
                h.handleJoin(userID, action)</span>
        case "make_move":<span class="cov0" title="0">
                h.handleMove(userID, action)</span>
        case "chat":<span class="cov0" title="0">
                h.handleChat(userID, action)</span>
        default:<span class="cov0" title="0">
                log.Printf("GameHub: Unknown action type %s from user %d", action.Type, userID)</span>
        }
}

func (h *GameHub) handleJoin(userID uint, action GameAction) <span class="cov1" title="1">{
        var room models.GameRoom
        if err := h.db.First(&amp;room, action.RoomID).Error; err != nil </span><span class="cov0" title="0">{
                h.sendError(userID, action.RoomID, "Game room not found")
                return
        }</span>

        <span class="cov1" title="1">if room.Status != models.GamePending </span><span class="cov0" title="0">{
                h.sendError(userID, action.RoomID, "Game already started or finished")
                return
        }</span>

        <span class="cov1" title="1">if room.CreatorID == userID </span><span class="cov0" title="0">{
                h.sendError(userID, action.RoomID, "You are the creator")
                return
        }</span>

        // Join as opponent
        <span class="cov1" title="1">room.OpponentID = &amp;userID
        room.Status = models.GameActive
        room.NextTurnID = room.CreatorID // Creator goes first

        if err := h.db.Save(&amp;room).Error; err != nil </span><span class="cov0" title="0">{
                h.sendError(userID, action.RoomID, "Failed to start game")
                return
        }</span>

        <span class="cov1" title="1">started := GameAction{
                Type:   "game_started",
                RoomID: action.RoomID,
                Payload: map[string]interface{}{
                        "status":        "active",
                        "next_turn":     room.NextTurnID,
                        "opponent_id":   userID,
                        "creator_id":    room.CreatorID,
                        "room_id":       room.ID,
                        "updated_at":    room.UpdatedAt,
                        "current_state": room.CurrentState,
                },
        }

        // Always broadcast directly to currently connected sockets in this process.
        h.BroadcastToRoom(action.RoomID, started)

        // Also publish through Redis for cross-process fanout when available.
        if h.notifier != nil </span><span class="cov0" title="0">{
                _ = h.notifier.PublishGameAction(
                        context.Background(),
                        action.RoomID,
                        `{"type": "game_started", "payload": {"status": "active", "next_turn": `+fmt.Sprint(room.NextTurnID)+`}}`,
                )
        }</span>
}

func (h *GameHub) handleMove(userID uint, action GameAction) <span class="cov0" title="0">{
        var room models.GameRoom
        if err := h.db.First(&amp;room, action.RoomID).Error; err != nil </span><span class="cov0" title="0">{
                h.sendError(userID, action.RoomID, "Game room not found")
                return
        }</span>

        <span class="cov0" title="0">if room.Status != models.GameActive || room.NextTurnID != userID </span><span class="cov0" title="0">{
                h.sendError(userID, action.RoomID, "Not your turn")
                return
        }</span>

        <span class="cov0" title="0">moveBytes, _ := json.Marshal(action.Payload)

        var board interface{}
        var symbol string
        if room.OpponentID != nil &amp;&amp; userID == *room.OpponentID </span><span class="cov0" title="0">{
                symbol = "O"
        }</span> else<span class="cov0" title="0"> {
                symbol = "X"
        }</span>

        <span class="cov0" title="0">if room.Type == models.TicTacToe </span><span class="cov0" title="0">{
                var moveData models.TicTacToeMove
                if err := json.Unmarshal(moveBytes, &amp;moveData); err != nil </span><span class="cov0" title="0">{
                        h.sendError(userID, action.RoomID, "Invalid move format")
                        return
                }</span>

                <span class="cov0" title="0">tttBoard := room.GetTicTacToeState()
                if moveData.X &lt; 0 || moveData.X &gt; 2 || moveData.Y &lt; 0 || moveData.Y &gt; 2 || tttBoard[moveData.X][moveData.Y] != "" </span><span class="cov0" title="0">{
                        h.sendError(userID, action.RoomID, "Invalid move location")
                        return
                }</span>
                <span class="cov0" title="0">tttBoard[moveData.X][moveData.Y] = symbol
                board = tttBoard
                room.SetState(tttBoard)</span>
        } else<span class="cov0" title="0"> if room.Type == models.ConnectFour </span><span class="cov0" title="0">{
                var moveData models.ConnectFourMove
                if err := json.Unmarshal(moveBytes, &amp;moveData); err != nil </span><span class="cov0" title="0">{
                        h.sendError(userID, action.RoomID, "Invalid move format")
                        return
                }</span>

                <span class="cov0" title="0">c4Board := room.GetConnectFourState()
                if moveData.Column &lt; 0 || moveData.Column &gt; 6 || c4Board[0][moveData.Column] != "" </span><span class="cov0" title="0">{
                        h.sendError(userID, action.RoomID, "Invalid move location or column full")
                        return
                }</span>

                // Gravity: find lowest empty row
                <span class="cov0" title="0">found := false
                for r := 5; r &gt;= 0; r-- </span><span class="cov0" title="0">{
                        if c4Board[r][moveData.Column] == "" </span><span class="cov0" title="0">{
                                c4Board[r][moveData.Column] = symbol
                                found = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        h.sendError(userID, action.RoomID, "Column is full")
                        return
                }</span>

                <span class="cov0" title="0">board = c4Board
                room.SetState(c4Board)</span>
        }

        // Persist move
        <span class="cov0" title="0">moveRecord := models.GameMove{
                GameRoomID: room.ID,
                UserID:     userID,
                MoveData:   string(moveBytes),
        }
        h.db.Create(&amp;moveRecord)

        // Check for win/draw
        winnerSym, finished := room.CheckWin()
        if finished </span><span class="cov0" title="0">{
                room.Status = models.GameFinished
                if winnerSym != "" </span><span class="cov0" title="0">{
                        winID := room.CreatorID
                        if winnerSym == "O" &amp;&amp; room.OpponentID != nil </span><span class="cov0" title="0">{
                                winID = *room.OpponentID
                        }</span>
                        <span class="cov0" title="0">room.WinnerID = &amp;winID
                        // Award points
                        points := 10
                        if room.Type == models.ConnectFour </span><span class="cov0" title="0">{
                                points = 15
                        }</span>
                        <span class="cov0" title="0">h.db.Model(&amp;models.GameStats{}).Where("user_id = ? AND game_type = ?", winID, room.Type).
                                Update("points", gorm.Expr("points + ?", points)).
                                Update("wins", gorm.Expr("wins + ?", 1)).
                                Update("total_games", gorm.Expr("total_games + ?", 1))

                        lossID := room.CreatorID
                        if winID == room.CreatorID &amp;&amp; room.OpponentID != nil </span><span class="cov0" title="0">{
                                lossID = *room.OpponentID
                        }</span>
                        <span class="cov0" title="0">h.db.Model(&amp;models.GameStats{}).Where("user_id = ? AND game_type = ?", lossID, room.Type).
                                Update("losses", gorm.Expr("losses + ?", 1)).
                                Update("total_games", gorm.Expr("total_games + ?", 1))</span>
                } else<span class="cov0" title="0"> {
                        room.IsDraw = true
                        opponentID := uint(0)
                        if room.OpponentID != nil </span><span class="cov0" title="0">{
                                opponentID = *room.OpponentID
                        }</span>
                        <span class="cov0" title="0">h.db.Model(&amp;models.GameStats{}).Where("user_id IN (?, ?) AND game_type = ?", room.CreatorID, opponentID, room.Type).
                                Update("draws", gorm.Expr("draws + ?", 1)).
                                Update("total_games", gorm.Expr("total_games + ?", 1))</span>
                }
        } else<span class="cov0" title="0"> {
                // Switch turn
                if userID == room.CreatorID &amp;&amp; room.OpponentID != nil </span><span class="cov0" title="0">{
                        room.NextTurnID = *room.OpponentID
                }</span> else<span class="cov0" title="0"> {
                        room.NextTurnID = room.CreatorID
                }</span>
        }

        <span class="cov0" title="0">h.db.Save(&amp;room)

        // Broadcast update
        action.Type = "game_state"
        action.Payload = map[string]interface{}{
                "board":     board,
                "status":    room.Status,
                "winner_id": room.WinnerID,
                "next_turn": room.NextTurnID,
                "is_draw":   room.IsDraw,
        }
        actionJSON, _ := json.Marshal(action)
        _ = h.notifier.PublishGameAction(context.Background(), action.RoomID, string(actionJSON))</span>
}

func (h *GameHub) handleChat(_ uint, action GameAction) <span class="cov0" title="0">{
        // Simple chat broadcast
        h.BroadcastToRoom(action.RoomID, action)
}</span>

func (h *GameHub) sendError(userID, roomID uint, message string) <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        room, ok := h.rooms[roomID]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, ok := room[userID]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp := GameAction{
                Type:   "error",
                RoomID: roomID,
                Payload: map[string]string{
                        "message": message,
                },
        }
        respJSON, _ := json.Marshal(resp)
        client.TrySend(respJSON)</span>
}

// StartWiring connects GameHub to Redis
func (h *GameHub) StartWiring(ctx context.Context, n *Notifier) error <span class="cov0" title="0">{
        return n.StartGameSubscriber(ctx, func(channel, payload string) </span><span class="cov0" title="0">{
                var roomID uint
                if _, err := fmt.Sscanf(channel, "game:room:%d", &amp;roomID); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">var action GameAction
                if err := json.Unmarshal([]byte(payload), &amp;action); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">action.RoomID = roomID

                h.BroadcastToRoom(roomID, action)</span>
        })
}

// Shutdown gracefully closes all websocket connections
func (h *GameHub) Shutdown(_ context.Context) error <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        // Close all room connections
        for roomID, users := range h.rooms </span><span class="cov0" title="0">{
                for userID, client := range users </span><span class="cov0" title="0">{
                        shutdownMsg := GameAction{
                                Type:    "server_shutdown",
                                RoomID:  roomID,
                                Payload: map[string]string{"message": "Server is shutting down"},
                        }
                        if msgJSON, err := json.Marshal(shutdownMsg); err == nil </span><span class="cov0" title="0">{
                                client.TrySend(msgJSON)
                        }</span>
                        <span class="cov0" title="0">if err := client.Conn.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to close websocket in room %d for user %d: %v", roomID, userID, err)
                        }</span>
                }
        }

        // Clear all state
        <span class="cov0" title="0">h.rooms = make(map[uint]map[uint]*Client)
        h.userRooms = make(map[uint]map[uint]struct{})

        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package notifications provides real-time notification delivery and management.
package notifications

import (
        "context"
        "errors"
        "fmt"
        "log"
        "strings"
        "sync"

        "github.com/gofiber/websocket/v2"
)

const (
        // Max connections per user
        maxConnsPerUser = 12
        // Max total connections
        maxTotalConns = 10000
)

// Hub is a websocket hub that maps userID -&gt; list of Clients.
type Hub struct {
        mu         sync.RWMutex
        conns      map[uint]map[*Client]struct{}
        totalConns int
        shutdown   chan struct{}
        done       chan struct{}
}

// Name returns a human-readable identifier for this hub.
func (h *Hub) Name() string <span class="cov0" title="0">{ return "notification hub" }</span>

// NewHub creates a new Hub instance for managing notifications.
func (h *Hub) UnregisterClient(client *Client) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        if m, ok := h.conns[client.UserID]; ok </span><span class="cov0" title="0">{
                if _, exists := m[client]; exists </span><span class="cov0" title="0">{
                        delete(m, client)
                        h.totalConns--
                }</span>
                <span class="cov0" title="0">if len(m) == 0 </span><span class="cov0" title="0">{
                        delete(h.conns, client.UserID)
                }</span>
        }
}

// Register a connection for a given userID. Returns the Client or error if limits exceeded.
func (h *Hub) Register(userID uint, conn *websocket.Conn) (*Client, error) <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if h.totalConns &gt;= maxTotalConns </span><span class="cov0" title="0">{
                return nil, errors.New("server connection limit reached")
        }</span>

        <span class="cov0" title="0">m, ok := h.conns[userID]
        if !ok </span><span class="cov0" title="0">{
                m = make(map[*Client]struct{})
                h.conns[userID] = m
        }</span>

        <span class="cov0" title="0">if len(m) &gt;= maxConnsPerUser </span><span class="cov0" title="0">{
                return nil, errors.New("user connection limit reached")
        }</span>

        <span class="cov0" title="0">client := NewClient(h, conn, userID)

        m[client] = struct{}{}
        h.totalConns++

        return client, nil</span>
}

// NewHub creates a new Hub instance for managing notifications.
func NewHub() *Hub <span class="cov0" title="0">{
        return &amp;Hub{
                conns:    make(map[uint]map[*Client]struct{}),
                shutdown: make(chan struct{}),
                done:     make(chan struct{}),
        }
}</span>

// Broadcast sends message to all connections for userID
func (h *Hub) Broadcast(userID uint, message string) <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        if clients, ok := h.conns[userID]; ok </span><span class="cov0" title="0">{
                data := []byte(message)
                for c := range clients </span><span class="cov0" title="0">{
                        select </span>{
                        case c.Send &lt;- data:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                // Backpressure: Drop message if buffer full to avoid blocking the hub
                                log.Printf("Backpressure: dropping message for user %d (buffer full)", userID)</span>
                        }
                }
        }
}

// IsOnline reports whether a user currently has at least one active websocket connection.
func (h *Hub) IsOnline(userID uint) bool <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        clients, ok := h.conns[userID]
        return ok &amp;&amp; len(clients) &gt; 0
}</span>

// BroadcastAll sends message to every connected websocket client.
func (h *Hub) BroadcastAll(message string) <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        data := []byte(message)
        for _, clients := range h.conns </span><span class="cov0" title="0">{
                for c := range clients </span><span class="cov0" title="0">{
                        select </span>{
                        case c.Send &lt;- data:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0"></span>
                                // Backpressure
                        }
                }
        }
}

// StartWiring connects the Notifier to this hub: it subscribes to Redis pattern and
// forwards messages to matching userID connections.
func (h *Hub) StartWiring(ctx context.Context, n *Notifier) error <span class="cov0" title="0">{
        return n.StartPatternSubscriber(ctx, func(channel, payload string) </span><span class="cov0" title="0">{
                if channel == "notifications:broadcast" </span><span class="cov0" title="0">{
                        h.BroadcastAll(payload)
                        return
                }</span>
                <span class="cov0" title="0">if !strings.HasPrefix(channel, "notifications:user:") </span><span class="cov0" title="0">{
                        log.Printf("invalid notification channel: %s", channel)
                        return
                }</span>
                // channel form: notifications:user:&lt;id&gt;
                <span class="cov0" title="0">var userID uint
                // simple parse
                _, err := fmt.Sscanf(channel, "notifications:user:%d", &amp;userID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("invalid notification channel: %s", channel)
                        return
                }</span>
                <span class="cov0" title="0">h.Broadcast(userID, payload)</span>
        })
}

// Shutdown gracefully closes all websocket connections
func (h *Hub) Shutdown(_ context.Context) error <span class="cov0" title="0">{
        close(h.shutdown)

        // Close all connections gracefully
        h.mu.Lock()
        for userID, userConns := range h.conns </span><span class="cov0" title="0">{
                for client := range userConns </span><span class="cov0" title="0">{
                        // Send close message to client
                        if err := client.Conn.WriteMessage(websocket.CloseMessage,
                                websocket.FormatCloseMessage(websocket.CloseGoingAway, "Server shutting down")); err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to write close message for user %d: %v", userID, err)
                        }</span>
                        // Close the connection
                        <span class="cov0" title="0">if err := client.Conn.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to close websocket for user %d: %v", userID, err)
                        }</span>
                }
        }
        // Clear all connections
        <span class="cov0" title="0">h.conns = make(map[uint]map[*Client]struct{})
        h.mu.Unlock()

        // Signal completion
        close(h.done)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package notifications provides real-time notification delivery and management.
package notifications

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"

        "github.com/redis/go-redis/v9"
)

// Notifier provides helpers to publish notifications into Redis channels
type Notifier struct {
        rdb *redis.Client
}

// NewNotifier creates a new Notifier instance using the provided Redis client.
func NewNotifier(rdb *redis.Client) *Notifier <span class="cov1" title="1">{
        return &amp;Notifier{rdb: rdb}
}</span>

// PublishUser sends a notification payload to a user's channel.
func (n *Notifier) PublishUser(
        ctx context.Context, userID uint, payload string,
) error <span class="cov1" title="1">{
        if n.rdb == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">channel := fmt.Sprintf("notifications:user:%d", userID)
        return n.rdb.Publish(ctx, channel, payload).Err()</span>
}

// PublishBroadcast sends a notification payload to all connected users.
func (n *Notifier) PublishBroadcast(ctx context.Context, payload string) error <span class="cov0" title="0">{
        if n.rdb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return n.rdb.Publish(ctx, "notifications:broadcast", payload).Err()</span>
}

// StartPatternSubscriber subscribes to pattern `notifications:user:*` and calls onMessage
// for each incoming message. onMessage receives channel and payload.
func (n *Notifier) StartPatternSubscriber(
        ctx context.Context, onMessage func(channel string, payload string),
) error <span class="cov0" title="0">{
        if n.rdb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">sub := n.rdb.PSubscribe(ctx, "notifications:user:*", "notifications:broadcast")
        ch := sub.Channel()

        go func() </span><span class="cov0" title="0">{
                for msg := range ch </span><span class="cov0" title="0">{
                        // Example channel: notifications:user:123
                        onMessage(msg.Channel, msg.Payload)
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

// PublishChatMessage publishes a chat message to a conversation channel
func (n *Notifier) PublishChatMessage(
        ctx context.Context, conversationID uint, payload string,
) error <span class="cov0" title="0">{
        if n.rdb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">channel := fmt.Sprintf("chat:conv:%d", conversationID)
        return n.rdb.Publish(ctx, channel, payload).Err()</span>
}

// PublishTypingIndicator publishes a typing indicator to a conversation
func (n *Notifier) PublishTypingIndicator(
        ctx context.Context, conversationID, userID uint, username string, isTyping bool,
) error <span class="cov0" title="0">{
        if n.rdb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">channel := fmt.Sprintf("typing:conv:%d", conversationID)
        payload := map[string]interface{}{
                "user_id":   userID,
                "username":  username,
                "is_typing": isTyping,
        }
        payloadJSON, _ := json.Marshal(payload)
        return n.rdb.Publish(ctx, channel, string(payloadJSON)).Err()</span>
}

// PublishPresence publishes a user's presence status to a conversation
func (n *Notifier) PublishPresence(
        ctx context.Context, conversationID, userID uint, username, status string,
) error <span class="cov0" title="0">{
        if n.rdb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">channel := fmt.Sprintf("presence:conv:%d", conversationID)
        payload := map[string]interface{}{
                "user_id":  userID,
                "username": username,
                "status":   status, // "online", "offline", "away"
        }
        payloadJSON, _ := json.Marshal(payload)
        return n.rdb.Publish(ctx, channel, string(payloadJSON)).Err()</span>
}

// StartChatSubscriber subscribes to chat-related patterns and calls onMessage
// for each incoming message. Subscribes to: chat:conv:*, typing:conv:*, presence:conv:*
func (n *Notifier) StartChatSubscriber(
        ctx context.Context, onMessage func(channel string, payload string),
) error <span class="cov0" title="0">{
        if n.rdb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">sub := n.rdb.PSubscribe(ctx, "chat:conv:*", "typing:conv:*", "presence:conv:*")
        ch := sub.Channel()

        go func() </span><span class="cov0" title="0">{
                for msg := range ch </span><span class="cov0" title="0">{
                        onMessage(msg.Channel, msg.Payload)
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

// PublishGameAction publishes a game action (move, join, etc) to a room channel
func (n *Notifier) PublishGameAction(
        ctx context.Context, roomID uint, payload string,
) error <span class="cov0" title="0">{
        if n.rdb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">channel := fmt.Sprintf("game:room:%d", roomID)
        return n.rdb.Publish(ctx, channel, payload).Err()</span>
}

// StartGameSubscriber subscribes to game room patterns
func (n *Notifier) StartGameSubscriber(
        ctx context.Context, onMessage func(channel string, payload string),
) error <span class="cov0" title="0">{
        if n.rdb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">sub := n.rdb.PSubscribe(ctx, "game:room:*")
        ch := sub.Channel()

        go func() </span><span class="cov0" title="0">{
                for msg := range ch </span><span class="cov0" title="0">{
                        onMessage(msg.Channel, msg.Payload)
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

// PublishVideoChatSignal publishes a WebRTC signaling message to a video chat room channel
func (n *Notifier) PublishVideoChatSignal(
        ctx context.Context, roomID string, payload string,
) error <span class="cov0" title="0">{
        if n.rdb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">channel := fmt.Sprintf("videochat:room:%s", roomID)
        return n.rdb.Publish(ctx, channel, payload).Err()</span>
}

// StartVideoChatSubscriber subscribes to video chat room patterns
func (n *Notifier) StartVideoChatSubscriber(
        ctx context.Context, onMessage func(channel string, payload string),
) error <span class="cov0" title="0">{
        if n.rdb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">sub := n.rdb.PSubscribe(ctx, "videochat:room:*")
        ch := sub.Channel()

        go func() </span><span class="cov0" title="0">{
                for msg := range ch </span><span class="cov0" title="0">{
                        onMessage(msg.Channel, msg.Payload)
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

// UserChannel derives the Redis channel name for a user.
func UserChannel(userID uint) string <span class="cov10" title="2">{
        return "notifications:user:" + strconv.FormatUint(uint64(userID), 10)
}</span>

// ConversationChannel derives the Redis channel name for a conversation.
func ConversationChannel(conversationID uint) string <span class="cov1" title="1">{
        return "chat:conv:" + strconv.FormatUint(uint64(conversationID), 10)
}</span>

// GameRoomChannel derives the Redis channel name for a game room.
func GameRoomChannel(roomID uint) string <span class="cov0" title="0">{
        return "game:room:" + strconv.FormatUint(uint64(roomID), 10)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package notifications

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "sync"

        "github.com/gofiber/websocket/v2"
)

const (
        // MaxPeersPerRoom prevents unbounded room growth
        MaxPeersPerRoom = 10
        // MaxTotalRooms prevents unbounded map growth
        MaxTotalRooms = 1000
)

// VideoChatSignal represents a WebRTC signaling message relayed through the hub
type VideoChatSignal struct {
        Type     string      `json:"type"`                // "join", "leave", "offer", "answer", "ice-candidate", "room_users", "user_joined", "user_left", "error"
        RoomID   string      `json:"room_id,omitempty"`   // Room identifier (string-based for flexibility)
        UserID   uint        `json:"user_id,omitempty"`   // Sender
        TargetID uint        `json:"target_id,omitempty"` // Intended recipient (for offer/answer/ice)
        Username string      `json:"username,omitempty"`
        Payload  interface{} `json:"payload,omitempty"` // SDP or ICE candidate data
}

// VideoChatHub manages WebRTC signaling for peer-to-peer video chat rooms.
// It does NOT touch media ‚Äî it only relays SDP offers/answers and ICE candidates.
type VideoChatHub struct {
        mu sync.RWMutex

        // rooms maps roomID -&gt; userID -&gt; client
        rooms map[string]map[uint]*Client
}

// Name returns a human-readable identifier for this hub.
func (h *VideoChatHub) Name() string <span class="cov0" title="0">{ return "video chat hub" }</span>

// NewVideoChatHub creates a new VideoChatHub
func NewVideoChatHub() *VideoChatHub <span class="cov2" title="2">{
        return &amp;VideoChatHub{
                rooms: make(map[string]map[uint]*Client),
        }
}</span>

// Join is a legacy wrapper for Register.
func (h *VideoChatHub) Join(roomID string, userID uint, username string, conn *websocket.Conn) <span class="cov6" title="12">{
        if _, err := h.Register(roomID, userID, conn); err != nil </span><span class="cov1" title="1">{
                log.Printf("VideoChatHub: Failed to join room %s for user %d: %v", roomID, userID, err)
                return
        }</span>
        <span class="cov6" title="11">h.BroadcastJoin(roomID, userID, username)</span>
}

// BroadcastJoin notifies existing peers of a new joiner and sends existing peer list to the joiner.
func (h *VideoChatHub) BroadcastJoin(roomID string, userID uint, username string) <span class="cov6" title="11">{
        h.mu.RLock()
        room, ok := h.rooms[roomID]
        if !ok </span><span class="cov0" title="0">{
                h.mu.RUnlock()
                return
        }</span>

        // Prepare list of existing users for the new joiner
        <span class="cov6" title="11">existingUsers := make([]map[string]any, 0, len(room))
        for uid := range room </span><span class="cov10" title="56">{
                if uid == userID </span><span class="cov6" title="11">{
                        continue</span>
                }
                // We don't store username in Client currently, so this might be limited
                // but we can at least send userIDs.
                <span class="cov9" title="45">existingUsers = append(existingUsers, map[string]any{
                        "userId": uid,
                        // username is not stored in hub/client, so we'll have to rely on IDs or update storage
                })</span>
        }
        <span class="cov6" title="11">newJoiner := room[userID]
        h.mu.RUnlock()

        // 1. Tell new joiner who is already there
        if newJoiner != nil </span><span class="cov6" title="11">{
                roomUsersMsg := VideoChatSignal{
                        Type:   "room_users",
                        RoomID: roomID,
                        Payload: map[string]any{
                                "users": existingUsers,
                        },
                }
                if msgJSON, err := json.Marshal(roomUsersMsg); err == nil </span><span class="cov6" title="11">{
                        newJoiner.TrySend(msgJSON)
                }</span>
        }

        // 2. Tell others that someone new joined
        <span class="cov6" title="11">joinMsg := VideoChatSignal{
                Type:     "user_joined",
                RoomID:   roomID,
                UserID:   userID,
                Username: username,
        }
        h.broadcastToRoom(roomID, userID, joinMsg)</span>
}

// Register adds a user to a video chat room. Returns Client or error if limits exceeded.
func (h *VideoChatHub) Register(roomID string, userID uint, conn *websocket.Conn) (*Client, error) <span class="cov6" title="12">{
        h.mu.Lock()
        defer h.mu.Unlock()

        // Enforce room count limit
        if h.rooms[roomID] == nil &amp;&amp; len(h.rooms) &gt;= MaxTotalRooms </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("too many active rooms")
        }</span>

        <span class="cov6" title="12">if h.rooms[roomID] == nil </span><span class="cov2" title="2">{
                h.rooms[roomID] = make(map[uint]*Client)
        }</span>

        // Enforce per-room peer limit
        <span class="cov6" title="12">if len(h.rooms[roomID]) &gt;= MaxPeersPerRoom </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("room is full")
        }</span>

        <span class="cov6" title="11">client := NewClient(h, conn, userID)
        h.rooms[roomID][userID] = client

        return client, nil</span>
}

// UnregisterClient removes a user from a video chat room
func (h *VideoChatHub) UnregisterClient(client *Client) <span class="cov0" title="0">{
        h.mu.Lock()

        var targetRoomID string
        found := false
        for roomID, peers := range h.rooms </span><span class="cov0" title="0">{
                if c, ok := peers[client.UserID]; ok </span><span class="cov0" title="0">{
                        // Only remove if the registered client matches this client instance.
                        if c != client </span><span class="cov0" title="0">{
                                // Another active client is registered for this user in the room; skip.
                                continue</span>
                        }
                        <span class="cov0" title="0">targetRoomID = roomID
                        delete(peers, client.UserID)
                        if len(peers) == 0 </span><span class="cov0" title="0">{
                                delete(h.rooms, roomID)
                        }</span>
                        <span class="cov0" title="0">found = true
                        break</span>
                }
        }
        <span class="cov0" title="0">h.mu.Unlock()

        if found </span><span class="cov0" title="0">{
                log.Printf("VideoChatHub: User %d left room %s", client.UserID, targetRoomID)
                // Notify remaining peers
                leaveMsg := VideoChatSignal{
                        Type:   "user_left",
                        RoomID: targetRoomID,
                        UserID: client.UserID,
                }
                h.broadcastToRoom(targetRoomID, client.UserID, leaveMsg)
        }</span>
}

// Leave removes a user from a video chat room and notifies remaining peers
func (h *VideoChatHub) Leave(roomID string, userID uint) <span class="cov1" title="1">{
        h.mu.Lock()

        room, ok := h.rooms[roomID]
        if !ok </span><span class="cov0" title="0">{
                h.mu.Unlock()
                return
        }</span>

        <span class="cov1" title="1">delete(room, userID)
        if len(room) == 0 </span><span class="cov1" title="1">{
                delete(h.rooms, roomID)
        }</span>

        <span class="cov1" title="1">h.mu.Unlock()

        log.Printf("VideoChatHub: User %d left room %s", userID, roomID)

        // Notify remaining peers
        leaveMsg := VideoChatSignal{
                Type:   "user_left",
                RoomID: roomID,
                UserID: userID,
        }
        h.broadcastToRoom(roomID, userID, leaveMsg)</span>
}

// Relay forwards a signaling message (offer/answer/ice-candidate) to a specific target peer
func (h *VideoChatHub) Relay(roomID string, fromUserID, targetID uint, signal VideoChatSignal) <span class="cov0" title="0">{
        h.mu.RLock()
        room, ok := h.rooms[roomID]
        if !ok </span><span class="cov0" title="0">{
                h.mu.RUnlock()
                return
        }</span>
        <span class="cov0" title="0">target, ok := room[targetID]
        h.mu.RUnlock()

        if !ok </span><span class="cov0" title="0">{
                log.Printf("VideoChatHub: Target user %d not found in room %s", targetID, roomID)
                return
        }</span>

        <span class="cov0" title="0">signal.UserID = fromUserID
        msgJSON, err := json.Marshal(signal)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">target.TrySend(msgJSON)</span>
}

// broadcastToRoom sends a message to all peers in a room except the sender
func (h *VideoChatHub) broadcastToRoom(roomID string, excludeUserID uint, signal VideoChatSignal) <span class="cov6" title="12">{
        h.mu.RLock()
        room, ok := h.rooms[roomID]
        if !ok </span><span class="cov1" title="1">{
                h.mu.RUnlock()
                return
        }</span>

        <span class="cov6" title="11">targets := make([]*Client, 0, len(room))
        for uid, peer := range room </span><span class="cov10" title="56">{
                if uid == excludeUserID </span><span class="cov6" title="11">{
                        continue</span>
                }
                <span class="cov9" title="45">targets = append(targets, peer)</span>
        }
        <span class="cov6" title="11">h.mu.RUnlock()

        msgJSON, err := json.Marshal(signal)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="11">for _, peer := range targets </span><span class="cov9" title="45">{
                peer.TrySend(msgJSON)
        }</span>
}

// StartWiring connects VideoChatHub to Redis pub/sub
func (h *VideoChatHub) StartWiring(ctx context.Context, n *Notifier) error <span class="cov0" title="0">{
        return n.StartVideoChatSubscriber(ctx, func(channel, payload string) </span><span class="cov0" title="0">{
                var roomID string
                if _, err := fmt.Sscanf(channel, "videochat:room:%s", &amp;roomID); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">var signal VideoChatSignal
                if err := json.Unmarshal([]byte(payload), &amp;signal); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">signal.RoomID = roomID

                if signal.TargetID != 0 </span><span class="cov0" title="0">{
                        h.Relay(roomID, signal.UserID, signal.TargetID, signal)
                }</span> else<span class="cov0" title="0"> {
                        h.broadcastToRoom(roomID, signal.UserID, signal)
                }</span>
        })
}

// Shutdown gracefully closes all video chat connections
func (h *VideoChatHub) Shutdown(_ context.Context) error <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        for roomID, users := range h.rooms </span><span class="cov0" title="0">{
                for _, peer := range users </span><span class="cov0" title="0">{
                        shutdownMsg := VideoChatSignal{
                                Type:   "server_shutdown",
                                RoomID: roomID,
                        }
                        if msgJSON, err := json.Marshal(shutdownMsg); err == nil </span><span class="cov0" title="0">{
                                peer.TrySend(msgJSON)
                        }</span>
                        <span class="cov0" title="0">_ = peer.Conn.Close()</span>
                }
        }

        <span class="cov0" title="0">h.rooms = make(map[string]map[uint]*Client)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repository

import (
        "context"

        "sanctum/internal/models"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

// ChatRepository defines the interface for chat data operations
type ChatRepository interface {
        CreateConversation(ctx context.Context, conv *models.Conversation) error
        GetConversation(ctx context.Context, id uint) (*models.Conversation, error)
        GetUserConversations(ctx context.Context, userID uint) ([]*models.Conversation, error)
        AddParticipant(ctx context.Context, convID, userID uint) error
        RemoveParticipant(ctx context.Context, convID, userID uint) error
        CreateMessage(ctx context.Context, msg *models.Message) error
        GetMessages(ctx context.Context, convID uint, limit, offset int) ([]*models.Message, error)
        MarkMessageRead(ctx context.Context, msgID uint) error
        UpdateLastRead(ctx context.Context, convID, userID uint) error
}

// chatRepository implements ChatRepository
type chatRepository struct {
        db *gorm.DB
}

// NewChatRepository creates a new chat repository
func NewChatRepository(db *gorm.DB) ChatRepository <span class="cov1" title="1">{
        return &amp;chatRepository{db: db}
}</span>

func (r *chatRepository) CreateConversation(ctx context.Context, conv *models.Conversation) error <span class="cov1" title="1">{
        return r.db.WithContext(ctx).Create(conv).Error
}</span>

func (r *chatRepository) GetConversation(ctx context.Context, id uint) (*models.Conversation, error) <span class="cov1" title="1">{
        var conv models.Conversation
        err := r.db.WithContext(ctx).
                Preload("Participants").
                Preload("Messages", func(db *gorm.DB) *gorm.DB </span><span class="cov1" title="1">{
                        return db.Order("created_at ASC").Limit(50)
                }</span>).
                Preload("Messages.Sender").
                First(&amp;conv, id).Error
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;conv, nil</span>
}

func (r *chatRepository) GetUserConversations(ctx context.Context, userID uint) ([]*models.Conversation, error) <span class="cov0" title="0">{
        var conversations []*models.Conversation
        err := r.db.WithContext(ctx).
                Joins("JOIN conversation_participants cp ON conversations.id = cp.conversation_id").
                Where("cp.user_id = ?", userID).
                Select("conversations.*, COALESCE(cp.unread_count, 0) as unread_count").
                Preload("Participants").
                Preload("Messages", func(db *gorm.DB) *gorm.DB </span><span class="cov0" title="0">{
                        return db.Order("created_at DESC").Limit(1)
                }</span>).
                Preload("Messages.Sender").
                Order("conversations.updated_at DESC").
                Find(&amp;conversations).Error
        <span class="cov0" title="0">return conversations, err</span>
}

func (r *chatRepository) AddParticipant(ctx context.Context, convID, userID uint) error <span class="cov10" title="3">{
        participant := models.ConversationParticipant{
                ConversationID: convID,
                UserID:         userID,
        }
        // Use OnConflict to silently ignore duplicate key errors
        return r.db.WithContext(ctx).Clauses(clause.OnConflict{DoNothing: true}).Create(&amp;participant).Error
}</span>

func (r *chatRepository) RemoveParticipant(ctx context.Context, convID, userID uint) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Where("conversation_id = ? AND user_id = ?", convID, userID).Delete(&amp;models.ConversationParticipant{}).Error
}</span>

func (r *chatRepository) CreateMessage(ctx context.Context, msg *models.Message) error <span class="cov1" title="1">{
        return r.db.WithContext(ctx).Create(msg).Error
}</span>

func (r *chatRepository) GetMessages(ctx context.Context, convID uint, limit, offset int) ([]*models.Message, error) <span class="cov1" title="1">{
        var messages []*models.Message
        err := r.db.WithContext(ctx).
                Where("conversation_id = ?", convID).
                Preload("Sender").
                Order("created_at DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;messages).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Reverse messages to return them in chronological order (oldest -&gt; newest)
        // We fetched DESC to get the *latest* messages, but client expects ASC
        <span class="cov1" title="1">for i, j := 0, len(messages)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                messages[i], messages[j] = messages[j], messages[i]
        }</span>

        <span class="cov1" title="1">return messages, nil</span>
}

func (r *chatRepository) MarkMessageRead(ctx context.Context, msgID uint) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Model(&amp;models.Message{}).Where("id = ?", msgID).Update("is_read", true).Error
}</span>

func (r *chatRepository) UpdateLastRead(ctx context.Context, convID, userID uint) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Model(&amp;models.ConversationParticipant{}).
                Where("conversation_id = ? AND user_id = ?", convID, userID).
                Update("last_read_at", "NOW()").Error
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package repository provides data access layer implementations for the application.
package repository

import (
        "context"

        "sanctum/internal/models"

        "gorm.io/gorm"
)

// CommentRepository defines interface for comment operations
type CommentRepository interface {
        Create(ctx context.Context, comment *models.Comment) error
        GetByID(ctx context.Context, id uint) (*models.Comment, error)
        ListByPost(ctx context.Context, postID uint) ([]*models.Comment, error)
        Update(ctx context.Context, comment *models.Comment) error
        Delete(ctx context.Context, id uint) error
}

type commentRepository struct {
        db *gorm.DB
}

// NewCommentRepository creates a new CommentRepository
func NewCommentRepository(db *gorm.DB) CommentRepository <span class="cov1" title="1">{
        return &amp;commentRepository{db: db}
}</span>

func (r *commentRepository) Create(ctx context.Context, comment *models.Comment) error <span class="cov10" title="2">{
        return r.db.WithContext(ctx).Create(comment).Error
}</span>

func (r *commentRepository) GetByID(ctx context.Context, id uint) (*models.Comment, error) <span class="cov10" title="2">{
        var comment models.Comment
        if err := r.db.WithContext(ctx).Preload("User").First(&amp;comment, id).Error; err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;comment, nil</span>
}

func (r *commentRepository) ListByPost(
        ctx context.Context,
        postID uint,
) ([]*models.Comment, error) <span class="cov1" title="1">{
        var comments []*models.Comment
        err := r.db.WithContext(ctx).Preload("User").Where("post_id = ?", postID).Order("created_at desc").Find(&amp;comments).Error
        return comments, err
}</span>

func (r *commentRepository) Update(ctx context.Context, comment *models.Comment) error <span class="cov1" title="1">{
        return r.db.WithContext(ctx).Save(comment).Error
}</span>

func (r *commentRepository) Delete(ctx context.Context, id uint) error <span class="cov1" title="1">{
        return r.db.WithContext(ctx).Delete(&amp;models.Comment{}, id).Error
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package repository provides data access layer implementations for the application.
package repository

import (
        "context"
        "errors"

        "sanctum/internal/models"

        "gorm.io/gorm"
)

// FriendRepository defines the interface for friend data operations
type FriendRepository interface {
        Create(ctx context.Context, friendship *models.Friendship) error
        GetByID(ctx context.Context, id uint) (*models.Friendship, error)
        GetFriendshipBetweenUsers(ctx context.Context, userID1, userID2 uint) (*models.Friendship, error)
        GetFriends(ctx context.Context, userID uint) ([]models.User, error)
        GetPendingRequests(ctx context.Context, userID uint) ([]models.Friendship, error)
        GetSentRequests(ctx context.Context, userID uint) ([]models.Friendship, error)
        UpdateStatus(ctx context.Context, friendshipID uint, status models.FriendshipStatus) error
        Delete(ctx context.Context, friendshipID uint) error
        RemoveFriendship(ctx context.Context, userID1, userID2 uint) error
}

// friendRepository implements FriendRepository
type friendRepository struct {
        db *gorm.DB
}

// NewFriendRepository creates a new friend repository
func NewFriendRepository(db *gorm.DB) FriendRepository <span class="cov1" title="1">{
        return &amp;friendRepository{db: db}
}</span>

func (r *friendRepository) Create(ctx context.Context, friendship *models.Friendship) error <span class="cov1" title="1">{
        if err := r.db.WithContext(ctx).Create(friendship).Error; err != nil </span><span class="cov0" title="0">{
                return models.NewInternalError(err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (r *friendRepository) GetByID(ctx context.Context, id uint) (*models.Friendship, error) <span class="cov0" title="0">{
        var friendship models.Friendship
        if err := r.db.WithContext(ctx).Preload("Requester").Preload("Addressee").First(&amp;friendship, id).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, models.NewNotFoundError("Friendship", id)
                }</span>
                <span class="cov0" title="0">return nil, models.NewInternalError(err)</span>
        }
        <span class="cov0" title="0">return &amp;friendship, nil</span>
}

func (r *friendRepository) GetFriendshipBetweenUsers(ctx context.Context, userID1, userID2 uint) (*models.Friendship, error) <span class="cov10" title="2">{
        var friendship models.Friendship

        // Find friendship where users are either requester/addressee in any order
        if err := r.db.WithContext(ctx).
                Where("(requester_id = ? AND addressee_id = ?) OR (requester_id = ? AND addressee_id = ?)",
                        userID1, userID2, userID2, userID1).
                Preload("Requester").
                Preload("Addressee").
                First(&amp;friendship).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil // No friendship exists
                }</span>
                <span class="cov0" title="0">return nil, models.NewInternalError(err)</span>
        }
        <span class="cov10" title="2">return &amp;friendship, nil</span>
}

func (r *friendRepository) GetFriends(ctx context.Context, userID uint) ([]models.User, error) <span class="cov10" title="2">{
        var users []models.User

        // Find all accepted friendships for the user and get the other user in each friendship
        if err := r.db.WithContext(ctx).
                Table("users").
                Joins("JOIN friendships f ON (users.id = f.requester_id OR users.id = f.addressee_id)").
                Where("f.status = ? AND (f.requester_id = ? OR f.addressee_id = ?) AND users.id != ?",
                        models.FriendshipStatusAccepted, userID, userID, userID).
                Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                return nil, models.NewInternalError(err)
        }</span>

        <span class="cov10" title="2">return users, nil</span>
}

func (r *friendRepository) GetPendingRequests(ctx context.Context, userID uint) ([]models.Friendship, error) <span class="cov1" title="1">{
        var friendships []models.Friendship

        // Find pending requests where user is the addressee
        if err := r.db.WithContext(ctx).
                Where("addressee_id = ? AND status = ?", userID, models.FriendshipStatusPending).
                Preload("Requester").
                Preload("Addressee").
                Find(&amp;friendships).Error; err != nil </span><span class="cov0" title="0">{
                return nil, models.NewInternalError(err)
        }</span>

        <span class="cov1" title="1">return friendships, nil</span>
}

func (r *friendRepository) GetSentRequests(ctx context.Context, userID uint) ([]models.Friendship, error) <span class="cov0" title="0">{
        var friendships []models.Friendship

        // Find pending requests where user is the requester
        if err := r.db.WithContext(ctx).
                Where("requester_id = ? AND status = ?", userID, models.FriendshipStatusPending).
                Preload("Requester").
                Preload("Addressee").
                Find(&amp;friendships).Error; err != nil </span><span class="cov0" title="0">{
                return nil, models.NewInternalError(err)
        }</span>

        <span class="cov0" title="0">return friendships, nil</span>
}

func (r *friendRepository) UpdateStatus(ctx context.Context, friendshipID uint, status models.FriendshipStatus) error <span class="cov1" title="1">{
        if err := r.db.WithContext(ctx).
                Model(&amp;models.Friendship{}).
                Where("id = ?", friendshipID).
                Update("status", status).Error; err != nil </span><span class="cov0" title="0">{
                return models.NewInternalError(err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (r *friendRepository) Delete(ctx context.Context, friendshipID uint) error <span class="cov1" title="1">{
        if err := r.db.WithContext(ctx).Delete(&amp;models.Friendship{}, friendshipID).Error; err != nil </span><span class="cov0" title="0">{
                return models.NewInternalError(err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (r *friendRepository) RemoveFriendship(ctx context.Context, userID1, userID2 uint) error <span class="cov0" title="0">{
        if err := r.db.WithContext(ctx).
                Where("(requester_id = ? AND addressee_id = ?) OR (requester_id = ? AND addressee_id = ?)",
                        userID1, userID2, userID2, userID1).
                Delete(&amp;models.Friendship{}).Error; err != nil </span><span class="cov0" title="0">{
                return models.NewInternalError(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package repository

import (
        "errors"

        "sanctum/internal/models"

        "gorm.io/gorm"
)

// GameRepository defines operations for managing game rooms and statistics.
type GameRepository interface {
        CreateRoom(room *models.GameRoom) error
        GetRoom(id uint) (*models.GameRoom, error)
        UpdateRoom(room *models.GameRoom) error
        GetAllActiveRooms() ([]models.GameRoom, error)
        GetActiveRooms(gameType models.GameType) ([]models.GameRoom, error)
        GetPendingRoomByCreator(gameType models.GameType, creatorID uint) (*models.GameRoom, error)
        CreateMove(move *models.GameMove) error
        GetMoves(roomID uint) ([]models.GameMove, error)
        GetStats(userID uint, gameType models.GameType) (*models.GameStats, error)
        UpdateStats(stats *models.GameStats) error
}

type gameRepository struct {
        db *gorm.DB
}

// NewGameRepository creates and returns a new GameRepository instance.
func NewGameRepository(db *gorm.DB) GameRepository <span class="cov0" title="0">{
        return &amp;gameRepository{db: db}
}</span>

func (r *gameRepository) CreateRoom(room *models.GameRoom) error <span class="cov0" title="0">{
        return r.db.Create(room).Error
}</span>

func (r *gameRepository) GetRoom(id uint) (*models.GameRoom, error) <span class="cov0" title="0">{
        var room models.GameRoom
        err := r.db.Preload("Creator").Preload("Opponent").First(&amp;room, id).Error
        return &amp;room, err
}</span>

func (r *gameRepository) UpdateRoom(room *models.GameRoom) error <span class="cov0" title="0">{
        return r.db.Save(room).Error
}</span>

func (r *gameRepository) GetAllActiveRooms() ([]models.GameRoom, error) <span class="cov0" title="0">{
        var rooms []models.GameRoom
        err := r.db.Where("status = ?", models.GamePending).
                Preload("Creator").Find(&amp;rooms).Error
        return rooms, err
}</span>

func (r *gameRepository) GetActiveRooms(gameType models.GameType) ([]models.GameRoom, error) <span class="cov0" title="0">{
        var rooms []models.GameRoom
        err := r.db.Where("type = ? AND status = ?", gameType, models.GamePending).
                Preload("Creator").Find(&amp;rooms).Error
        return rooms, err
}</span>

func (r *gameRepository) GetPendingRoomByCreator(gameType models.GameType, creatorID uint) (*models.GameRoom, error) <span class="cov0" title="0">{
        var room models.GameRoom
        err := r.db.Where("type = ? AND creator_id = ? AND status = ?", gameType, creatorID, models.GamePending).
                Preload("Creator").First(&amp;room).Error
        return &amp;room, err
}</span>

func (r *gameRepository) CreateMove(move *models.GameMove) error <span class="cov0" title="0">{
        return r.db.Create(move).Error
}</span>

func (r *gameRepository) GetMoves(roomID uint) ([]models.GameMove, error) <span class="cov0" title="0">{
        var moves []models.GameMove
        err := r.db.Where("game_room_id = ?", roomID).Order("move_number asc").Find(&amp;moves).Error
        return moves, err
}</span>

func (r *gameRepository) GetStats(userID uint, gameType models.GameType) (*models.GameStats, error) <span class="cov0" title="0">{
        var stats models.GameStats
        err := r.db.Where("user_id = ? AND game_type = ?", userID, gameType).First(&amp;stats).Error
        if err != nil &amp;&amp; errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                stats = models.GameStats{UserID: userID, GameType: gameType}
                err = r.db.Create(&amp;stats).Error
        }</span>
        <span class="cov0" title="0">return &amp;stats, err</span>
}

func (r *gameRepository) UpdateStats(stats *models.GameStats) error <span class="cov0" title="0">{
        return r.db.Save(stats).Error
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package repository provides data access layer implementations for the application.
package repository

import (
        "context"

        "sanctum/internal/cache"
        "sanctum/internal/models"

        "gorm.io/gorm"
)

// PostRepository defines the interface for post data operations
type PostRepository interface {
        Create(ctx context.Context, post *models.Post) error
        GetByID(ctx context.Context, id uint, currentUserID uint) (*models.Post, error)
        GetByUserID(ctx context.Context, userID uint, limit, offset int, currentUserID uint) ([]*models.Post, error)
        GetBySanctumID(ctx context.Context, sanctumID uint, limit, offset int, currentUserID uint) ([]*models.Post, error)
        List(ctx context.Context, limit, offset int, currentUserID uint) ([]*models.Post, error)
        Search(ctx context.Context, query string, limit, offset int, currentUserID uint) ([]*models.Post, error)
        Update(ctx context.Context, post *models.Post) error
        Delete(ctx context.Context, id uint) error
        IsLiked(ctx context.Context, userID, postID uint) (bool, error)
        Like(ctx context.Context, userID, postID uint) error
        Unlike(ctx context.Context, userID, postID uint) error
}

// postRepository implements PostRepository
type postRepository struct {
        db *gorm.DB
}

// NewPostRepository creates a new post repository
func NewPostRepository(db *gorm.DB) PostRepository <span class="cov3" title="2">{
        return &amp;postRepository{db: db}
}</span>

func (r *postRepository) Create(ctx context.Context, post *models.Post) error <span class="cov8" title="7">{
        return r.db.WithContext(ctx).Create(post).Error
}</span>

func (r *postRepository) GetByID(ctx context.Context, id uint, currentUserID uint) (*models.Post, error) <span class="cov3" title="2">{
        var post models.Post
        key := cache.PostKey(id)

        err := cache.Aside(ctx, key, &amp;post, cache.PostTTL, func() error </span><span class="cov3" title="2">{
                return r.db.WithContext(ctx).Preload("User").First(&amp;post, id).Error
        }</span>)

        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // populate comments and likes count
        <span class="cov3" title="2">r.populatePostDetails(ctx, &amp;post, currentUserID)
        return &amp;post, nil</span>
}

func (r *postRepository) GetByUserID(ctx context.Context, userID uint, limit, offset int, currentUserID uint) ([]*models.Post, error) <span class="cov0" title="0">{
        var posts []*models.Post
        err := r.db.WithContext(ctx).
                Preload("User").
                Where("user_id = ?", userID).
                Order("created_at DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;posts).Error
        if err != nil </span><span class="cov0" title="0">{
                return posts, err
        }</span>
        <span class="cov0" title="0">for _, p := range posts </span><span class="cov0" title="0">{
                r.populatePostDetails(ctx, p, currentUserID)
        }</span>
        <span class="cov0" title="0">return posts, err</span>
}

func (r *postRepository) GetBySanctumID(ctx context.Context, sanctumID uint, limit, offset int, currentUserID uint) ([]*models.Post, error) <span class="cov0" title="0">{
        var posts []*models.Post
        err := r.db.WithContext(ctx).
                Preload("User").
                Where("sanctum_id = ?", sanctumID).
                Order("created_at DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;posts).Error
        if err != nil </span><span class="cov0" title="0">{
                return posts, err
        }</span>
        <span class="cov0" title="0">for _, p := range posts </span><span class="cov0" title="0">{
                r.populatePostDetails(ctx, p, currentUserID)
        }</span>
        <span class="cov0" title="0">return posts, err</span>
}

func (r *postRepository) List(ctx context.Context, limit, offset int, currentUserID uint) ([]*models.Post, error) <span class="cov1" title="1">{
        var posts []*models.Post
        err := r.db.WithContext(ctx).
                Preload("User").
                Order("created_at DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;posts).Error
        if err != nil </span><span class="cov0" title="0">{
                return posts, err
        }</span>
        <span class="cov1" title="1">for _, p := range posts </span><span class="cov7" title="5">{
                r.populatePostDetails(ctx, p, currentUserID)
        }</span>
        <span class="cov1" title="1">return posts, err</span>
}

func (r *postRepository) Search(ctx context.Context, query string, limit, offset int, currentUserID uint) ([]*models.Post, error) <span class="cov1" title="1">{
        var posts []*models.Post
        like := "%" + query + "%"
        err := r.db.WithContext(ctx).
                Preload("User").
                Where("title ILIKE ? OR content ILIKE ?", like, like).
                Order("created_at DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;posts).Error
        if err != nil </span><span class="cov0" title="0">{
                return posts, err
        }</span>
        <span class="cov1" title="1">for _, p := range posts </span><span class="cov3" title="2">{
                r.populatePostDetails(ctx, p, currentUserID)
        }</span>
        <span class="cov1" title="1">return posts, err</span>
}

// populatePostDetails fetches counts for comments and likes, and checks if the post is liked by the current user.
func (r *postRepository) populatePostDetails(ctx context.Context, p *models.Post, currentUserID uint) <span class="cov10" title="9">{
        // 1. Get comments count
        var commentsCount int64
        r.db.WithContext(ctx).Model(&amp;models.Comment{}).Where("post_id = ?", p.ID).Count(&amp;commentsCount)
        p.CommentsCount = int(commentsCount)

        // 2. Get likes count
        var likesCount int64
        r.db.WithContext(ctx).Model(&amp;models.Like{}).Where("post_id = ?", p.ID).Count(&amp;likesCount)
        p.LikesCount = int(likesCount)

        // 3. Check if the current user liked the post
        if currentUserID != 0 </span><span class="cov10" title="9">{
                var like models.Like
                err := r.db.WithContext(ctx).Where("post_id = ? AND user_id = ?", p.ID, currentUserID).First(&amp;like).Error
                p.Liked = err == nil
        }</span> else<span class="cov0" title="0"> {
                p.Liked = false
        }</span>
}

func (r *postRepository) Update(ctx context.Context, post *models.Post) error <span class="cov0" title="0">{
        if err := r.db.WithContext(ctx).Save(post).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cache.Invalidate(ctx, cache.PostKey(post.ID))
        return nil</span>
}

func (r *postRepository) Delete(ctx context.Context, id uint) error <span class="cov0" title="0">{
        if err := r.db.WithContext(ctx).Delete(&amp;models.Post{}, id).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cache.Invalidate(ctx, cache.PostKey(id))
        return nil</span>
}

func (r *postRepository) IsLiked(ctx context.Context, userID, postID uint) (bool, error) <span class="cov3" title="2">{
        var count int64
        if err := r.db.WithContext(ctx).
                Model(&amp;models.Like{}).
                Where("user_id = ? AND post_id = ?", userID, postID).
                Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov3" title="2">return count &gt; 0, nil</span>
}

func (r *postRepository) Like(ctx context.Context, userID, postID uint) error <span class="cov1" title="1">{
        // Use INSERT ... ON CONFLICT DO NOTHING to handle race conditions
        // This is atomic and prevents duplicate key errors
        result := r.db.WithContext(ctx).Exec(
                `INSERT INTO likes (user_id, post_id, created_at) 
                 VALUES (?, ?, NOW()) 
                 ON CONFLICT (user_id, post_id) DO NOTHING`,
                userID, postID,
        )
        if result.Error == nil </span><span class="cov1" title="1">{
                cache.Invalidate(ctx, cache.PostKey(postID))
        }</span>
        <span class="cov1" title="1">return result.Error</span>
}

func (r *postRepository) Unlike(ctx context.Context, userID, postID uint) error <span class="cov1" title="1">{
        // Hard delete the like record (not soft delete)
        err := r.db.WithContext(ctx).Unscoped().Where("user_id = ? AND post_id = ?", userID, postID).Delete(&amp;models.Like{}).Error
        if err == nil </span><span class="cov1" title="1">{
                cache.Invalidate(ctx, cache.PostKey(postID))
        }</span>
        <span class="cov1" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package repository

import (
        "context"

        "sanctum/internal/models"

        "gorm.io/gorm"
)

// StreamRepository defines the interface for stream data operations
type StreamRepository interface {
        CreateStream(ctx context.Context, stream *models.Stream) error
        GetStreamByID(ctx context.Context, id uint) (*models.Stream, error)
        GetStreamsByUserID(ctx context.Context, userID uint) ([]*models.Stream, error)
        GetLiveStreams(ctx context.Context, category string, limit, offset int) ([]*models.Stream, int64, error)
        UpdateStream(ctx context.Context, stream *models.Stream) error
        DeleteStream(ctx context.Context, id uint) error
        SetStreamLive(ctx context.Context, id uint, isLive bool) error
        IncrementViewerCount(ctx context.Context, id uint) error
        DecrementViewerCount(ctx context.Context, id uint) error
        // Stream messages
        CreateStreamMessage(ctx context.Context, msg *models.StreamMessage) error
        GetStreamMessages(ctx context.Context, streamID uint, limit, offset int) ([]*models.StreamMessage, error)
}

// streamRepository implements StreamRepository
type streamRepository struct {
        db *gorm.DB
}

// NewStreamRepository creates a new stream repository
func NewStreamRepository(db *gorm.DB) StreamRepository <span class="cov0" title="0">{
        return &amp;streamRepository{db: db}
}</span>

func (r *streamRepository) CreateStream(ctx context.Context, stream *models.Stream) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(stream).Error
}</span>

func (r *streamRepository) GetStreamByID(ctx context.Context, id uint) (*models.Stream, error) <span class="cov0" title="0">{
        var stream models.Stream
        err := r.db.WithContext(ctx).
                Preload("User").
                First(&amp;stream, id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;stream, nil</span>
}

func (r *streamRepository) GetStreamsByUserID(ctx context.Context, userID uint) ([]*models.Stream, error) <span class="cov0" title="0">{
        var streams []*models.Stream
        err := r.db.WithContext(ctx).
                Where("user_id = ?", userID).
                Preload("User").
                Order("created_at DESC").
                Find(&amp;streams).Error
        return streams, err
}</span>

func (r *streamRepository) GetLiveStreams(ctx context.Context, category string, limit, offset int) ([]*models.Stream, int64, error) <span class="cov0" title="0">{
        var streams []*models.Stream
        var total int64

        query := r.db.WithContext(ctx).Model(&amp;models.Stream{}).Where("is_live = ?", true)

        if category != "" </span><span class="cov0" title="0">{
                query = query.Where("category = ?", category)
        }</span>

        // Get total count
        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">err := query.
                Preload("User").
                Order("viewer_count DESC, started_at DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;streams).Error

        return streams, total, err</span>
}

func (r *streamRepository) UpdateStream(ctx context.Context, stream *models.Stream) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(stream).Error
}</span>

func (r *streamRepository) DeleteStream(ctx context.Context, id uint) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;models.Stream{}, id).Error
}</span>

func (r *streamRepository) SetStreamLive(ctx context.Context, id uint, isLive bool) error <span class="cov0" title="0">{
        updates := map[string]any{"is_live": isLive}
        if isLive </span><span class="cov0" title="0">{
                updates["started_at"] = gorm.Expr("NOW()")
        }</span> else<span class="cov0" title="0"> {
                updates["ended_at"] = gorm.Expr("NOW()")
                updates["viewer_count"] = 0
        }</span>
        <span class="cov0" title="0">return r.db.WithContext(ctx).Model(&amp;models.Stream{}).Where("id = ?", id).Updates(updates).Error</span>
}

func (r *streamRepository) IncrementViewerCount(ctx context.Context, id uint) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Model(&amp;models.Stream{}).Where("id = ?", id).
                UpdateColumn("viewer_count", gorm.Expr("viewer_count + 1")).Error
}</span>

func (r *streamRepository) DecrementViewerCount(ctx context.Context, id uint) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Model(&amp;models.Stream{}).Where("id = ? AND viewer_count &gt; 0", id).
                UpdateColumn("viewer_count", gorm.Expr("viewer_count - 1")).Error
}</span>

func (r *streamRepository) CreateStreamMessage(ctx context.Context, msg *models.StreamMessage) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(msg).Error
}</span>

func (r *streamRepository) GetStreamMessages(ctx context.Context, streamID uint, limit, offset int) ([]*models.StreamMessage, error) <span class="cov0" title="0">{
        var messages []*models.StreamMessage
        err := r.db.WithContext(ctx).
                Where("stream_id = ?", streamID).
                Preload("User").
                Order("created_at DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;messages).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Reverse to return chronological order
        <span class="cov0" title="0">for i, j := 0, len(messages)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                messages[i], messages[j] = messages[j], messages[i]
        }</span>

        <span class="cov0" title="0">return messages, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package repository provides data access layer implementations for the application.
package repository

import (
        "context"
        "errors"

        "sanctum/internal/cache"
        "sanctum/internal/models"

        "gorm.io/gorm"
)

// UserRepository defines the interface for user data operations
type UserRepository interface {
        GetByID(ctx context.Context, id uint) (*models.User, error)
        GetByIDWithPosts(ctx context.Context, id uint, limit int) (*models.User, error)
        GetByEmail(ctx context.Context, email string) (*models.User, error)
        GetByUsername(ctx context.Context, username string) (*models.User, error)
        Create(ctx context.Context, user *models.User) error
        Update(ctx context.Context, user *models.User) error
        Delete(ctx context.Context, id uint) error
        List(ctx context.Context, limit, offset int) ([]models.User, error)
}

// userRepository implements UserRepository
type userRepository struct {
        db *gorm.DB
}

// NewUserRepository creates a new user repository
func NewUserRepository(db *gorm.DB) UserRepository <span class="cov1" title="1">{
        return &amp;userRepository{db: db}
}</span>

func (r *userRepository) GetByID(ctx context.Context, id uint) (*models.User, error) <span class="cov8" title="3">{
        var user models.User
        key := cache.UserKey(id)

        err := cache.Aside(ctx, key, &amp;user, cache.UserTTL, func() error </span><span class="cov8" title="3">{
                if err := r.db.WithContext(ctx).First(&amp;user, id).Error; err != nil </span><span class="cov1" title="1">{
                        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                                return models.NewNotFoundError("User", id)
                        }</span>
                        <span class="cov0" title="0">return models.NewInternalError(err)</span>
                }
                <span class="cov5" title="2">return nil</span>
        })

        <span class="cov8" title="3">if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov5" title="2">return &amp;user, nil</span>
}

// GetByIDWithPosts retrieves a user with a limited number of their posts
// Use this when you need to display user posts to avoid N+1 queries
func (r *userRepository) GetByIDWithPosts(ctx context.Context, id uint, limit int) (*models.User, error) <span class="cov1" title="1">{
        var user models.User
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10 // Default to 10 posts if not specified
        }</span>
        <span class="cov1" title="1">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100 // Maximum 100 posts to prevent abuse
        }</span>

        <span class="cov1" title="1">if err := r.db.WithContext(ctx).
                Preload("Posts", func(db *gorm.DB) *gorm.DB </span><span class="cov1" title="1">{
                        return db.Order("created_at DESC").Limit(limit)
                }</span>).
                First(&amp;user, id).Error; err != nil <span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, models.NewNotFoundError("User", id)
                }</span>
                <span class="cov0" title="0">return nil, models.NewInternalError(err)</span>
        }
        <span class="cov1" title="1">return &amp;user, nil</span>
}

func (r *userRepository) GetByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov1" title="1">{
        var user models.User
        if err := r.db.WithContext(ctx).Where("email = ?", email).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil // Return nil for not found, not an error
                }</span>
                <span class="cov0" title="0">return nil, models.NewInternalError(err)</span>
        }
        <span class="cov1" title="1">return &amp;user, nil</span>
}

func (r *userRepository) GetByUsername(ctx context.Context, username string) (*models.User, error) <span class="cov1" title="1">{
        var user models.User
        if err := r.db.WithContext(ctx).Where("username = ?", username).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, models.NewInternalError(err)</span>
        }
        <span class="cov1" title="1">return &amp;user, nil</span>
}

func (r *userRepository) Create(ctx context.Context, user *models.User) error <span class="cov10" title="4">{
        if err := r.db.WithContext(ctx).Create(user).Error; err != nil </span><span class="cov0" title="0">{
                return models.NewInternalError(err)
        }</span>
        <span class="cov10" title="4">return nil</span>
}

func (r *userRepository) Update(ctx context.Context, user *models.User) error <span class="cov1" title="1">{
        if err := r.db.WithContext(ctx).Save(user).Error; err != nil </span><span class="cov0" title="0">{
                return models.NewInternalError(err)
        }</span>
        <span class="cov1" title="1">cache.Invalidate(ctx, cache.UserKey(user.ID))
        return nil</span>
}

func (r *userRepository) Delete(ctx context.Context, id uint) error <span class="cov1" title="1">{
        if err := r.db.WithContext(ctx).Delete(&amp;models.User{}, id).Error; err != nil </span><span class="cov0" title="0">{
                return models.NewInternalError(err)
        }</span>
        <span class="cov1" title="1">cache.Invalidate(ctx, cache.UserKey(id))
        return nil</span>
}

func (r *userRepository) List(ctx context.Context, limit, offset int) ([]models.User, error) <span class="cov0" title="0">{
        var users []models.User
        if err := r.db.WithContext(ctx).Limit(limit).Offset(offset).Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                return nil, models.NewInternalError(err)
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package seed provides helpers to create test and demo data for the
// application database. These helpers are intended for development and
// testing only.
package seed

import (
        "fmt"

        "sanctum/internal/models"

        "github.com/brianvoe/gofakeit/v6"
        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
)

// Factory builds domain entities and persists them to the database.
// It is a thin helper used by seed presets and tests.
type Factory struct {
        db *gorm.DB
}

// NewFactory creates a new Factory bound to the provided Gorm DB.
func NewFactory(db *gorm.DB) *Factory <span class="cov0" title="0">{
        return &amp;Factory{db: db}
}</span>

// CreateUser constructs and persists a sample `models.User`.
// Optional override functions may modify the generated user before saving.
func (f *Factory) CreateUser(overrides ...func(*models.User)) (*models.User, error) <span class="cov0" title="0">{
        hashedPassword, _ := bcrypt.GenerateFromPassword([]byte("password123"), bcrypt.DefaultCost)

        user := &amp;models.User{
                Username: gofakeit.Username() + fmt.Sprintf("%d", gofakeit.Number(100, 999)),
                Email:    gofakeit.Email(),
                Password: string(hashedPassword),
                Bio:      gofakeit.Sentence(10),
                Avatar:   fmt.Sprintf("https://i.pravatar.cc/150?u=%s", gofakeit.UUID()),
        }

        for _, override := range overrides </span><span class="cov0" title="0">{
                override(user)
        }</span>

        <span class="cov0" title="0">if err := f.db.Create(user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

// CreatePost constructs and persists a sample `models.Post` for the given user.
func (f *Factory) CreatePost(user *models.User, overrides ...func(*models.Post)) (*models.Post, error) <span class="cov0" title="0">{
        post := &amp;models.Post{
                Title:    gofakeit.Sentence(5),
                Content:  gofakeit.Paragraph(1, 3, 5, "\n"),
                UserID:   user.ID,
                ImageURL: fmt.Sprintf("https://picsum.photos/seed/%s/800/800", gofakeit.UUID()),
        }

        for _, override := range overrides </span><span class="cov0" title="0">{
                override(post)
        }</span>

        <span class="cov0" title="0">if err := f.db.Create(post).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return post, nil</span>
}

// CreateComment constructs and persists a sample `models.Comment` on the
// provided post authored by the provided user.
func (f *Factory) CreateComment(user *models.User, post *models.Post, overrides ...func(*models.Comment)) (*models.Comment, error) <span class="cov0" title="0">{
        comment := &amp;models.Comment{
                Content: gofakeit.Sentence(8),
                UserID:  user.ID,
                PostID:  post.ID,
        }

        for _, override := range overrides </span><span class="cov0" title="0">{
                override(comment)
        }</span>

        <span class="cov0" title="0">if err := f.db.Create(comment).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return comment, nil</span>
}

// CreateLike persists a like from `user` on `post`.
func (f *Factory) CreateLike(user *models.User, post *models.Post) error <span class="cov0" title="0">{
        like := &amp;models.Like{
                UserID: user.ID,
                PostID: post.ID,
        }
        return f.db.Create(like).Error
}</span>

// CreateFriendship persists a friendship relationship between two users.
func (f *Factory) CreateFriendship(requester, addressee *models.User, status models.FriendshipStatus) error <span class="cov0" title="0">{
        friendship := &amp;models.Friendship{
                RequesterID: requester.ID,
                AddresseeID: addressee.ID,
                Status:      status,
        }
        return f.db.Create(friendship).Error
}</span>

// CreateMessage constructs and persists a sample `models.Message` in the
// provided conversation from the provided sender.
func (f *Factory) CreateMessage(conversation *models.Conversation, sender *models.User, overrides ...func(*models.Message)) (*models.Message, error) <span class="cov0" title="0">{
        message := &amp;models.Message{
                ConversationID: conversation.ID,
                SenderID:       sender.ID,
                Content:        gofakeit.Sentence(10),
                MessageType:    "text",
        }

        for _, override := range overrides </span><span class="cov0" title="0">{
                override(message)
        }</span>

        <span class="cov0" title="0">if err := f.db.Create(message).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return message, nil</span>
}

// CreateGame constructs and persists a `models.GameRoom` with the given
// creator, type and status.
func (f *Factory) CreateGame(creator *models.User, gameType models.GameType, status models.GameStatus, overrides ...func(*models.GameRoom)) (*models.GameRoom, error) <span class="cov0" title="0">{
        game := &amp;models.GameRoom{
                Type:      gameType,
                Status:    status,
                CreatorID: creator.ID,
        }

        for _, override := range overrides </span><span class="cov0" title="0">{
                override(game)
        }</span>

        <span class="cov0" title="0">if err := f.db.Create(game).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return game, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package seed

import (
        "errors"
        "fmt"

        "sanctum/internal/models"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

// BuiltInSanctum is a permanent system sanctum.
type BuiltInSanctum struct {
        Name        string
        Slug        string
        Description string
}

// BuiltInSanctums defines the permanent system sanctums.
var BuiltInSanctums = []BuiltInSanctum{
        {Name: "General", Slug: "atrium", Description: "Core discussion for Sanctum."},
        {Name: "Herald Announcements", Slug: "herald", Description: "Announcements and platform updates."},
        {Name: "Support", Slug: "support", Description: "Help and troubleshooting."},
        {Name: "Movies", Slug: "movies", Description: "Film discussion and recommendations."},
        {Name: "Television", Slug: "television", Description: "TV shows and series conversation."},
        {Name: "Books", Slug: "books", Description: "Books, writing, and reading lists."},
        {Name: "Music", Slug: "music", Description: "Music discovery and discussion."},
        {Name: "Anime", Slug: "anime", Description: "Anime and manga talk."},
        {Name: "Gaming", Slug: "gaming", Description: "Gaming across all platforms."},
        {Name: "Pcgaming", Slug: "pcgaming", Description: "PC gaming hardware and titles."},
        {Name: "Development", Slug: "development", Description: "Software development discussions."},
        {Name: "Hardware", Slug: "hardware", Description: "Hardware builds and tuning."},
        {Name: "Linux", Slug: "linux", Description: "Linux distros, tooling, and workflows."},
        {Name: "Ai", Slug: "ai", Description: "AI trends, tools, and research."},
        {Name: "Fitness", Slug: "fitness", Description: "Fitness and training programs."},
        {Name: "Food", Slug: "food", Description: "Food, cooking, and nutrition."},
}

// Sanctums seeds permanent built-in sanctums and their default chat rooms.
func Sanctums(db *gorm.DB) error <span class="cov2" title="2">{
        for _, item := range BuiltInSanctums </span><span class="cov10" title="32">{
                err := db.Transaction(func(tx *gorm.DB) error </span><span class="cov10" title="32">{
                        sanctum := models.Sanctum{
                                Name:        item.Name,
                                Slug:        item.Slug,
                                Description: item.Description,
                                Status:      models.SanctumStatusActive,
                        }

                        if err := tx.Clauses(clause.OnConflict{
                                Columns:   []clause.Column{{Name: "slug"}},
                                DoUpdates: clause.AssignmentColumns([]string{"name", "description", "status", "updated_at"}),
                        }).Create(&amp;sanctum).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov10" title="32">if sanctum.ID == 0 </span><span class="cov0" title="0">{
                                if err := tx.Where("slug = ?", item.Slug).First(&amp;sanctum).Error; err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                        <span class="cov10" title="32">var existing models.Conversation
                        queryErr := tx.Where("sanctum_id = ?", sanctum.ID).First(&amp;existing).Error
                        switch </span>{
                        case queryErr == nil:<span class="cov8" title="16">
                                if existing.Name != sanctum.Name </span><span class="cov0" title="0">{
                                        updateErr := tx.Model(&amp;models.Conversation{}).Where("id = ?", existing.ID).Update("name", sanctum.Name).Error
                                        if updateErr != nil </span><span class="cov0" title="0">{
                                                return updateErr
                                        }</span>
                                }
                                <span class="cov8" title="16">return nil</span>
                        case queryErr != nil &amp;&amp; !errors.Is(queryErr, gorm.ErrRecordNotFound):<span class="cov0" title="0">
                                return queryErr</span>
                        }

                        <span class="cov8" title="16">conv := models.Conversation{
                                Name:      sanctum.Name,
                                IsGroup:   true,
                                CreatedBy: 0,
                                SanctumID: &amp;sanctum.ID,
                        }
                        if err := tx.Create(&amp;conv).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="16">return nil</span>
                })
                <span class="cov10" title="32">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("seed built-in sanctum %s: %w", item.Slug, err)
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package seed

import (
        "fmt"
        "log"
        "math/rand"
        "time"

        "sanctum/internal/models"

        "gorm.io/gorm"
)

// Seeder provides high-level methods to populate the database with
// representative demo and test data. Methods are safe for local/dev use.
type Seeder struct {
        db      *gorm.DB
        factory *Factory
}

// NewSeeder creates a Seeder for the given Gorm DB.
func NewSeeder(db *gorm.DB) *Seeder <span class="cov0" title="0">{
        return &amp;Seeder{
                db:      db,
                factory: NewFactory(db),
        }
}</span>

// ClearAll truncates application tables and resets sequences. Intended
// for test/setup workflows only.
func (s *Seeder) ClearAll() error <span class="cov0" title="0">{
        log.Println("üóëÔ∏è  Clearing all existing data...")
        sql := `TRUNCATE TABLE comments, likes, posts, conversation_participants, messages, conversations, sanctum_memberships, sanctum_requests, sanctums, stream_messages, streams, users, friendships, game_rooms, game_moves RESTART IDENTITY CASCADE;`
        return s.db.Exec(sql).Error
}</span>

// SeedSocialMesh creates a number of users and random friendships
// to simulate a social graph for testing and local development.
func (s *Seeder) SeedSocialMesh(userCount int) ([]*models.User, error) <span class="cov0" title="0">{
        log.Printf("üï∏Ô∏è  Seeding social mesh with %d users...", userCount)
        users := make([]*models.User, 0, userCount)

        // Admin and system users
        baseUsers := []string{"corey", "cburns", "test"}
        for _, username := range baseUsers </span><span class="cov0" title="0">{
                u, err := s.factory.CreateUser(func(u *models.User) </span><span class="cov0" title="0">{
                        u.Username = username
                        u.Email = username + "@example.com"
                }</span>)
                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                        users = append(users, u)
                }</span>
        }

        // Random users
        <span class="cov0" title="0">for i := len(users); i &lt; userCount; i++ </span><span class="cov0" title="0">{
                u, err := s.factory.CreateUser()
                if err == nil </span><span class="cov0" title="0">{
                        users = append(users, u)
                }</span>
        }

        // Friendships
        // #nosec G404: Non-cryptographic randomness is acceptable for seeding test data
        <span class="cov0" title="0">r := rand.New(rand.NewSource(time.Now().UnixNano()))
        for _, u1 := range users </span><span class="cov0" title="0">{
                targets := r.Intn(5) + 1
                for i := 0; i &lt; targets; i++ </span><span class="cov0" title="0">{
                        u2 := users[r.Intn(len(users))]
                        if u1.ID == u2.ID </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">status := models.FriendshipStatusAccepted
                        if r.Float32() &lt; 0.2 </span><span class="cov0" title="0">{
                                status = models.FriendshipStatusPending
                        }</span>
                        <span class="cov0" title="0">_ = s.factory.CreateFriendship(u1, u2, status)</span>
                }
        }

        <span class="cov0" title="0">return users, nil</span>
}

// SeedEngagement creates posts, likes and comments to generate feed
// activity for testing and local development.
func (s *Seeder) SeedEngagement(users []*models.User, postCount int) ([]*models.Post, error) <span class="cov0" title="0">{
        log.Printf("üî• Seeding engagement for %d posts...", postCount)
        posts := make([]*models.Post, 0, postCount)
        // #nosec G404: Non-cryptographic randomness is acceptable for seeding test data
        r := rand.New(rand.NewSource(time.Now().UnixNano()))

        for i := 0; i &lt; postCount; i++ </span><span class="cov0" title="0">{
                creator := users[r.Intn(len(users))]
                p, err := s.factory.CreatePost(creator)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">posts = append(posts, p)

                // Random likes
                likersCount := r.Intn(len(users) / 2)
                for j := 0; j &lt; likersCount; j++ </span><span class="cov0" title="0">{
                        liker := users[r.Intn(len(users))]
                        _ = s.factory.CreateLike(liker, p)
                }</span>

                // Random comments
                <span class="cov0" title="0">commentersCount := r.Intn(5)
                for j := 0; j &lt; commentersCount; j++ </span><span class="cov0" title="0">{
                        commenter := users[r.Intn(len(users))]
                        _, _ = s.factory.CreateComment(commenter, p)
                }</span>
        }

        <span class="cov0" title="0">return posts, nil</span>
}

// SeedActiveGames creates sample game rooms in a mix of states.
func (s *Seeder) SeedActiveGames(users []*models.User) error <span class="cov0" title="0">{
        log.Println("üéÆ Seeding active games...")
        // #nosec G404: Non-cryptographic randomness is acceptable for seeding test data
        r := rand.New(rand.NewSource(time.Now().UnixNano()))

        gameTypes := []models.GameType{models.TicTacToe, models.ConnectFour}

        for _, gType := range gameTypes </span><span class="cov0" title="0">{
                // One pending, one active, one finished
                creator := users[r.Intn(len(users))]
                _, _ = s.factory.CreateGame(creator, gType, models.GamePending)

                creator = users[r.Intn(len(users))]
                opponent := users[r.Intn(len(users))]
                for creator.ID == opponent.ID </span><span class="cov0" title="0">{
                        opponent = users[r.Intn(len(users))]
                }</span>
                <span class="cov0" title="0">_, _ = s.factory.CreateGame(creator, gType, models.GameActive, func(g *models.GameRoom) </span><span class="cov0" title="0">{
                        oID := opponent.ID
                        g.OpponentID = &amp;oID
                }</span>)
        }

        <span class="cov0" title="0">return nil</span>
}

// SeedDMs creates sample direct message conversations and messages.
func (s *Seeder) SeedDMs(users []*models.User) error <span class="cov0" title="0">{
        log.Println("üí¨ Seeding DM history...")
        // #nosec G404: Non-cryptographic randomness is acceptable for seeding test data
        r := rand.New(rand.NewSource(time.Now().UnixNano()))

        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                u1 := users[r.Intn(len(users))]
                u2 := users[r.Intn(len(users))]
                if u1.ID == u2.ID </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">conv := &amp;models.Conversation{
                        IsGroup:   false,
                        CreatedBy: u1.ID,
                }
                if err := s.db.Create(conv).Error; err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">_ = s.db.Model(conv).Association("Participants").Append(u1, u2)

                msgCount := r.Intn(10) + 5
                for j := 0; j &lt; msgCount; j++ </span><span class="cov0" title="0">{
                        sender := u1
                        if j%2 == 0 </span><span class="cov0" title="0">{
                                sender = u2
                        }</span>
                        <span class="cov0" title="0">_, _ = s.factory.CreateMessage(conv, sender)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// SeedSanctumPosts creates 50 posts for each existing sanctum, with random
// engagement from the provided users.
func (s *Seeder) SeedSanctumPosts(users []*models.User) error <span class="cov0" title="0">{
        log.Println("üè∞ Seeding sanctum-specific posts...")
        var sanctums []*models.Sanctum
        if err := s.db.Find(&amp;sanctums).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // #nosec G404: Non-cryptographic randomness is acceptable for seeding test data
        <span class="cov0" title="0">r := rand.New(rand.NewSource(time.Now().UnixNano()))

        for _, sanctum := range sanctums </span><span class="cov0" title="0">{
                log.Printf("  üìç Seeding 50 posts for sanctum: %s", sanctum.Name)
                for i := 0; i &lt; 50; i++ </span><span class="cov0" title="0">{
                        creator := users[r.Intn(len(users))]
                        p, err := s.factory.CreatePost(creator, func(p *models.Post) </span><span class="cov0" title="0">{
                                p.SanctumID = &amp;sanctum.ID
                                p.Title = fmt.Sprintf("[%s] %s", sanctum.Name, p.Title)
                        }</span>)
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Random likes
                        <span class="cov0" title="0">likersCount := r.Intn(len(users) / 3)
                        for j := 0; j &lt; likersCount; j++ </span><span class="cov0" title="0">{
                                liker := users[r.Intn(len(users))]
                                _ = s.factory.CreateLike(liker, p)
                        }</span>

                        // Random comments
                        <span class="cov0" title="0">commentersCount := r.Intn(5) + 2 // At least 2 comments
                        for j := 0; j &lt; commentersCount; j++ </span><span class="cov0" title="0">{
                                commenter := users[r.Intn(len(users))]
                                _, _ = s.factory.CreateComment(commenter, p)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// ApplyPreset runs a named seeder preset (e.g. "MegaPopulated").
func (s *Seeder) ApplyPreset(name string) error <span class="cov0" title="0">{
        log.Printf("üåü Applying seeder preset: %s", name)
        switch name </span>{
        case "MegaPopulated":<span class="cov0" title="0">
                users, err := s.SeedSocialMesh(50)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_, _ = s.SeedEngagement(users, 50)
                _ = s.SeedSanctumPosts(users)
                _ = s.SeedActiveGames(users)
                _ = s.SeedDMs(users)</span>
        default:<span class="cov0" title="0">
                log.Printf("‚ö†Ô∏è Unknown preset: %s", name)</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package server contains HTTP and WebSocket handlers for the application's API endpoints.
package server

import (
        "context"
        "fmt"
        "strconv"
        "strings"
        "time"

        "sanctum/internal/models"
        "sanctum/internal/validation"

        "github.com/gofiber/fiber/v2"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

// Signup handles POST /api/auth/signup
// @Summary User signup
// @Description Register a new user account
// @Tags auth
// @Accept json
// @Produce json
// @Param request body object{username=string,email=string,password=string} true "Signup request"
// @Success 201 {object} object{token=string,refresh_token=string,user=models.User}
// @Failure 400 {object} object{error=string}
// @Failure 409 {object} object{error=string}
// @Router /auth/signup [post]
func (s *Server) Signup(c *fiber.Ctx) error <span class="cov8" title="5">{
        var req struct {
                Username string `json:"username"`
                Email    string `json:"email"`
                Password string `json:"password"`
        }
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        // Validate input
        <span class="cov8" title="5">if req.Username == "" || req.Email == "" || req.Password == "" </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Username, email, and password are required"))
        }</span>

        // Validate username format
        <span class="cov8" title="5">if err := validation.ValidateUsername(req.Username); err != nil </span><span class="cov1" title="1">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError(err.Error()))
        }</span>

        // Validate email format
        <span class="cov7" title="4">if err := validation.ValidateEmail(req.Email); err != nil </span><span class="cov1" title="1">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError(err.Error()))
        }</span>

        // Validate password strength
        <span class="cov6" title="3">if err := validation.ValidatePassword(req.Password); err != nil </span><span class="cov1" title="1">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError(err.Error()))
        }</span>

        // Check if user already exists
        <span class="cov4" title="2">existing, err := s.userRepo.GetByEmail(c.Context(), req.Email)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>
        <span class="cov4" title="2">if existing != nil </span><span class="cov1" title="1">{
                return models.RespondWithError(c, fiber.StatusConflict,
                        models.NewValidationError("User already exists"))
        }</span>

        // Hash password
        <span class="cov1" title="1">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        // Create user
        <span class="cov1" title="1">user := &amp;models.User{
                Username: req.Username,
                Email:    req.Email,
                Password: string(hashedPassword),
        }

        if createErr := s.userRepo.Create(c.Context(), user); createErr != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, createErr)
        }</span>

        // Generate tokens
        <span class="cov1" title="1">accessToken, err := s.generateAccessToken(user.ID, user.Username)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        <span class="cov1" title="1">refreshToken, err := s.generateRefreshToken(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        <span class="cov1" title="1">return c.Status(fiber.StatusCreated).JSON(fiber.Map{
                "token":         accessToken,
                "refresh_token": refreshToken,
                "user":          user,
        })</span>
}

// Login handles POST /api/auth/login
// @Summary User login
// @Description Authenticate user and return JWT tokens
// @Tags auth
// @Accept json
// @Produce json
// @Param request body object{email=string,password=string} true "Login credentials"
// @Success 200 {object} object{token=string,refresh_token=string,user=models.User}
// @Failure 400 {object} object{error=string}
// @Failure 401 {object} object{error=string}
// @Router /auth/login [post]
func (s *Server) Login(c *fiber.Ctx) error <span class="cov4" title="2">{
        var req struct {
                Email    string `json:"email"`
                Password string `json:"password"`
        }
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        // Find user by email
        <span class="cov4" title="2">user, err := s.userRepo.GetByEmail(c.Context(), req.Email)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>
        <span class="cov4" title="2">if user == nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusUnauthorized,
                        models.NewUnauthorizedError("Invalid credentials"))
        }</span>

        // Compare password
        <span class="cov4" title="2">if cmpErr := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password)); cmpErr != nil </span><span class="cov1" title="1">{
                return models.RespondWithError(c, fiber.StatusUnauthorized,
                        models.NewUnauthorizedError("Invalid credentials"))
        }</span>

        // Generate tokens
        <span class="cov1" title="1">accessToken, err := s.generateAccessToken(user.ID, user.Username)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        <span class="cov1" title="1">refreshToken, err := s.generateRefreshToken(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        <span class="cov1" title="1">return c.JSON(fiber.Map{
                "token":         accessToken,
                "refresh_token": refreshToken,
                "user":          user,
        })</span>
}

// Refresh handles POST /api/auth/refresh
// @Summary Refresh JWT token
// @Description Get a new access token using a refresh token
// @Tags auth
// @Accept json
// @Produce json
// @Param request body object{refresh_token=string} true "Refresh request"
// @Success 200 {object} object{token=string,refresh_token=string}
// @Failure 401 {object} object{error=string}
// @Router /auth/refresh [post]
func (s *Server) Refresh(c *fiber.Ctx) error <span class="cov6" title="3">{
        var req struct {
                RefreshToken string `json:"refresh_token"`
        }
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        <span class="cov6" title="3">if req.RefreshToken == "" </span><span class="cov1" title="1">{
                return models.RespondWithError(c, fiber.StatusUnauthorized,
                        models.NewUnauthorizedError("Refresh token required"))
        }</span>

        // Parse and validate refresh token
        <span class="cov4" title="2">token, err := jwt.Parse(req.RefreshToken, func(token *jwt.Token) (interface{}, error) </span><span class="cov1" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov1" title="1">return []byte(s.config.JWTSecret), nil</span>
        })

        <span class="cov4" title="2">if err != nil || !token.Valid </span><span class="cov1" title="1">{
                return models.RespondWithError(c, fiber.StatusUnauthorized,
                        models.NewUnauthorizedError("Invalid or expired refresh token"))
        }</span>

        <span class="cov1" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusUnauthorized,
                        models.NewUnauthorizedError("Invalid token claims"))
        }</span>

        // Check if it's a refresh token
        <span class="cov1" title="1">if aud, ok := claims["aud"].(string); !ok || aud != "sanctum-refresh" </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusUnauthorized,
                        models.NewUnauthorizedError("Invalid token type"))
        }</span>

        // Extract user ID
        <span class="cov1" title="1">sub, ok := claims["sub"].(string)
        if !ok </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusUnauthorized,
                        models.NewUnauthorizedError("Invalid subject claim"))
        }</span>

        <span class="cov1" title="1">userID64, err := strconv.ParseUint(sub, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusUnauthorized,
                        models.NewUnauthorizedError("Invalid user ID in token"))
        }</span>
        <span class="cov1" title="1">userID := uint(userID64)

        // Check JTI in Redis (revocation check)
        jti, ok := claims["jti"].(string)
        if !ok </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusUnauthorized,
                        models.NewUnauthorizedError("Invalid JTI claim"))
        }</span>

        <span class="cov1" title="1">if s.redis != nil </span><span class="cov0" title="0">{
                redisKey := fmt.Sprintf("refresh_token:%d:%s", userID, jti)
                exists, err := s.redis.Exists(c.Context(), redisKey).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return models.RespondWithError(c, fiber.StatusInternalServerError,
                                models.NewInternalError(err))
                }</span>
                <span class="cov0" title="0">if exists == 0 </span><span class="cov0" title="0">{
                        return models.RespondWithError(c, fiber.StatusUnauthorized,
                                models.NewUnauthorizedError("Refresh token revoked or already used"))
                }</span>

                // Refresh token rotation: Revoke current one
                <span class="cov0" title="0">s.redis.Del(c.Context(), redisKey)</span>
        }

        // Get user to ensure they still exist and get username
        <span class="cov1" title="1">user, err := s.userRepo.GetByID(c.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusUnauthorized,
                        models.NewUnauthorizedError("User no longer exists"))
        }</span>

        // Generate new tokens
        <span class="cov1" title="1">newAccessToken, err := s.generateAccessToken(user.ID, user.Username)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        <span class="cov1" title="1">newRefreshToken, err := s.generateRefreshToken(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        <span class="cov1" title="1">return c.JSON(fiber.Map{
                "token":         newAccessToken,
                "refresh_token": newRefreshToken,
        })</span>
}

// Logout handles POST /api/auth/logout
// @Summary User logout
// @Description Revoke refresh token and blacklist current access token
// @Tags auth
// @Accept json
// @Produce json
// @Param request body object{refresh_token=string} true "Logout request"
// @Success 200 {object} object{message=string}
// @Router /auth/logout [post]
func (s *Server) Logout(c *fiber.Ctx) error <span class="cov4" title="2">{
        var req struct {
                RefreshToken string `json:"refresh_token"`
        }
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        // Blacklist the access token if provided in Authorization header
        <span class="cov4" title="2">authHeader := c.Get("Authorization")
        if authHeader != "" </span><span class="cov0" title="0">{
                parts := strings.Split(authHeader, " ")
                if len(parts) == 2 &amp;&amp; parts[0] == "Bearer" </span><span class="cov0" title="0">{
                        accessToken := parts[1]
                        token, err := jwt.Parse(accessToken, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                                return []byte(s.config.JWTSecret), nil
                        }</span>)
                        <span class="cov0" title="0">if err == nil &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                                if claims, ok := token.Claims.(jwt.MapClaims); ok </span><span class="cov0" title="0">{
                                        if jti, ok := claims["jti"].(string); ok &amp;&amp; s.redis != nil </span><span class="cov0" title="0">{
                                                // Extract expiration to set TTL for blacklist
                                                if exp, ok := claims["exp"].(float64); ok </span><span class="cov0" title="0">{
                                                        ttl := time.Until(time.Unix(int64(exp), 0))
                                                        if ttl &gt; 0 </span><span class="cov0" title="0">{
                                                                s.redis.Set(c.Context(), "blacklist:"+jti, "1", ttl)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov4" title="2">if req.RefreshToken == "" </span><span class="cov1" title="1">{
                return c.JSON(fiber.Map{"message": "Logged out successfully"})
        }</span>

        // Parse token to get JTI and userID
        <span class="cov1" title="1">token, err := jwt.Parse(req.RefreshToken, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(s.config.JWTSecret), nil
        }</span>)

        <span class="cov1" title="1">if err == nil &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                if claims, ok := token.Claims.(jwt.MapClaims); ok </span><span class="cov0" title="0">{
                        sub, _ := claims["sub"].(string)
                        jti, _ := claims["jti"].(string)
                        userID, _ := strconv.ParseUint(sub, 10, 32)

                        if s.redis != nil &amp;&amp; jti != "" </span><span class="cov0" title="0">{
                                redisKey := fmt.Sprintf("refresh_token:%d:%s", userID, jti)
                                s.redis.Del(c.Context(), redisKey)
                        }</span>
                }
        }

        <span class="cov1" title="1">return c.JSON(fiber.Map{"message": "Logged out successfully"})</span>
}

// generateAccessToken creates a short-lived JWT token for the given user ID and username
func (s *Server) generateAccessToken(userID uint, username string) (string, error) <span class="cov6" title="3">{
        // Validate secret exists
        if s.config.JWTSecret == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("JWT secret not configured")
        }</span>

        <span class="cov6" title="3">now := time.Now()
        claims := jwt.MapClaims{
                "sub":      strconv.FormatUint(uint64(userID), 10), // Subject (user ID as string)
                "username": username,                               // Username (cached in token)
                "iss":      "sanctum-api",                          // Issuer
                "aud":      "sanctum-client",                       // Audience
                "exp":      now.Add(15 * time.Minute).Unix(),       // Expiration (15 minutes)
                "iat":      now.Unix(),                             // Issued at
                "nbf":      now.Unix(),                             // Not before
                "jti":      s.generateJTI(),                        // JWT ID (unique identifier)
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(s.config.JWTSecret))</span>
}

// generateRefreshToken creates a long-lived JWT token for the given user ID
func (s *Server) generateRefreshToken(userID uint) (string, error) <span class="cov7" title="4">{
        if s.config.JWTSecret == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("JWT secret not configured")
        }</span>

        <span class="cov7" title="4">now := time.Now()
        jti := s.generateJTI()
        expiresAt := now.Add(7 * 24 * time.Hour)

        claims := jwt.MapClaims{
                "sub": strconv.FormatUint(uint64(userID), 10),
                "iss": "sanctum-api",
                "aud": "sanctum-refresh",
                "exp": expiresAt.Unix(),
                "iat": now.Unix(),
                "jti": jti,
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        signedToken, err := token.SignedString([]byte(s.config.JWTSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Store JTI in Redis
        <span class="cov7" title="4">if s.redis != nil </span><span class="cov0" title="0">{
                redisKey := fmt.Sprintf("refresh_token:%d:%s", userID, jti)
                err = s.redis.Set(context.Background(), redisKey, "1", 7*24*time.Hour).Err()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to store refresh token: %w", err)
                }</span>
        }

        <span class="cov7" title="4">return signedToken, err</span>
}

// generateJTI creates a unique JWT ID to prevent replay attacks
func (s *Server) generateJTI() string <span class="cov10" title="7">{
        return fmt.Sprintf("%d-%s", time.Now().Unix(), uuid.New().String()[:8])
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Package server contains HTTP and WebSocket handlers for the application's API endpoints.
package server

import (
        "encoding/json"
        "time"

        "sanctum/internal/models"
        "sanctum/internal/notifications"
        "sanctum/internal/service"

        "github.com/gofiber/fiber/v2"
        "gorm.io/gorm"
)

// CreateConversation handles POST /api/conversations
func (s *Server) CreateConversation(c *fiber.Ctx) error <span class="cov10" title="2">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)

        var req struct {
                Name           string `json:"name,omitempty"`
                IsGroup        bool   `json:"is_group,omitempty"`
                ParticipantIDs []uint `json:"participant_ids"`
        }
        if parseErr := c.BodyParser(&amp;req); parseErr != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        <span class="cov10" title="2">conv, err := s.chatSvc().CreateConversation(ctx, service.CreateConversationInput{
                UserID:         userID,
                Name:           req.Name,
                IsGroup:        req.IsGroup,
                ParticipantIDs: req.ParticipantIDs,
        })
        if err != nil </span><span class="cov1" title="1">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok &amp;&amp; appErr.Code == "VALIDATION_ERROR" </span><span class="cov1" title="1">{
                        status = fiber.StatusBadRequest
                }</span>
                <span class="cov1" title="1">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov1" title="1">return c.Status(fiber.StatusCreated).JSON(conv)</span>
}

// GetConversations handles GET /api/conversations
func (s *Server) GetConversations(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)

        conversations, err := s.chatSvc().GetConversations(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">for _, conv := range conversations </span><span class="cov0" title="0">{
                if conv.IsGroup </span><span class="cov0" title="0">{
                        conv.Participants = s.filterOnlineParticipants(conv.Participants)
                }</span>
        }

        <span class="cov0" title="0">return c.JSON(conversations)</span>
}

// GetConversation handles GET /api/conversations/:id
func (s *Server) GetConversation(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        convID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">conv, err := s.chatSvc().GetConversationForUser(ctx, convID, userID)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok &amp;&amp; appErr.Code == "UNAUTHORIZED" </span><span class="cov0" title="0">{
                        status = fiber.StatusForbidden
                }</span> else<span class="cov0" title="0"> if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        status = fiber.StatusNotFound
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">if conv.IsGroup </span><span class="cov0" title="0">{
                conv.Participants = s.filterOnlineParticipants(conv.Participants)
        }</span>

        <span class="cov0" title="0">return c.JSON(conv)</span>
}

// SendMessage handles POST /api/conversations/:id/messages
func (s *Server) SendMessage(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        convID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var req struct {
                Content     string          `json:"content"`
                MessageType string          `json:"message_type,omitempty"`
                Metadata    json.RawMessage `json:"metadata,omitempty"`
        }
        if parseErr := c.BodyParser(&amp;req); parseErr != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        <span class="cov0" title="0">message, conv, err := s.chatSvc().SendMessage(ctx, service.SendMessageInput{
                UserID:         userID,
                ConversationID: convID,
                Content:        req.Content,
                MessageType:    req.MessageType,
                Metadata:       req.Metadata,
        })
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok </span><span class="cov0" title="0">{
                        switch appErr.Code </span>{
                        case "VALIDATION_ERROR":<span class="cov0" title="0">
                                status = fiber.StatusBadRequest</span>
                        case "UNAUTHORIZED":<span class="cov0" title="0">
                                status = fiber.StatusForbidden</span>
                        }
                } else<span class="cov0" title="0"> if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        status = fiber.StatusNotFound
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">senderUsername := ""
        if message.Sender != nil </span><span class="cov0" title="0">{
                senderUsername = message.Sender.Username
        }</span>

        // Broadcast message to all WebSocket-connected participants in real-time via ChatHub
        <span class="cov0" title="0">if s.chatHub != nil </span><span class="cov0" title="0">{
                s.chatHub.BroadcastToConversation(convID, notifications.ChatMessage{
                        Type:           "message",
                        ConversationID: convID,
                        UserID:         userID,
                        Username:       senderUsername,
                        Payload:        message,
                })
        }</span>

        // For public chatrooms, broadcast room-level realtime updates to all connected users
        // so room tabs/counters can react even when the room isn't currently open.
        <span class="cov0" title="0">if conv.IsGroup &amp;&amp; s.chatHub != nil </span><span class="cov0" title="0">{
                s.chatHub.BroadcastToAllUsers(notifications.ChatMessage{
                        Type:           "room_message",
                        ConversationID: convID,
                        UserID:         userID,
                        Username:       senderUsername,
                        Payload:        message,
                })
        }</span>

        // Notify only for direct messages; chatroom/group traffic should not trigger
        // global bell/toast notifications.
        <span class="cov0" title="0">if !conv.IsGroup </span><span class="cov0" title="0">{
                for _, participant := range conv.Participants </span><span class="cov0" title="0">{
                        if participant.ID == userID </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">s.publishUserEvent(participant.ID, EventMessageReceived, map[string]interface{}{
                                "conversation_id": conv.ID,
                                "message_id":      message.ID,
                                "is_group":        conv.IsGroup,
                                "from_user":       userSummaryPtr(message.Sender),
                                "preview":         message.Content,
                                "created_at":      time.Now().UTC().Format(time.RFC3339Nano),
                        })</span>
                }
        }

        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(message)</span>
}

// GetMessages handles GET /api/conversations/:id/messages
func (s *Server) GetMessages(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        convID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">page := parsePagination(c, 50)

        messages, err := s.chatSvc().GetMessagesForUser(ctx, convID, userID, page.Limit, page.Offset)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok &amp;&amp; appErr.Code == "UNAUTHORIZED" </span><span class="cov0" title="0">{
                        status = fiber.StatusForbidden
                }</span> else<span class="cov0" title="0"> if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        status = fiber.StatusNotFound
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">return c.JSON(messages)</span>
}

// AddParticipant handles POST /api/conversations/:id/participants
func (s *Server) AddParticipant(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        convID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var req struct {
                UserID uint `json:"user_id"`
        }
        if parseErr := c.BodyParser(&amp;req); parseErr != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        <span class="cov0" title="0">if err := s.chatSvc().AddParticipant(ctx, convID, userID, req.UserID); err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok </span><span class="cov0" title="0">{
                        switch appErr.Code </span>{
                        case "UNAUTHORIZED":<span class="cov0" title="0">
                                status = fiber.StatusForbidden</span>
                        case "VALIDATION_ERROR":<span class="cov0" title="0">
                                status = fiber.StatusBadRequest</span>
                        }
                } else<span class="cov0" title="0"> if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        status = fiber.StatusNotFound
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">return c.SendStatus(fiber.StatusOK)</span>
}

// LeaveConversation handles DELETE /api/conversations/:id
// Removes the current user from a conversation so it no longer appears in their list.
func (s *Server) LeaveConversation(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        convID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">conv, err := s.chatSvc().LeaveConversation(ctx, convID, userID)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok &amp;&amp; appErr.Code == "UNAUTHORIZED" </span><span class="cov0" title="0">{
                        status = fiber.StatusForbidden
                }</span> else<span class="cov0" title="0"> if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        status = fiber.StatusNotFound
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">if conv.IsGroup </span><span class="cov0" title="0">{
                s.broadcastChatroomPresenceSnapshot(ctx, convID, userID, "", "left_room")
        }</span>

        <span class="cov0" title="0">return c.JSON(fiber.Map{"message": "Conversation removed"})</span>
}

func (s *Server) chatSvc() *service.ChatService <span class="cov10" title="2">{
        if s.chatService == nil </span><span class="cov1" title="1">{
                s.chatService = service.NewChatService(s.chatRepo, s.userRepo, s.db, s.isAdminByUserID)
        }</span>
        <span class="cov10" title="2">return s.chatService</span>
}

// GetAllChatrooms handles GET /api/chatrooms - returns ALL public chatrooms
func (s *Server) GetAllChatrooms(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)

        chatrooms, err := s.chatSvc().GetAllChatrooms(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        // Add "is_joined" field to each chatroom
        <span class="cov0" title="0">type ChatroomResponse struct {
                *models.Conversation
                IsJoined bool `json:"is_joined"`
        }

        result := make([]ChatroomResponse, 0, len(chatrooms))
        for _, room := range chatrooms </span><span class="cov0" title="0">{
                result = append(result, ChatroomResponse{
                        Conversation: room.Conversation,
                        IsJoined:     room.IsJoined,
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(result)</span>
}

// GetJoinedChatrooms handles GET /api/chatrooms/joined - returns chatrooms the user has joined
func (s *Server) GetJoinedChatrooms(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)

        chatrooms, err := s.chatSvc().GetJoinedChatrooms(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(chatrooms)</span>
}

// JoinChatroom handles POST /api/chatrooms/:id/join - join a chatroom
func (s *Server) JoinChatroom(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        roomID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if _, err := s.chatSvc().JoinChatroom(ctx, roomID, userID); err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok </span><span class="cov0" title="0">{
                        switch appErr.Code </span>{
                        case "NOT_FOUND":<span class="cov0" title="0">
                                status = fiber.StatusNotFound</span>
                        case "VALIDATION_ERROR":<span class="cov0" title="0">
                                status = fiber.StatusBadRequest</span>
                        }
                }
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">s.broadcastChatroomPresenceSnapshot(ctx, roomID, userID, "", "joined_room")

        return c.JSON(fiber.Map{"message": "Joined chatroom successfully"})</span>
}

// RemoveParticipant handles DELETE /api/chatrooms/:id/participants/:participantId (admin only)
func (s *Server) RemoveParticipant(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        roomID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">participantID, err := s.parseID(c, "participantId")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">username, err := s.chatSvc().RemoveParticipant(ctx, roomID, userID, participantID)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok </span><span class="cov0" title="0">{
                        switch appErr.Code </span>{
                        case "NOT_FOUND":<span class="cov0" title="0">
                                status = fiber.StatusNotFound</span>
                        case "UNAUTHORIZED":<span class="cov0" title="0">
                                status = fiber.StatusForbidden</span>
                        }
                }
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">s.broadcastChatroomPresenceSnapshot(ctx, roomID, userID, username, "removed_participant")

        return c.JSON(fiber.Map{"message": "Participant removed successfully"})</span>
}

func (s *Server) filterOnlineParticipants(participants []models.User) []models.User <span class="cov0" title="0">{
        if len(participants) == 0 </span><span class="cov0" title="0">{
                return participants
        }</span>

        <span class="cov0" title="0">if s.chatHub == nil </span><span class="cov0" title="0">{
                return []models.User{}
        }</span>

        <span class="cov0" title="0">online := make([]models.User, 0, len(participants))
        for _, participant := range participants </span><span class="cov0" title="0">{
                if s.chatHub.IsUserOnline(participant.ID) </span><span class="cov0" title="0">{
                        online = append(online, participant)
                }</span>
        }
        <span class="cov0" title="0">return online</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package server contains HTTP and WebSocket handlers for the application's API endpoints.
package server

import (
        "time"

        "sanctum/internal/models"
        "sanctum/internal/service"

        "github.com/gofiber/fiber/v2"
)

// CreateComment creates a comment on a post (protected)
func (s *Server) CreateComment(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)

        postID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var req struct {
                Content string `json:"content"`
        }
        if parseErr := c.BodyParser(&amp;req); parseErr != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest, models.NewValidationError("Invalid request body"))
        }</span>

        <span class="cov0" title="0">created, err := s.commentSvc().CreateComment(ctx, service.CreateCommentInput{
                UserID:  userID,
                PostID:  postID,
                Content: req.Content,
        })
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok </span><span class="cov0" title="0">{
                        switch appErr.Code </span>{
                        case "VALIDATION_ERROR":<span class="cov0" title="0">
                                status = fiber.StatusBadRequest</span>
                        case "NOT_FOUND":<span class="cov0" title="0">
                                status = fiber.StatusNotFound</span>
                        }
                }
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">commentsCount := 0
        if post, postErr := s.postRepo.GetByID(ctx, postID, userID); postErr == nil </span><span class="cov0" title="0">{
                commentsCount = post.CommentsCount
        }</span>
        <span class="cov0" title="0">s.publishBroadcastEvent(EventCommentCreated, map[string]interface{}{
                "post_id":        postID,
                "comment":        created,
                "comments_count": commentsCount,
                "updated_at":     time.Now().UTC().Format(time.RFC3339Nano),
        })

        return c.Status(fiber.StatusCreated).JSON(created)</span>
}

// GetComments returns all comments for a post (public)
func (s *Server) GetComments(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        postID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">comments, err := s.commentSvc().ListComments(ctx, postID)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok &amp;&amp; appErr.Code == "NOT_FOUND" </span><span class="cov0" title="0">{
                        status = fiber.StatusNotFound
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">return c.JSON(comments)</span>
}

// UpdateComment updates a comment (only owner)
func (s *Server) UpdateComment(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)

        commentID, err := s.parseID(c, "commentId")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var req struct {
                Content string `json:"content"`
        }
        if parseErr := c.BodyParser(&amp;req); parseErr != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest, models.NewValidationError("Invalid request body"))
        }</span>

        <span class="cov0" title="0">updated, err := s.commentSvc().UpdateComment(ctx, service.UpdateCommentInput{
                UserID:    userID,
                CommentID: commentID,
                Content:   req.Content,
        })
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok </span><span class="cov0" title="0">{
                        switch appErr.Code </span>{
                        case "VALIDATION_ERROR":<span class="cov0" title="0">
                                status = fiber.StatusBadRequest</span>
                        case "NOT_FOUND":<span class="cov0" title="0">
                                status = fiber.StatusNotFound</span>
                        case "UNAUTHORIZED":<span class="cov0" title="0">
                                status = fiber.StatusForbidden</span>
                        }
                }
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">commentsCount := 0
        if post, postErr := s.postRepo.GetByID(ctx, updated.PostID, userID); postErr == nil </span><span class="cov0" title="0">{
                commentsCount = post.CommentsCount
        }</span>
        <span class="cov0" title="0">s.publishBroadcastEvent(EventCommentUpdated, map[string]interface{}{
                "post_id":        updated.PostID,
                "comment":        updated,
                "comments_count": commentsCount,
                "updated_at":     time.Now().UTC().Format(time.RFC3339Nano),
        })

        return c.JSON(updated)</span>
}

// DeleteComment deletes a comment (owner only)
func (s *Server) DeleteComment(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)

        commentID, err := s.parseID(c, "commentId")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">comment, err := s.commentSvc().DeleteComment(ctx, service.DeleteCommentInput{
                UserID:    userID,
                CommentID: commentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok </span><span class="cov0" title="0">{
                        switch appErr.Code </span>{
                        case "NOT_FOUND":<span class="cov0" title="0">
                                status = fiber.StatusNotFound</span>
                        case "UNAUTHORIZED":<span class="cov0" title="0">
                                status = fiber.StatusForbidden</span>
                        }
                }
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">commentsCount := 0
        if post, postErr := s.postRepo.GetByID(ctx, comment.PostID, userID); postErr == nil </span><span class="cov0" title="0">{
                commentsCount = post.CommentsCount
        }</span>
        <span class="cov0" title="0">s.publishBroadcastEvent(EventCommentDeleted, map[string]interface{}{
                "post_id":        comment.PostID,
                "comment_id":     commentID,
                "comments_count": commentsCount,
                "updated_at":     time.Now().UTC().Format(time.RFC3339Nano),
        })

        return c.SendStatus(fiber.StatusOK)</span>
}

func (s *Server) commentSvc() *service.CommentService <span class="cov0" title="0">{
        if s.commentService == nil </span><span class="cov0" title="0">{
                s.commentService = service.NewCommentService(s.commentRepo, s.postRepo, s.isAdminByUserID)
        }</span>
        <span class="cov0" title="0">return s.commentService</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Package server contains HTTP and WebSocket handlers for the application's API endpoints.
package server

import (
        "context"
        "encoding/json"
        "log"
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/websocket/v2"

        "sanctum/internal/middleware"
        "sanctum/internal/models"
)

// GetUserCached demonstrates cache-aside for GET /users/:id/cached
func (s *Server) GetUserCached(c *fiber.Ctx) error <span class="cov0" title="0">{
        id, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var user models.User

        u, err := s.userRepo.GetByID(context.Background(), id)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, models.NewInternalError(err))
        }</span>
        // copy into dest
        <span class="cov0" title="0">user = *u
        return c.JSON(user)</span>
}

// WebsocketHandler returns a websocket handler that registers connections with the Hub.
// Authentication is handled by route middleware and userID is read from connection locals.
func (s *Server) WebsocketHandler() fiber.Handler <span class="cov0" title="0">{
        return websocket.New(func(conn *websocket.Conn) </span><span class="cov0" title="0">{
                middleware.ActiveWebSockets.Inc()
                defer middleware.ActiveWebSockets.Dec()

                userIDVal := conn.Locals("userID")
                if userIDVal == nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                log.Printf("websocket close error: %v", cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">uid, ok := userIDVal.(uint)
                if !ok </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                log.Printf("websocket close error: %v", cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">if s.hub == nil </span><span class="cov0" title="0">{
                        _ = conn.Close()
                        return
                }</span>

                // Register connection with scaling guardrails
                <span class="cov0" title="0">client, err := s.hub.Register(uid, conn)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("WebSocket Notification: Failed to register user %d: %v", uid, err)
                        _ = conn.WriteMessage(websocket.TextMessage, []byte(`{"error":"`+err.Error()+`"}`))
                        _ = conn.Close()
                        return
                }</span>

                <span class="cov0" title="0">defer s.hub.UnregisterClient(client)

                // Presence logic
                s.notifyFriendsPresence(uid, "online")
                s.sendFriendsOnlineSnapshot(conn, uid)

                // Start pumps
                go client.WritePump()
                client.ReadPump()

                // After ReadPump returns, client is disconnected
                if !s.hub.IsOnline(uid) </span><span class="cov0" title="0">{
                        s.notifyFriendsPresence(uid, "offline")
                }</span>
        })
}

func (s *Server) notifyFriendsPresence(userID uint, status string) <span class="cov0" title="0">{
        if s.friendRepo == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">friends, err := s.friendRepo.GetFriends(context.Background(), userID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to load friends for presence event: %v", err)
                return
        }</span>
        <span class="cov0" title="0">user, err := s.userRepo.GetByID(context.Background(), userID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to load user for presence event: %v", err)
                return
        }</span>
        <span class="cov0" title="0">for _, friend := range friends </span><span class="cov0" title="0">{
                s.publishUserEvent(friend.ID, EventFriendPresenceChanged, map[string]interface{}{
                        "user_id":    user.ID,
                        "username":   user.Username,
                        "avatar":     user.Avatar,
                        "status":     status,
                        "updated_at": time.Now().UTC().Format(time.RFC3339Nano),
                })
        }</span>
}

func (s *Server) sendFriendsOnlineSnapshot(conn *websocket.Conn, userID uint) <span class="cov0" title="0">{
        if s.friendRepo == nil || s.hub == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">friends, err := s.friendRepo.GetFriends(context.Background(), userID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to load friends for online snapshot: %v", err)
                return
        }</span>
        <span class="cov0" title="0">onlineFriendIDs := make([]uint, 0, len(friends))
        for _, friend := range friends </span><span class="cov0" title="0">{
                if s.hub.IsOnline(friend.ID) </span><span class="cov0" title="0">{
                        onlineFriendIDs = append(onlineFriendIDs, friend.ID)
                }</span>
        }
        <span class="cov0" title="0">msg, err := json.Marshal(map[string]interface{}{
                "type": "friends_online_snapshot",
                "payload": map[string]interface{}{
                        "user_ids": onlineFriendIDs,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to marshal friends online snapshot: %v", err)
                return
        }</span>
        <span class="cov0" title="0">if err := conn.WriteMessage(websocket.TextMessage, msg); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to write friends online snapshot: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package server

import "github.com/gofiber/fiber/v2"

// GetFeatureFlags returns configured feature flags and evaluated state for current user.
func (s *Server) GetFeatureFlags(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID, _ := c.Locals("userID").(uint)

        if s.featureFlags == nil </span><span class="cov0" title="0">{
                return c.JSON(fiber.Map{
                        "raw":       map[string]string{},
                        "evaluated": map[string]bool{},
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(fiber.Map{
                "raw":       s.featureFlags.Raw(),
                "evaluated": s.featureFlags.Snapshot(userID),
        })</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package server contains HTTP and WebSocket handlers for the application's API endpoints.
package server

import (
        "time"

        "sanctum/internal/models"
        "sanctum/internal/service"

        "github.com/gofiber/fiber/v2"
)

// SendFriendRequest handles POST /api/friends/requests/:userId
func (s *Server) SendFriendRequest(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        targetUserID, err := s.parseID(c, "userId")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">friendship, err := s.friendSvc().SendFriendRequest(ctx, userID, targetUserID)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok </span><span class="cov0" title="0">{
                        switch appErr.Code </span>{
                        case "NOT_FOUND":<span class="cov0" title="0">
                                status = fiber.StatusNotFound</span>
                        case "VALIDATION_ERROR":<span class="cov0" title="0">
                                status = fiber.StatusConflict
                                if appErr.Message == "Cannot send friend request to yourself" </span><span class="cov0" title="0">{
                                        status = fiber.StatusBadRequest
                                }</span>
                        }
                }
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        // Notify both users so UI updates immediately.
        <span class="cov0" title="0">s.publishUserEvent(friendship.AddresseeID, EventFriendRequestReceived, map[string]interface{}{
                "request_id": friendship.ID,
                "from_user":  userSummary(friendship.Requester),
                "created_at": time.Now().UTC().Format(time.RFC3339Nano),
        })
        s.publishUserEvent(friendship.RequesterID, EventFriendRequestSent, map[string]interface{}{
                "request_id": friendship.ID,
                "to_user":    userSummary(friendship.Addressee),
                "created_at": time.Now().UTC().Format(time.RFC3339Nano),
        })

        return c.Status(fiber.StatusCreated).JSON(friendship)</span>
}

// GetPendingRequests handles GET /api/friends/requests
func (s *Server) GetPendingRequests(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)

        requests, err := s.friendSvc().GetPendingRequests(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(requests)</span>
}

// GetSentRequests handles GET /api/friends/requests/sent
func (s *Server) GetSentRequests(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)

        requests, err := s.friendSvc().GetSentRequests(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(requests)</span>
}

// AcceptFriendRequest handles POST /api/friends/requests/:requestId/accept
func (s *Server) AcceptFriendRequest(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        requestID, err := s.parseID(c, "requestId")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">friendship, err := s.friendSvc().AcceptFriendRequest(ctx, userID, requestID)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok </span><span class="cov0" title="0">{
                        switch appErr.Code </span>{
                        case "NOT_FOUND":<span class="cov0" title="0">
                                status = fiber.StatusNotFound</span>
                        case "UNAUTHORIZED":<span class="cov0" title="0">
                                status = fiber.StatusForbidden</span>
                        case "VALIDATION_ERROR":<span class="cov0" title="0">
                                status = fiber.StatusConflict</span>
                        }
                }
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">s.publishUserEvent(friendship.RequesterID, EventFriendRequestAccepted, map[string]interface{}{
                "request_id":  friendship.ID,
                "friend_user": userSummary(friendship.Addressee),
                "created_at":  time.Now().UTC().Format(time.RFC3339Nano),
        })
        s.publishUserEvent(friendship.AddresseeID, EventFriendAdded, map[string]interface{}{
                "request_id":  friendship.ID,
                "friend_user": userSummary(friendship.Requester),
                "created_at":  time.Now().UTC().Format(time.RFC3339Nano),
        })

        return c.JSON(friendship)</span>
}

// RejectFriendRequest handles POST /api/friends/requests/:requestId/reject
func (s *Server) RejectFriendRequest(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        requestID, err := s.parseID(c, "requestId")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">friendship, err := s.friendSvc().RejectFriendRequest(ctx, userID, requestID)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok </span><span class="cov0" title="0">{
                        switch appErr.Code </span>{
                        case "NOT_FOUND":<span class="cov0" title="0">
                                status = fiber.StatusNotFound</span>
                        case "UNAUTHORIZED":<span class="cov0" title="0">
                                status = fiber.StatusForbidden</span>
                        case "VALIDATION_ERROR":<span class="cov0" title="0">
                                status = fiber.StatusConflict</span>
                        }
                }
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">eventType := EventFriendRequestRejected
        if friendship.RequesterID == userID </span><span class="cov0" title="0">{
                eventType = EventFriendRequestCancelled
        }</span>
        <span class="cov0" title="0">s.publishUserEvent(friendship.RequesterID, eventType, map[string]interface{}{
                "request_id":  friendship.ID,
                "by_user_id":  userID,
                "rejected_at": time.Now().UTC().Format(time.RFC3339Nano),
        })
        s.publishUserEvent(friendship.AddresseeID, eventType, map[string]interface{}{
                "request_id":  friendship.ID,
                "by_user_id":  userID,
                "rejected_at": time.Now().UTC().Format(time.RFC3339Nano),
        })

        return c.SendStatus(fiber.StatusNoContent)</span>
}

// GetFriends handles GET /api/friends
func (s *Server) GetFriends(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)

        friends, err := s.friendSvc().GetFriends(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(friends)</span>
}

// GetFriendshipStatus handles GET /api/friends/status/:userId
func (s *Server) GetFriendshipStatus(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        targetUserID, err := s.parseID(c, "userId")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">status, requestID, friendship, err := s.friendSvc().GetFriendshipStatus(ctx, userID, targetUserID)
        if err != nil </span><span class="cov0" title="0">{
                httpStatus := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok &amp;&amp; appErr.Code == "NOT_FOUND" </span><span class="cov0" title="0">{
                        httpStatus = fiber.StatusNotFound
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, httpStatus, err)</span>
        }

        <span class="cov0" title="0">return c.JSON(fiber.Map{
                "status":     status,
                "request_id": requestID,
                "friendship": friendship,
        })</span>
}

// RemoveFriend handles DELETE /api/friends/:userId
func (s *Server) RemoveFriend(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        targetUserID, err := s.parseID(c, "userId")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">_, err = s.friendSvc().RemoveFriend(ctx, userID, targetUserID)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok &amp;&amp; appErr.Code == "NOT_FOUND" </span><span class="cov0" title="0">{
                        status = fiber.StatusNotFound
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">s.publishUserEvent(userID, EventFriendRemoved, map[string]interface{}{
                "user_id":    targetUserID,
                "removed_at": time.Now().UTC().Format(time.RFC3339Nano),
        })
        s.publishUserEvent(targetUserID, EventFriendRemoved, map[string]interface{}{
                "user_id":    userID,
                "removed_at": time.Now().UTC().Format(time.RFC3339Nano),
        })

        return c.SendStatus(fiber.StatusOK)</span>
}

func (s *Server) friendSvc() *service.FriendService <span class="cov0" title="0">{
        return service.NewFriendService(s.friendRepo, s.userRepo)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package server

import (
        "context"
        "encoding/json"
        "log"
        "strconv"
        "time"

        "sanctum/internal/middleware"
        "sanctum/internal/models"
        "sanctum/internal/notifications"
        "sanctum/internal/service"

        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/websocket/v2"
)

const pendingRoomMaxIdle = 10 * time.Minute

func isPendingRoomStale(room models.GameRoom, now time.Time) bool <span class="cov10" title="3">{
        if room.Status != models.GamePending </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov6" title="2">return now.Sub(room.UpdatedAt) &gt; pendingRoomMaxIdle</span>
}

// CreateGameRoom handles the creation of a new game room
func (s *Server) CreateGameRoom(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)

        var req struct {
                Type models.GameType `json:"type"`
        }
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest, models.NewValidationError("Invalid request body"))
        }</span>

        <span class="cov0" title="0">room, created, err := s.gameSvc().CreateGameRoom(ctx, userID, req.Type)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>
        <span class="cov0" title="0">if !created </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusOK).JSON(room)
        }</span>
        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(room)</span>
}

// GetActiveGameRooms returns pending rooms for a game type
func (s *Server) GetActiveGameRooms(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        gameType := c.Query("type")

        var requestedType *models.GameType
        if gameType != "" </span><span class="cov0" title="0">{
                gt := models.GameType(gameType)
                requestedType = &amp;gt
        }</span>

        <span class="cov0" title="0">rooms, err := s.gameSvc().GetActiveGameRooms(ctx, requestedType)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>
        <span class="cov0" title="0">return c.JSON(rooms)</span>
}

// GetGameStats fetches stats for a user and game type
func (s *Server) GetGameStats(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        gameType := models.GameType(c.Params("type"))

        stats, err := s.gameSvc().GetGameStats(ctx, userID, gameType)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(stats)</span>
}

// GetGameRoom fetches a specific game room
func (s *Server) GetGameRoom(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        roomID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">room, err := s.gameSvc().GetGameRoom(ctx, roomID)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok &amp;&amp; appErr.Code == "NOT_FOUND" </span><span class="cov0" title="0">{
                        status = fiber.StatusNotFound
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">return c.JSON(room)</span>
}

// LeaveGameRoom explicitly leaves/cancels a room for the current user.
func (s *Server) LeaveGameRoom(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        roomID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">room, alreadyClosed, err := s.gameSvc().LeaveGameRoom(ctx, userID, roomID)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok </span><span class="cov0" title="0">{
                        switch appErr.Code </span>{
                        case "NOT_FOUND":<span class="cov0" title="0">
                                status = fiber.StatusNotFound</span>
                        case "FORBIDDEN":<span class="cov0" title="0">
                                status = fiber.StatusForbidden</span>
                        }
                }
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">if !alreadyClosed &amp;&amp; room.Status == models.GameCancelled &amp;&amp; s.notifier != nil </span><span class="cov0" title="0">{
                _ = s.notifier.PublishGameAction(context.Background(), room.ID, `{"type":"game_cancelled","payload":{"message":"A player left the room"}}`)
        }</span>
        <span class="cov0" title="0">message := "Room closed"
        if alreadyClosed </span><span class="cov0" title="0">{
                message = "Room already closed"
        }</span>
        <span class="cov0" title="0">return c.JSON(fiber.Map{"message": message, "status": room.Status})</span>
}

// WebSocketGameHandler handles real-time game coordination
func (s *Server) WebSocketGameHandler() fiber.Handler <span class="cov0" title="0">{
        return websocket.New(func(c *websocket.Conn) </span><span class="cov0" title="0">{
                middleware.ActiveWebSockets.Inc()
                defer middleware.ActiveWebSockets.Dec()

                userIDVal := c.Locals("userID")
                if userIDVal == nil </span><span class="cov0" title="0">{
                        log.Println("GameWS: No userID in locals")
                        _ = c.Close()
                        return
                }</span>
                <span class="cov0" title="0">userID := userIDVal.(uint)

                roomIDStr := c.Query("room_id")
                if roomIDStr == "" </span><span class="cov0" title="0">{
                        log.Println("GameWS: No room_id in query")
                        _ = c.Close()
                        return
                }</span>
                <span class="cov0" title="0">roomID64, _ := strconv.ParseUint(roomIDStr, 10, 32)
                roomID := uint(roomID64)

                // Create a Client for serialized writes and hub registration
                client := notifications.NewClient(s.gameHub, c, userID)

                // Register connection with GameHub
                s.gameHub.RegisterClient(roomID, client)
                defer func() </span><span class="cov0" title="0">{
                        s.gameHub.UnregisterClient(client)
                        _ = c.Close()
                }</span>()

                // Set incoming handler for game actions
                <span class="cov0" title="0">client.IncomingHandler = func(_ *notifications.Client, msg []byte) </span><span class="cov0" title="0">{
                        var action notifications.GameAction
                        if err := json.Unmarshal(msg, &amp;action); err != nil </span><span class="cov0" title="0">{
                                log.Printf("GameWS: Failed to unmarshal action: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">action.UserID = userID
                        action.RoomID = roomID

                        // Handle the action through the hub
                        s.gameHub.HandleAction(userID, action)</span>
                }

                // Launch write pump for serialized writes
                <span class="cov0" title="0">go client.WritePump()

                // Read pump (blocks until disconnect)
                client.ReadPump()</span>
        })
}

func (s *Server) gameSvc() *service.GameService <span class="cov0" title="0">{
        return service.NewGameService(s.gameRepo)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">// Package server contains HTTP and WebSocket handlers for the application's API endpoints.
package server

import (
        "context"
        "errors"
        "strings"
        "unicode"

        "sanctum/internal/models"

        "github.com/gofiber/fiber/v2"
)

// errResponseWritten is a sentinel indicating the HTTP response was already
// committed by a helper.  Handlers must return nil (not this error) to avoid
// Fiber's ErrorHandler overwriting the response.
var errResponseWritten = errors.New("response already written")

// Pagination holds parsed limit/offset query parameters.
type Pagination struct {
        Limit  int
        Offset int
}

// parsePagination extracts limit and offset query parameters with the given default limit.
func parsePagination(c *fiber.Ctx, defaultLimit int) Pagination <span class="cov2" title="2">{
        return Pagination{
                Limit:  c.QueryInt("limit", defaultLimit),
                Offset: c.QueryInt("offset", 0),
        }
}</span>

// parseID extracts a route parameter by name as a positive uint.
// On failure it writes a 400 JSON response and returns errResponseWritten.
// Callers should check: if err != nil { return nil }
// The error message is derived from the parameter name (e.g. "id" -&gt; "Invalid ID",
// "userId" -&gt; "Invalid user ID", "commentId" -&gt; "Invalid comment ID").
func (s *Server) parseID(c *fiber.Ctx, param string) (uint, error) <span class="cov7" title="13">{
        id, err := c.ParamsInt(param)
        if err != nil || id &lt; 0 </span><span class="cov4" title="5">{
                _ = models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid "+humanizeParam(param)))
                return 0, errResponseWritten
        }</span>
        <span class="cov5" title="8">return uint(id), nil</span>
}

// humanizeParam converts a route param name into a human-readable label.
// Examples: "id" -&gt; "ID", "userId" -&gt; "user ID", "commentId" -&gt; "comment ID".
func humanizeParam(param string) string <span class="cov6" title="12">{
        if param == "id" </span><span class="cov4" title="4">{
                return "ID"
        }</span>
        // Split on camelCase boundary before the trailing "Id" suffix.
        <span class="cov5" title="8">if strings.HasSuffix(param, "Id") </span><span class="cov5" title="7">{
                prefix := param[:len(param)-2]
                // Split camelCase prefix into words.
                words := splitCamel(prefix)
                return strings.ToLower(strings.Join(words, " ")) + " ID"
        }</span>
        <span class="cov1" title="1">return param</span>
}

// splitCamel splits a camelCase string into words.
func splitCamel(s string) []string <span class="cov5" title="7">{
        var words []string
        start := 0
        for i, r := range s </span><span class="cov10" title="44">{
                if i &gt; 0 &amp;&amp; unicode.IsUpper(r) </span><span class="cov0" title="0">{
                        words = append(words, s[start:i])
                        start = i
                }</span>
        }
        <span class="cov5" title="7">words = append(words, s[start:])
        return words</span>
}

// isAdmin checks whether the given user has admin privileges.
func (s *Server) isAdmin(c *fiber.Ctx, userID uint) (bool, error) <span class="cov4" title="5">{
        return s.isAdminByUserID(c.Context(), userID)
}</span>

func (s *Server) isAdminByUserID(ctx context.Context, userID uint) (bool, error) <span class="cov4" title="5">{
        var user models.User
        if err := s.db.WithContext(ctx).Select("is_admin").First(&amp;user, userID).Error; err != nil </span><span class="cov1" title="1">{
                return false, err
        }</span>
        <span class="cov4" title="4">return user.IsAdmin, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Package server contains HTTP and WebSocket handlers for the application's API endpoints.
package server

import (
        "strconv"
        "time"

        "sanctum/internal/models"
        "sanctum/internal/service"

        "github.com/gofiber/fiber/v2"
)

// SearchPosts handles GET /api/posts/search?q=...
func (s *Server) SearchPosts(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        q := c.Query("q")
        page := parsePagination(c, 10)
        userID, _ := s.optionalUserID(c)

        posts, err := s.postSvc().SearchPosts(ctx, q, page.Limit, page.Offset, userID)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok &amp;&amp; appErr.Code == "VALIDATION_ERROR" </span><span class="cov0" title="0">{
                        status = fiber.StatusBadRequest
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">return c.JSON(posts)</span>
}

// CreatePost handles POST /api/posts
func (s *Server) CreatePost(c *fiber.Ctx) error <span class="cov10" title="2">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)

        var req struct {
                Title     string `json:"title"`
                Content   string `json:"content"`
                ImageURL  string `json:"image_url,omitempty"`
                SanctumID *uint  `json:"sanctum_id,omitempty"`
        }
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        <span class="cov10" title="2">post, err := s.postSvc().CreatePost(ctx, service.CreatePostInput{
                UserID:    userID,
                Title:     req.Title,
                Content:   req.Content,
                ImageURL:  req.ImageURL,
                SanctumID: req.SanctumID,
        })
        if err != nil </span><span class="cov1" title="1">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok &amp;&amp; appErr.Code == "VALIDATION_ERROR" </span><span class="cov1" title="1">{
                        status = fiber.StatusBadRequest
                }</span>
                <span class="cov1" title="1">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov1" title="1">s.publishBroadcastEvent(EventPostCreated, map[string]interface{}{
                "post_id":    post.ID,
                "author_id":  post.UserID,
                "created_at": time.Now().UTC().Format(time.RFC3339Nano),
        })

        return c.Status(fiber.StatusCreated).JSON(post)</span>
}

// GetPosts handles GET /api/posts
func (s *Server) GetPosts(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        page := parsePagination(c, 20)
        userID, _ := s.optionalUserID(c)

        var sanctumID *uint
        sanctumIDStr := c.Query("sanctum_id")
        if sanctumIDStr != "" </span><span class="cov0" title="0">{
                parsed, err := strconv.ParseUint(sanctumIDStr, 10, 32)
                if err == nil </span><span class="cov0" title="0">{
                        id := uint(parsed)
                        sanctumID = &amp;id
                }</span>
        }

        <span class="cov0" title="0">posts, err := s.postSvc().ListPosts(ctx, service.ListPostsInput{
                Limit:         page.Limit,
                Offset:        page.Offset,
                CurrentUserID: userID,
                SanctumID:     sanctumID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(posts)</span>
}

// GetPost handles GET /api/posts/:id
func (s *Server) GetPost(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        id, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">userID, _ := s.optionalUserID(c)

        post, err := s.postSvc().GetPost(ctx, id, userID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusNotFound, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(post)</span>
}

// GetUserPosts handles GET /api/users/:id/posts
func (s *Server) GetUserPosts(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userIDParam, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">page := parsePagination(c, 20)
        currentUserID, _ := s.optionalUserID(c)

        posts, err := s.postSvc().GetUserPosts(ctx, userIDParam, page.Limit, page.Offset, currentUserID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(posts)</span>
}

// UpdatePost handles PUT /api/posts/:id
func (s *Server) UpdatePost(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        postID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var req struct {
                Title    string `json:"title"`
                Content  string `json:"content"`
                ImageURL string `json:"image_url,omitempty"`
        }
        parseErr := c.BodyParser(&amp;req)
        if parseErr != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        <span class="cov0" title="0">post, err := s.postSvc().UpdatePost(ctx, service.UpdatePostInput{
                UserID:   userID,
                PostID:   postID,
                Title:    req.Title,
                Content:  req.Content,
                ImageURL: req.ImageURL,
        })
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok </span><span class="cov0" title="0">{
                        switch appErr.Code </span>{
                        case "UNAUTHORIZED":<span class="cov0" title="0">
                                status = fiber.StatusForbidden</span>
                        case "NOT_FOUND":<span class="cov0" title="0">
                                status = fiber.StatusNotFound</span>
                        }
                }
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">return c.JSON(post)</span>
}

// DeletePost handles DELETE /api/posts/:id
func (s *Server) DeletePost(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        postID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := s.postSvc().DeletePost(ctx, service.DeletePostInput{
                UserID: userID,
                PostID: postID,
        }); err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok </span><span class="cov0" title="0">{
                        switch appErr.Code </span>{
                        case "UNAUTHORIZED":<span class="cov0" title="0">
                                status = fiber.StatusForbidden</span>
                        case "NOT_FOUND":<span class="cov0" title="0">
                                status = fiber.StatusNotFound</span>
                        }
                }
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// LikePost handles POST /api/posts/:id/like
// This endpoint toggles the like status - if already liked, it unlikes; if not liked, it likes
func (s *Server) LikePost(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        postID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">post, err := s.postSvc().ToggleLike(ctx, userID, postID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">s.publishBroadcastEvent(EventPostReactionUpdated, map[string]interface{}{
                "post_id":        post.ID,
                "likes_count":    post.LikesCount,
                "comments_count": post.CommentsCount,
                "updated_at":     time.Now().UTC().Format(time.RFC3339Nano),
        })

        return c.JSON(post)</span>
}

// UnlikePost handles DELETE /api/posts/:id/like
func (s *Server) UnlikePost(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        userID := c.Locals("userID").(uint)
        postID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">post, err := s.postSvc().UnlikePost(ctx, userID, postID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">s.publishBroadcastEvent(EventPostReactionUpdated, map[string]interface{}{
                "post_id":        post.ID,
                "likes_count":    post.LikesCount,
                "comments_count": post.CommentsCount,
                "updated_at":     time.Now().UTC().Format(time.RFC3339Nano),
        })

        return c.JSON(post)</span>
}

func (s *Server) postSvc() *service.PostService <span class="cov10" title="2">{
        if s.postService == nil </span><span class="cov1" title="1">{
                s.postService = service.NewPostService(s.postRepo, s.isAdminByUserID)
        }</span>
        <span class="cov10" title="2">return s.postService</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package server

import (
        "context"
        "encoding/json"
        "log"

        "sanctum/internal/models"
)

// Event type constants prevent typos in event names.
const (
        EventPostCreated            = "post_created"
        EventPostReactionUpdated    = "post_reaction_updated"
        EventCommentCreated         = "comment_created"
        EventCommentUpdated         = "comment_updated"
        EventCommentDeleted         = "comment_deleted"
        EventMessageReceived        = "message_received"
        EventFriendRequestReceived  = "friend_request_received"
        EventFriendRequestSent      = "friend_request_sent"
        EventFriendRequestAccepted  = "friend_request_accepted"
        EventFriendAdded            = "friend_added"
        EventFriendRequestRejected  = "friend_request_rejected"
        EventFriendRequestCancelled = "friend_request_cancelled"
        EventFriendRemoved          = "friend_removed"
        EventFriendPresenceChanged  = "friend_presence_changed"
        EventSanctumRequestCreated  = "sanctum_request_created"
        EventSanctumRequestReviewed = "sanctum_request_reviewed"
)

func (s *Server) publishAdminEvent(eventType string, payload map[string]interface{}) <span class="cov0" title="0">{
        // Find all admin IDs
        var adminIDs []uint
        if err := s.db.Model(&amp;models.User{}).Where("is_admin = ?", true).Pluck("id", &amp;adminIDs).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to fetch admin IDs for %s event: %v", eventType, err)
                return
        }</span>

        <span class="cov0" title="0">for _, adminID := range adminIDs </span><span class="cov0" title="0">{
                s.publishUserEvent(adminID, eventType, payload)
        }</span>
}

func (s *Server) publishUserEvent(userID uint, eventType string, payload map[string]interface{}) <span class="cov0" title="0">{
        event := map[string]interface{}{
                "type":    eventType,
                "payload": payload,
        }
        eventJSON, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to marshal %s event: %v", eventType, err)
                return
        }</span>
        <span class="cov0" title="0">message := string(eventJSON)
        if s.hub != nil </span><span class="cov0" title="0">{
                s.hub.Broadcast(userID, message)
        }</span>
        <span class="cov0" title="0">if s.notifier != nil </span><span class="cov0" title="0">{
                if err := s.notifier.PublishUser(context.Background(), userID, message); err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to publish %s event to user %d: %v", eventType, userID, err)
                }</span>
        }
}

func (s *Server) publishBroadcastEvent(eventType string, payload map[string]interface{}) <span class="cov10" title="2">{
        event := map[string]interface{}{
                "type":    eventType,
                "payload": payload,
        }
        eventJSON, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to marshal %s event: %v", eventType, err)
                return
        }</span>
        <span class="cov10" title="2">message := string(eventJSON)
        if s.hub != nil </span><span class="cov0" title="0">{
                s.hub.BroadcastAll(message)
        }</span>
        <span class="cov10" title="2">if s.notifier != nil </span><span class="cov0" title="0">{
                if err := s.notifier.PublishBroadcast(context.Background(), message); err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to publish %s broadcast event: %v", eventType, err)
                }</span>
        }
}

func userSummary(user models.User) map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "id":       user.ID,
                "username": user.Username,
                "avatar":   user.Avatar,
        }
}</span>

func userSummaryPtr(user *models.User) map[string]interface{} <span class="cov0" title="0">{
        if user == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return userSummary(*user)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package server

import (
        "errors"
        "strings"
        "time"

        "sanctum/internal/models"
        "sanctum/internal/validation"

        "github.com/gofiber/fiber/v2"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

// SanctumDTO is the API response model for sanctum endpoints.
type SanctumDTO struct {
        ID                uint                 `json:"id"`
        Name              string               `json:"name"`
        Slug              string               `json:"slug"`
        Description       string               `json:"description"`
        CreatedByUserID   *uint                `json:"created_by_user_id"`
        Status            models.SanctumStatus `json:"status"`
        CreatedAt         string               `json:"created_at"`
        UpdatedAt         string               `json:"updated_at"`
        DefaultChatRoomID *uint                `json:"default_chat_room_id"`
}

// SanctumMembershipDTO is the API response model for sanctum memberships.
type SanctumMembershipDTO struct {
        SanctumID uint                         `json:"sanctum_id"`
        UserID    uint                         `json:"user_id"`
        Role      models.SanctumMembershipRole `json:"role"`
        CreatedAt string                       `json:"created_at"`
        UpdatedAt string                       `json:"updated_at"`
        Sanctum   SanctumDTO                   `json:"sanctum"`
}

func toSanctumDTO(s models.Sanctum, defaultRoomID *uint) SanctumDTO <span class="cov1" title="1">{
        return SanctumDTO{
                ID:                s.ID,
                Name:              s.Name,
                Slug:              s.Slug,
                Description:       s.Description,
                CreatedByUserID:   s.CreatedByUserID,
                Status:            s.Status,
                CreatedAt:         s.CreatedAt.UTC().Format("2006-01-02T15:04:05.999999999Z07:00"),
                UpdatedAt:         s.UpdatedAt.UTC().Format("2006-01-02T15:04:05.999999999Z07:00"),
                DefaultChatRoomID: defaultRoomID,
        }
}</span>

func toSanctumMembershipDTO(m models.SanctumMembership, sanctum models.Sanctum, defaultRoomID *uint) SanctumMembershipDTO <span class="cov0" title="0">{
        return SanctumMembershipDTO{
                SanctumID: m.SanctumID,
                UserID:    m.UserID,
                Role:      m.Role,
                CreatedAt: m.CreatedAt.UTC().Format("2006-01-02T15:04:05.999999999Z07:00"),
                UpdatedAt: m.UpdatedAt.UTC().Format("2006-01-02T15:04:05.999999999Z07:00"),
                Sanctum:   toSanctumDTO(sanctum, defaultRoomID),
        }
}</span>

// GetSanctums handles GET /api/sanctums
// @Summary List sanctums
// @Description List active sanctums.
// @Tags sanctums
// @Produce json
// @Success 200 {array} SanctumDTO
// @Router /sanctums [get]
func (s *Server) GetSanctums(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.Context()

        var sanctums []models.Sanctum
        if err := s.db.WithContext(ctx).
                Where("status = ?", models.SanctumStatusActive).
                Order("name ASC").
                Find(&amp;sanctums).Error; err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">ids := make([]uint, 0, len(sanctums))
        for _, sanctum := range sanctums </span><span class="cov0" title="0">{
                ids = append(ids, sanctum.ID)
        }</span>

        <span class="cov0" title="0">roomBySanctumID := map[uint]uint{}
        if len(ids) &gt; 0 </span><span class="cov0" title="0">{
                var rooms []models.Conversation
                if err := s.db.WithContext(ctx).
                        Select("id", "sanctum_id").
                        Where("sanctum_id IN ?", ids).
                        Find(&amp;rooms).Error; err != nil </span><span class="cov0" title="0">{
                        return models.RespondWithError(c, fiber.StatusInternalServerError, err)
                }</span>
                <span class="cov0" title="0">for _, room := range rooms </span><span class="cov0" title="0">{
                        if room.SanctumID != nil </span><span class="cov0" title="0">{
                                roomBySanctumID[*room.SanctumID] = room.ID
                        }</span>
                }
        }

        <span class="cov0" title="0">resp := make([]SanctumDTO, 0, len(sanctums))
        for _, sanctum := range sanctums </span><span class="cov0" title="0">{
                var roomID *uint
                if id, ok := roomBySanctumID[sanctum.ID]; ok </span><span class="cov0" title="0">{
                        roomID = &amp;id
                }</span>
                <span class="cov0" title="0">resp = append(resp, toSanctumDTO(sanctum, roomID))</span>
        }

        <span class="cov0" title="0">return c.JSON(resp)</span>
}

// GetSanctumBySlug handles GET /api/sanctums/:slug
// @Summary Get sanctum by slug
// @Description Fetch active sanctum detail by slug.
// @Tags sanctums
// @Produce json
// @Param slug path string true "Sanctum slug"
// @Success 200 {object} SanctumDTO
// @Failure 404 {object} models.ErrorResponse
// @Router /sanctums/{slug} [get]
func (s *Server) GetSanctumBySlug(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.Context()
        slug := strings.TrimSpace(c.Params("slug"))
        if slug == "" </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("slug is required"))
        }</span>

        <span class="cov0" title="0">var sanctum models.Sanctum
        if err := s.db.WithContext(ctx).
                Where("slug = ? AND status = ?", slug, models.SanctumStatusActive).
                First(&amp;sanctum).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return models.RespondWithError(c, fiber.StatusNotFound,
                                models.NewNotFoundError("Sanctum", slug))
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, fiber.StatusInternalServerError, err)</span>
        }

        <span class="cov0" title="0">var room models.Conversation
        var roomID *uint
        if err := s.db.WithContext(ctx).Select("id").Where("sanctum_id = ?", sanctum.ID).First(&amp;room).Error; err == nil </span><span class="cov0" title="0">{
                roomID = &amp;room.ID
        }</span> else<span class="cov0" title="0"> if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(toSanctumDTO(sanctum, roomID))</span>
}

// CreateSanctumRequest handles POST /api/sanctums/requests
// @Summary Create sanctum request
// @Description Submit a request for a new sanctum.
// @Tags sanctums
// @Accept json
// @Produce json
// @Param request body object{requested_name=string,requested_slug=string,reason=string} true "Sanctum request"
// @Success 201 {object} models.SanctumRequest
// @Failure 400 {object} models.ErrorResponse
// @Failure 409 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /sanctums/requests [post]
func (s *Server) CreateSanctumRequest(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.Context()
        userID := c.Locals("userID").(uint)

        var req struct {
                RequestedName string `json:"requested_name"`
                RequestedSlug string `json:"requested_slug"`
                Reason        string `json:"reason"`
        }
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        <span class="cov0" title="0">req.RequestedName = strings.TrimSpace(req.RequestedName)
        req.RequestedSlug = strings.TrimSpace(req.RequestedSlug)
        req.Reason = strings.TrimSpace(req.Reason)

        if req.RequestedName == "" || req.Reason == "" </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("requested_name, requested_slug, and reason are required"))
        }</span>
        <span class="cov0" title="0">if err := validation.ValidateSanctumSlug(req.RequestedSlug); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest, models.NewValidationError(err.Error()))
        }</span>

        <span class="cov0" title="0">var existingCount int64
        if err := s.db.WithContext(ctx).Model(&amp;models.Sanctum{}).Where("slug = ?", req.RequestedSlug).Count(&amp;existingCount).Error; err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>
        <span class="cov0" title="0">if existingCount &gt; 0 </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusConflict,
                        models.NewValidationError("slug is already in use"))
        }</span>

        <span class="cov0" title="0">var pendingCount int64
        if err := s.db.WithContext(ctx).Model(&amp;models.SanctumRequest{}).
                Where("requested_slug = ? AND status = ?", req.RequestedSlug, models.SanctumRequestStatusPending).
                Count(&amp;pendingCount).Error; err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>
        <span class="cov0" title="0">if pendingCount &gt; 0 </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusConflict,
                        models.NewValidationError("a pending request already exists for this slug"))
        }</span>

        <span class="cov0" title="0">create := models.SanctumRequest{
                RequestedName:     req.RequestedName,
                RequestedSlug:     req.RequestedSlug,
                Reason:            req.Reason,
                RequestedByUserID: userID,
                Status:            models.SanctumRequestStatusPending,
        }
        if err := s.db.WithContext(ctx).Create(&amp;create).Error; err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">s.publishAdminEvent(EventSanctumRequestCreated, map[string]interface{}{
                "id":                create.ID,
                "requested_name":    create.RequestedName,
                "requested_slug":    create.RequestedSlug,
                "requested_by_user": create.RequestedByUserID,
                "status":            create.Status,
                "created_at":        create.CreatedAt.Format(time.RFC3339Nano),
        })

        return c.Status(fiber.StatusCreated).JSON(create)</span>
}

// GetMySanctumRequests handles GET /api/sanctums/requests/me
// @Summary Get my sanctum requests
// @Description List sanctum requests submitted by the current user.
// @Tags sanctums
// @Produce json
// @Success 200 {array} models.SanctumRequest
// @Security BearerAuth
// @Router /sanctums/requests/me [get]
func (s *Server) GetMySanctumRequests(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.Context()
        userID := c.Locals("userID").(uint)

        var requests []models.SanctumRequest
        if err := s.db.WithContext(ctx).
                Preload("ReviewedByUser").
                Where("requested_by_user_id = ?", userID).
                Order("created_at DESC").
                Find(&amp;requests).Error; err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(requests)</span>
}

// GetMySanctumMemberships handles GET /api/sanctums/memberships/me
// @Summary Get my sanctum memberships
// @Description List sanctum memberships for the current user.
// @Tags sanctums
// @Produce json
// @Success 200 {array} SanctumMembershipDTO
// @Security BearerAuth
// @Router /sanctums/memberships/me [get]
func (s *Server) GetMySanctumMemberships(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.Context()
        userID := c.Locals("userID").(uint)

        var memberships []models.SanctumMembership
        if err := s.db.WithContext(ctx).
                Preload("Sanctum").
                Where("user_id = ?", userID).
                Order("created_at ASC").
                Find(&amp;memberships).Error; err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">sanctumIDs := make([]uint, 0, len(memberships))
        sanctumsByID := make(map[uint]models.Sanctum, len(memberships))
        for _, membership := range memberships </span><span class="cov0" title="0">{
                if membership.Sanctum != nil </span><span class="cov0" title="0">{
                        sanctumIDs = append(sanctumIDs, membership.SanctumID)
                        sanctumsByID[membership.SanctumID] = *membership.Sanctum
                }</span>
        }

        <span class="cov0" title="0">roomBySanctumID := map[uint]uint{}
        if len(sanctumIDs) &gt; 0 </span><span class="cov0" title="0">{
                var rooms []models.Conversation
                if err := s.db.WithContext(ctx).
                        Select("id", "sanctum_id").
                        Where("sanctum_id IN ?", sanctumIDs).
                        Find(&amp;rooms).Error; err != nil </span><span class="cov0" title="0">{
                        return models.RespondWithError(c, fiber.StatusInternalServerError, err)
                }</span>
                <span class="cov0" title="0">for _, room := range rooms </span><span class="cov0" title="0">{
                        if room.SanctumID != nil </span><span class="cov0" title="0">{
                                roomBySanctumID[*room.SanctumID] = room.ID
                        }</span>
                }
        }

        <span class="cov0" title="0">resp := make([]SanctumMembershipDTO, 0, len(memberships))
        for _, membership := range memberships </span><span class="cov0" title="0">{
                sanctum, ok := sanctumsByID[membership.SanctumID]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var roomID *uint
                if id, found := roomBySanctumID[membership.SanctumID]; found </span><span class="cov0" title="0">{
                        roomID = &amp;id
                }</span>
                <span class="cov0" title="0">resp = append(resp, toSanctumMembershipDTO(membership, sanctum, roomID))</span>
        }

        <span class="cov0" title="0">return c.JSON(resp)</span>
}

// UpsertMySanctumMemberships handles POST /api/sanctums/memberships/bulk
// @Summary Save sanctums I follow
// @Description Upsert current user's followed sanctums by slug and keep owner/mod memberships intact.
// @Tags sanctums
// @Accept json
// @Produce json
// @Param request body object{sanctum_slugs=[]string} true "Sanctum follow list"
// @Success 200 {array} SanctumMembershipDTO
// @Failure 400 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /sanctums/memberships/bulk [post]
func (s *Server) UpsertMySanctumMemberships(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.Context()
        userID := c.Locals("userID").(uint)

        var body struct {
                SanctumSlugs []string `json:"sanctum_slugs"`
        }
        if err := c.BodyParser(&amp;body); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>
        <span class="cov0" title="0">if len(body.SanctumSlugs) == 0 </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("sanctum_slugs is required"))
        }</span>

        <span class="cov0" title="0">uniqueSlugs := make([]string, 0, len(body.SanctumSlugs))
        seen := make(map[string]struct{}, len(body.SanctumSlugs))
        for _, raw := range body.SanctumSlugs </span><span class="cov0" title="0">{
                slug := strings.TrimSpace(strings.ToLower(raw))
                if slug == "" </span><span class="cov0" title="0">{
                        return models.RespondWithError(c, fiber.StatusBadRequest,
                                models.NewValidationError("sanctum_slugs cannot contain empty values"))
                }</span>
                <span class="cov0" title="0">if _, ok := seen[slug]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">seen[slug] = struct{}{}
                uniqueSlugs = append(uniqueSlugs, slug)</span>
        }

        <span class="cov0" title="0">var sanctums []models.Sanctum
        if err := s.db.WithContext(ctx).
                Where("slug IN ? AND status = ?", uniqueSlugs, models.SanctumStatusActive).
                Find(&amp;sanctums).Error; err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>
        <span class="cov0" title="0">if len(sanctums) != len(uniqueSlugs) </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("one or more sanctum_slugs are invalid"))
        }</span>

        <span class="cov0" title="0">sanctumIDs := make([]uint, 0, len(sanctums))
        sanctumsByID := make(map[uint]models.Sanctum, len(sanctums))
        for _, sanctum := range sanctums </span><span class="cov0" title="0">{
                sanctumIDs = append(sanctumIDs, sanctum.ID)
                sanctumsByID[sanctum.ID] = sanctum
        }</span>

        <span class="cov0" title="0">err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                if err := tx.
                        Where("user_id = ? AND role = ? AND sanctum_id NOT IN ?", userID, models.SanctumMembershipRoleMember, sanctumIDs).
                        Delete(&amp;models.SanctumMembership{}).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for _, sanctumID := range sanctumIDs </span><span class="cov0" title="0">{
                        membership := models.SanctumMembership{
                                SanctumID: sanctumID,
                                UserID:    userID,
                                Role:      models.SanctumMembershipRoleMember,
                        }
                        if err := tx.Clauses(clause.OnConflict{
                                Columns:   []clause.Column{{Name: "sanctum_id"}, {Name: "user_id"}},
                                DoUpdates: clause.Assignments(map[string]any{"updated_at": gorm.Expr("NOW()")}),
                        }).Create(&amp;membership).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">var memberships []models.SanctumMembership
        if err := s.db.WithContext(ctx).
                Where("user_id = ? AND sanctum_id IN ?", userID, sanctumIDs).
                Order("created_at ASC").
                Find(&amp;memberships).Error; err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">roomBySanctumID := map[uint]uint{}
        var rooms []models.Conversation
        if err := s.db.WithContext(ctx).
                Select("id", "sanctum_id").
                Where("sanctum_id IN ?", sanctumIDs).
                Find(&amp;rooms).Error; err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>
        <span class="cov0" title="0">for _, room := range rooms </span><span class="cov0" title="0">{
                if room.SanctumID != nil </span><span class="cov0" title="0">{
                        roomBySanctumID[*room.SanctumID] = room.ID
                }</span>
        }

        <span class="cov0" title="0">resp := make([]SanctumMembershipDTO, 0, len(memberships))
        for _, membership := range memberships </span><span class="cov0" title="0">{
                sanctum, ok := sanctumsByID[membership.SanctumID]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var roomID *uint
                if id, found := roomBySanctumID[membership.SanctumID]; found </span><span class="cov0" title="0">{
                        roomID = &amp;id
                }</span>
                <span class="cov0" title="0">resp = append(resp, toSanctumMembershipDTO(membership, sanctum, roomID))</span>
        }

        <span class="cov0" title="0">return c.JSON(resp)</span>
}

// GetAdminSanctumRequests handles GET /api/admin/sanctum-requests
// @Summary List sanctum requests for admins
// @Description List sanctum requests by status. Defaults to pending.
// @Tags sanctums-admin
// @Produce json
// @Param status query string false "Filter status"
// @Success 200 {array} models.SanctumRequest
// @Security BearerAuth
// @Router /admin/sanctum-requests [get]
func (s *Server) GetAdminSanctumRequests(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.Context()
        status := strings.TrimSpace(c.Query("status", string(models.SanctumRequestStatusPending)))

        allowed := map[string]models.SanctumRequestStatus{
                string(models.SanctumRequestStatusPending):  models.SanctumRequestStatusPending,
                string(models.SanctumRequestStatusApproved): models.SanctumRequestStatusApproved,
                string(models.SanctumRequestStatusRejected): models.SanctumRequestStatusRejected,
        }
        statusEnum, ok := allowed[status]
        if !ok </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("status must be one of: pending, approved, rejected"))
        }</span>

        <span class="cov0" title="0">var requests []models.SanctumRequest
        if err := s.db.WithContext(ctx).
                Preload("RequestedByUser").
                Preload("ReviewedByUser").
                Where("status = ?", statusEnum).
                Order("created_at ASC").
                Find(&amp;requests).Error; err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(requests)</span>
}

// ApproveSanctumRequest handles POST /api/admin/sanctum-requests/:id/approve
// @Summary Approve sanctum request
// @Description Approve a pending sanctum request and create sanctum, owner membership, and default chat room.
// @Tags sanctums-admin
// @Accept json
// @Produce json
// @Param id path int true "Request ID"
// @Param request body object{review_notes=string} false "Optional review notes"
// @Success 200 {object} object{request=models.SanctumRequest,sanctum=SanctumDTO}
// @Failure 400 {object} models.ErrorResponse
// @Failure 404 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /admin/sanctum-requests/{id}/approve [post]
func (s *Server) ApproveSanctumRequest(c *fiber.Ctx) error <span class="cov10" title="4">{
        ctx := c.Context()
        reviewerID := c.Locals("userID").(uint)
        requestID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov10" title="4">var body struct {
                ReviewNotes string `json:"review_notes"`
        }
        if len(c.Body()) &gt; 0 </span><span class="cov1" title="1">{
                if err := c.BodyParser(&amp;body); err != nil </span><span class="cov0" title="0">{
                        return models.RespondWithError(c, fiber.StatusBadRequest,
                                models.NewValidationError("Invalid request body"))
                }</span>
        }

        <span class="cov10" title="4">var approvedRequest models.SanctumRequest
        var createdSanctum models.Sanctum
        var defaultRoom models.Conversation

        txErr := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov10" title="4">{
                if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).First(&amp;approvedRequest, requestID).Error; err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                                return models.NewNotFoundError("Sanctum request", requestID)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov10" title="4">if approvedRequest.Status != models.SanctumRequestStatusPending </span><span class="cov1" title="1">{
                        return models.NewValidationError("sanctum request is not pending")
                }</span>

                <span class="cov8" title="3">if err := validation.ValidateSanctumSlug(approvedRequest.RequestedSlug); err != nil </span><span class="cov1" title="1">{
                        return models.NewValidationError(err.Error())
                }</span>

                <span class="cov5" title="2">var existingCount int64
                if err := tx.Model(&amp;models.Sanctum{}).
                        Where("slug = ?", approvedRequest.RequestedSlug).
                        Count(&amp;existingCount).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov5" title="2">if existingCount &gt; 0 </span><span class="cov1" title="1">{
                        return models.NewValidationError("slug is already in use")
                }</span>

                <span class="cov1" title="1">createdSanctum = models.Sanctum{
                        Name:            approvedRequest.RequestedName,
                        Slug:            approvedRequest.RequestedSlug,
                        Description:     approvedRequest.Reason,
                        CreatedByUserID: &amp;approvedRequest.RequestedByUserID,
                        Status:          models.SanctumStatusActive,
                }
                if err := tx.Create(&amp;createdSanctum).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">membership := models.SanctumMembership{
                        SanctumID: createdSanctum.ID,
                        UserID:    approvedRequest.RequestedByUserID,
                        Role:      models.SanctumMembershipRoleOwner,
                }
                if err := tx.Create(&amp;membership).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">defaultRoom = models.Conversation{
                        Name:      createdSanctum.Name,
                        IsGroup:   true,
                        CreatedBy: approvedRequest.RequestedByUserID,
                        SanctumID: &amp;createdSanctum.ID,
                }
                if err := tx.Create(&amp;defaultRoom).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">approvedRequest.Status = models.SanctumRequestStatusApproved
                approvedRequest.ReviewedByUserID = &amp;reviewerID
                approvedRequest.ReviewNotes = strings.TrimSpace(body.ReviewNotes)
                if err := tx.Save(&amp;approvedRequest).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">return nil</span>
        })
        <span class="cov10" title="4">if txErr != nil </span><span class="cov8" title="3">{
                var appErr *models.AppError
                if errors.As(txErr, &amp;appErr) </span><span class="cov8" title="3">{
                        status := fiber.StatusBadRequest
                        if appErr.Code == "NOT_FOUND" </span><span class="cov0" title="0">{
                                status = fiber.StatusNotFound
                        }</span>
                        <span class="cov8" title="3">return models.RespondWithError(c, status, appErr)</span>
                }
                <span class="cov0" title="0">return models.RespondWithError(c, fiber.StatusInternalServerError, txErr)</span>
        }

        <span class="cov1" title="1">roomID := defaultRoom.ID
        resp := fiber.Map{
                "request": approvedRequest,
                "sanctum": toSanctumDTO(createdSanctum, &amp;roomID),
        }

        s.publishBroadcastEvent(EventSanctumRequestReviewed, map[string]interface{}{
                "id":         approvedRequest.ID,
                "status":     approvedRequest.Status,
                "updated_at": approvedRequest.UpdatedAt.Format(time.RFC3339Nano),
        })

        return c.JSON(resp)</span>
}

// RejectSanctumRequest handles POST /api/admin/sanctum-requests/:id/reject
// @Summary Reject sanctum request
// @Description Reject a pending sanctum request.
// @Tags sanctums-admin
// @Accept json
// @Produce json
// @Param id path int true "Request ID"
// @Param request body object{review_notes=string} false "Optional review notes"
// @Success 200 {object} models.SanctumRequest
// @Failure 400 {object} models.ErrorResponse
// @Failure 404 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /admin/sanctum-requests/{id}/reject [post]
func (s *Server) RejectSanctumRequest(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.Context()
        reviewerID := c.Locals("userID").(uint)
        requestID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var body struct {
                ReviewNotes string `json:"review_notes"`
        }
        if len(c.Body()) &gt; 0 </span><span class="cov0" title="0">{
                if err := c.BodyParser(&amp;body); err != nil </span><span class="cov0" title="0">{
                        return models.RespondWithError(c, fiber.StatusBadRequest,
                                models.NewValidationError("Invalid request body"))
                }</span>
        }

        <span class="cov0" title="0">var request models.SanctumRequest
        if err := s.db.WithContext(ctx).First(&amp;request, requestID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return models.RespondWithError(c, fiber.StatusNotFound,
                                models.NewNotFoundError("Sanctum request", requestID))
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, fiber.StatusInternalServerError, err)</span>
        }

        <span class="cov0" title="0">if request.Status != models.SanctumRequestStatusPending </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("sanctum request is not pending"))
        }</span>

        <span class="cov0" title="0">request.Status = models.SanctumRequestStatusRejected
        request.ReviewedByUserID = &amp;reviewerID
        request.ReviewNotes = strings.TrimSpace(body.ReviewNotes)
        if err := s.db.WithContext(ctx).Save(&amp;request).Error; err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">s.publishBroadcastEvent(EventSanctumRequestReviewed, map[string]interface{}{
                "id":         request.ID,
                "status":     request.Status,
                "updated_at": request.UpdatedAt.Format(time.RFC3339Nano),
        })

        return c.JSON(request)</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Package server contains HTTP and WebSocket handlers for the application's API endpoints.
package server

import (
        "context"
        "fmt"
        "log"
        "strconv"
        "strings"
        "time"

        _ "sanctum/docs" // swagger docs
        "sanctum/internal/cache"
        "sanctum/internal/config"
        "sanctum/internal/database"
        "sanctum/internal/featureflags"
        "sanctum/internal/middleware"
        "sanctum/internal/models"
        "sanctum/internal/notifications"
        "sanctum/internal/repository"
        "sanctum/internal/seed"
        "sanctum/internal/service"

        "github.com/ansrivas/fiberprometheus/v2"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"
        "github.com/gofiber/fiber/v2/middleware/helmet"
        "github.com/gofiber/fiber/v2/middleware/limiter"
        "github.com/gofiber/fiber/v2/middleware/monitor"
        "github.com/gofiber/fiber/v2/middleware/recover"
        "github.com/gofiber/fiber/v2/middleware/requestid"
        "github.com/gofiber/swagger"
        "github.com/golang-jwt/jwt/v5"
        "github.com/redis/go-redis/v9"
        "gorm.io/gorm"
)

// wireableHub is implemented by every WebSocket hub that can be wired to
// Redis pub/sub and gracefully shut down.
type wireableHub interface {
        Name() string
        StartWiring(ctx context.Context, n *notifications.Notifier) error
        Shutdown(ctx context.Context) error
}

// Server holds all dependencies and provides handlers
type Server struct {
        config         *config.Config
        db             *gorm.DB
        redis          *redis.Client
        app            *fiber.App
        promMiddleware *fiberprometheus.FiberPrometheus
        shutdownCtx    context.Context
        shutdownFn     context.CancelFunc
        userRepo       repository.UserRepository
        postRepo       repository.PostRepository
        commentRepo    repository.CommentRepository
        chatRepo       repository.ChatRepository
        friendRepo     repository.FriendRepository
        gameRepo       repository.GameRepository
        streamRepo     repository.StreamRepository
        notifier       *notifications.Notifier
        hub            *notifications.Hub
        chatHub        *notifications.ChatHub
        gameHub        *notifications.GameHub
        videoChatHub   *notifications.VideoChatHub
        hubs           []wireableHub // all hubs for wiring/shutdown iteration
        featureFlags   *featureflags.Manager
        postService    *service.PostService
        commentService *service.CommentService
        chatService    *service.ChatService
        userService    *service.UserService
}

// NewServer creates a new server instance with all dependencies
func NewServer(cfg *config.Config) (*Server, error) <span class="cov0" title="0">{
        // Initialize database
        db, err := database.Connect(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database connection failed: %w", err)
        }</span>

        // Initialize Redis
        <span class="cov0" title="0">cache.InitRedis(cfg.RedisURL)
        redisClient := cache.GetClient()

        // Initialize repositories
        userRepo := repository.NewUserRepository(db)
        postRepo := repository.NewPostRepository(db)
        commentRepo := repository.NewCommentRepository(db)
        chatRepo := repository.NewChatRepository(db)
        friendRepo := repository.NewFriendRepository(db)
        gameRepo := repository.NewGameRepository(db)
        streamRepo := repository.NewStreamRepository(db)

        // Initialize Prometheus metrics
        prom := middleware.InitMetrics("sanctum-api")

        server := &amp;Server{
                config:         cfg,
                db:             db,
                redis:          redisClient,
                promMiddleware: prom,
                userRepo:       userRepo,
                postRepo:       postRepo,
                commentRepo:    commentRepo,
                chatRepo:       chatRepo,
                friendRepo:     friendRepo,
                gameRepo:       gameRepo,
                streamRepo:     streamRepo,
                featureFlags:   featureflags.NewManager(cfg.FeatureFlags),
        }
        server.postService = service.NewPostService(server.postRepo, server.isAdminByUserID)
        server.commentService = service.NewCommentService(server.commentRepo, server.postRepo, server.isAdminByUserID)
        server.chatService = service.NewChatService(server.chatRepo, server.userRepo, server.db, server.isAdminByUserID)
        server.userService = service.NewUserService(server.userRepo)

        if err := seed.Sanctums(db); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to seed built-in sanctums: %w", err)
        }</span>

        // Initialize notifier and hub if Redis is available
        <span class="cov0" title="0">if redisClient != nil </span><span class="cov0" title="0">{
                server.notifier = notifications.NewNotifier(redisClient)
                server.hub = notifications.NewHub()
                server.chatHub = notifications.NewChatHub()
                server.gameHub = notifications.NewGameHub(db, server.notifier)
                server.videoChatHub = notifications.NewVideoChatHub()
                server.hubs = []wireableHub{server.hub, server.chatHub, server.gameHub, server.videoChatHub}
        }</span>

        <span class="cov0" title="0">return server, nil</span>
}

// SetupMiddleware configures middleware for the Fiber app
func (s *Server) SetupMiddleware(app *fiber.App) <span class="cov2" title="2">{
        // Panic recovery
        app.Use(recover.New())

        // Request ID for tracing
        app.Use(requestid.New())

        // Context Middleware to propagate Request ID and User ID
        app.Use(middleware.ContextMiddleware())

        // Prometheus Metrics
        if s.promMiddleware != nil </span><span class="cov0" title="0">{
                app.Use(middleware.MetricsMiddleware(s.promMiddleware))
        }</span>

        // Security headers
        <span class="cov2" title="2">app.Use(helmet.New())

        // Structured Logging middleware (after requestid and context middleware)
        app.Use(middleware.StructuredLogger())

        // CORS middleware should run before middlewares that can short-circuit (e.g. limiter)
        // so browser clients still receive CORS headers on error responses.
        origins := s.config.AllowedOrigins
        if origins == "" </span><span class="cov0" title="0">{
                origins = "http://localhost:5173,http://localhost:3000,http://127.0.0.1:5173"
        }</span>

        <span class="cov2" title="2">app.Use(cors.New(cors.Config{
                AllowOrigins:     origins,
                AllowHeaders:     "Origin, Content-Type, Accept, Authorization, Upgrade, Connection, Sec-WebSocket-Key, Sec-WebSocket-Version",
                AllowCredentials: true,
                MaxAge:           86400, // 24 hours
        }))

        // Global rate limiting (100 requests per minute per IP)
        app.Use(limiter.New(limiter.Config{
                Max:        100,
                Expiration: 1 * time.Minute,
                // Never rate-limit preflight requests; they should be handled by CORS.
                Next: func(c *fiber.Ctx) bool </span><span class="cov10" title="202">{
                        return c.Method() == fiber.MethodOptions
                }</span>,
                KeyGenerator: func(c *fiber.Ctx) string <span class="cov10" title="202">{
                        return c.IP()
                }</span>,
                LimitReached: func(c *fiber.Ctx) error <span class="cov2" title="2">{
                        return c.Status(fiber.StatusTooManyRequests).JSON(fiber.Map{
                                "error": "Too many requests, please try again later.",
                        })
                }</span>,
        }))
}

// SetupRoutes configures all routes for the application
func (s *Server) SetupRoutes(app *fiber.App) <span class="cov0" title="0">{
        api := app.Group("/api")

        // Health checks
        app.Get("/health/live", s.LivenessCheck)
        app.Get("/health/ready", s.ReadinessCheck)
        // Backwards-compatible legacy route: map /health to readiness (keeps existing scripts working)
        app.Get("/health", s.ReadinessCheck)
        api.Get("/", s.HealthCheck) // Vibecheck alias

        // Metrics endpoint for Prometheus
        if s.promMiddleware != nil </span><span class="cov0" title="0">{
                s.promMiddleware.RegisterAt(app, "/metrics")
        }</span>
        <span class="cov0" title="0">api.Get("/metrics/dashboard", monitor.New(monitor.Config{
                Title: "Sanctum Backend Metrics Dashboard",
        }))

        // Swagger documentation
        api.Get("/swagger/*", swagger.HandlerDefault)

        // Auth routes
        auth := api.Group("/auth")
        auth.Post("/signup", middleware.RateLimit(
                s.redis, 3, 10*time.Minute, "signup"), s.Signup)
        auth.Post("/login", middleware.RateLimit(
                s.redis, 10, 5*time.Minute, "login"), s.Login)
        auth.Post("/refresh", s.Refresh)
        auth.Post("/logout", s.Logout)

        // Public post routes (browse/search)
        publicPosts := api.Group("/posts")
        publicPosts.Get("/", s.GetPosts)
        publicPosts.Get("/search", middleware.RateLimit(
                s.redis, 10, time.Minute, "search"), s.SearchPosts)
        publicPosts.Get("/:id/comments", s.GetComments)
        publicPosts.Get("/:id", s.GetPost)

        // Public sanctum routes
        sanctums := api.Group("/sanctums")
        sanctums.Get("/", s.GetSanctums)
        sanctums.Get("/:slug", s.GetSanctumBySlug)

        // Protected routes
        protected := api.Group("", s.AuthRequired())

        // Sanctum request routes
        sanctumRequests := protected.Group("/sanctums/requests")
        sanctumRequests.Post("/", s.CreateSanctumRequest)
        sanctumRequests.Get("/me", s.GetMySanctumRequests)
        sanctumMemberships := protected.Group("/sanctums/memberships")
        sanctumMemberships.Get("/me", s.GetMySanctumMemberships)
        sanctumMemberships.Post("/bulk", s.UpsertMySanctumMemberships)

        // User routes
        users := protected.Group("/users")
        users.Get("/me", s.GetMyProfile)
        users.Put("/me", s.UpdateMyProfile)
        users.Get("/", s.GetAllUsers)

        // WebSocket ticket issuance
        api.Post("/ws/ticket", s.AuthRequired(), s.IssueWSTicket)

        // Define specific /:id/:resource routes BEFORE generic /:id route
        users.Get("/:id/cached", s.GetUserCached)
        users.Get("/:id/posts", s.GetUserPosts)
        users.Post("/:id/promote-admin", s.AdminRequired(), s.PromoteToAdmin)
        users.Post("/:id/demote-admin", s.AdminRequired(), s.DemoteFromAdmin)
        users.Get("/:id", s.GetUserProfile)

        // Friend routes
        friends := protected.Group("/friends")
        friends.Get("/", s.GetFriends)
        // Specific /requests routes before generic /:userId
        friends.Post("/requests/:userId", middleware.RateLimit(
                s.redis, 5, 5*time.Minute, "friend_request"), s.SendFriendRequest)
        friends.Get("/requests", s.GetPendingRequests)
        friends.Get("/requests/sent", s.GetSentRequests)
        friends.Post("/requests/:requestId/accept", s.AcceptFriendRequest)
        friends.Post("/requests/:requestId/reject", s.RejectFriendRequest)
        // Specific /status routes before generic /:userId
        friends.Get("/status/:userId", s.GetFriendshipStatus)
        // Generic /:userId route must be last
        friends.Delete("/:userId", s.RemoveFriend)

        // Protected post routes
        posts := protected.Group("/posts")
        posts.Post("/", middleware.RateLimit(
                s.redis, 1, 5*time.Minute, "create_post"), s.CreatePost)
        // Define specific /:id/:resource routes BEFORE generic /:id route
        posts.Post("/:id/like", s.LikePost)
        posts.Delete("/:id/like", s.UnlikePost)
        posts.Post("/:id/comments", middleware.RateLimit(
                s.redis, 1, time.Minute, "create_comment"), s.CreateComment)
        posts.Put("/:id/comments/:commentId", s.UpdateComment)
        posts.Delete("/:id/comments/:commentId", s.DeleteComment)
        // Generic /:id routes (for item detail, update, delete)
        posts.Put("/:id", s.UpdatePost)
        posts.Delete("/:id", s.DeletePost)

        // Chat routes
        conversations := protected.Group("/conversations")
        conversations.Post("/", s.CreateConversation)
        conversations.Get("/", s.GetConversations)
        // Define specific /:id/:resource routes BEFORE generic /:id route
        conversations.Get("/:id/messages", s.GetMessages)
        conversations.Post("/:id/messages", middleware.RateLimit(
                s.redis, 15, time.Minute, "send_chat"), s.SendMessage)
        conversations.Post("/:id/participants", s.AddParticipant)
        conversations.Delete("/:id", s.LeaveConversation)
        // Generic /:id route must be last
        conversations.Get("/:id", s.GetConversation)

        // Chatrooms routes (public group conversations)
        chatrooms := protected.Group("/chatrooms")
        chatrooms.Get("/", s.GetAllChatrooms)                                     // Get ALL public chatrooms
        chatrooms.Get("/joined", s.GetJoinedChatrooms)                            // Get rooms user has joined
        chatrooms.Post("/:id/join", s.JoinChatroom)                               // Join a chatroom
        chatrooms.Delete("/:id/participants/:participantId", s.RemoveParticipant) // Remove participant (admin/creator only)

        // Game routes
        games := protected.Group("/games")
        games.Post("/rooms", s.CreateGameRoom)
        games.Get("/rooms/active", s.GetActiveGameRooms)
        games.Post("/rooms/:id/leave", s.LeaveGameRoom)
        games.Get("/stats/:type", s.GetGameStats)
        games.Get("/rooms/:id", s.GetGameRoom)

        // Stream routes - public browse
        publicStreams := api.Group("/streams")
        publicStreams.Get("/", s.GetStreams)
        publicStreams.Get("/categories", s.GetStreamCategories)
        publicStreams.Get("/:id", s.GetStream)
        publicStreams.Get("/:id/messages", s.GetStreamMessages)

        // Stream routes - protected
        streams := protected.Group("/streams")
        streams.Get("/me", s.GetMyStreams)
        streams.Post("/", s.CreateStream)
        streams.Put("/:id", s.UpdateStream)
        streams.Delete("/:id", s.DeleteStream)
        streams.Post("/:id/go-live", s.GoLive)
        streams.Post("/:id/end", s.EndStream)
        streams.Post("/:id/messages", middleware.RateLimit(s.redis, 30, time.Minute, "stream_chat"), s.SendStreamMessage)

        // Websocket endpoints - protected by AuthRequired
        ws := api.Group("/ws", s.AuthRequired())
        ws.Get("/", s.WebsocketHandler())                   // General notifications
        ws.Get("/chat", s.WebSocketChatHandler())           // Real-time chat
        ws.Get("/game", s.WebSocketGameHandler())           // Multiplayer games
        ws.Get("/videochat", s.WebSocketVideoChatHandler()) // WebRTC video chat signaling

        // Admin routes
        admin := protected.Group("/admin", s.AdminRequired())
        admin.Get("/feature-flags", s.GetFeatureFlags)
        adminSanctumRequests := admin.Group("/sanctum-requests")
        adminSanctumRequests.Get("/", s.GetAdminSanctumRequests)
        adminSanctumRequests.Post("/:id/approve", s.ApproveSanctumRequest)
        adminSanctumRequests.Post("/:id/reject", s.RejectSanctumRequest)</span>
}

// HealthCheck is a legacy/simple alias for ReadinessCheck
func (s *Server) HealthCheck(c *fiber.Ctx) error <span class="cov0" title="0">{
        return s.ReadinessCheck(c)
}</span>

// LivenessCheck handles liveness probe requests
func (s *Server) LivenessCheck(c *fiber.Ctx) error <span class="cov1" title="1">{
        return c.Status(fiber.StatusOK).JSON(fiber.Map{
                "status": "up",
                "time":   time.Now(),
        })
}</span>

// ReadinessCheck handles readiness probe requests
func (s *Server) ReadinessCheck(c *fiber.Ctx) error <span class="cov2" title="2">{
        ctx, cancel := context.WithTimeout(c.Context(), 5*time.Second)
        defer cancel()

        dbStatus := "healthy"
        sqlDB, err := s.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                dbStatus = "unhealthy"
        }</span> else<span class="cov2" title="2"> if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov1" title="1">{
                dbStatus = "unhealthy"
        }</span>

        <span class="cov2" title="2">redisStatus := "healthy"
        if s.redis != nil </span><span class="cov2" title="2">{
                if err := s.redis.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                        redisStatus = "unhealthy"
                }</span>
        } else<span class="cov0" title="0"> {
                // Redis is considered required for full readiness in this app
                redisStatus = "unavailable"
        }</span>

        <span class="cov2" title="2">status := fiber.StatusOK
        overallStatus := "healthy"
        if dbStatus == "unhealthy" || redisStatus != "healthy" </span><span class="cov1" title="1">{
                status = fiber.StatusServiceUnavailable
                overallStatus = "unhealthy"
        }</span>

        <span class="cov2" title="2">return c.Status(status).JSON(fiber.Map{
                "message": "Vibecheck",
                "version": "1.0.0",
                "status":  overallStatus,
                "checks": fiber.Map{
                        "database": dbStatus,
                        "redis":    redisStatus,
                },
                "time": time.Now(),
        })</span>
}

// AdminRequired returns middleware that rejects non-admin users with 403.
// Must be placed after AuthRequired so that userID is available in locals.
func (s *Server) AdminRequired() fiber.Handler <span class="cov2" title="2">{
        return func(c *fiber.Ctx) error </span><span class="cov2" title="2">{
                userID := c.Locals("userID").(uint)

                admin, err := s.isAdmin(c, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return models.RespondWithError(c, fiber.StatusInternalServerError, err)
                }</span>
                <span class="cov2" title="2">if !admin </span><span class="cov1" title="1">{
                        return models.RespondWithError(c, fiber.StatusForbidden,
                                models.NewUnauthorizedError("Admin access required"))
                }</span>

                <span class="cov1" title="1">return c.Next()</span>
        }
}

// AuthRequired returns the authentication middleware
func (s *Server) AuthRequired() fiber.Handler <span class="cov1" title="1">{
        return func(c *fiber.Ctx) error </span><span class="cov4" title="8">{
                path := c.Path()
                isWSPath := strings.HasPrefix(path, "/api/ws")

                // 1. Try WebSocket ticket first (short-lived, single-use)
                ticket := c.Query("ticket")
                if ticket != "" &amp;&amp; s.redis != nil </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("ws_ticket:%s", ticket)
                        userIDStr, err := s.redis.Get(c.Context(), key).Result()
                        if err == nil </span><span class="cov0" title="0">{
                                // Valid ticket!
                                userID, parseErr := strconv.ParseUint(userIDStr, 10, 32)
                                if parseErr == nil </span><span class="cov0" title="0">{
                                        // Delete ticket immediately (single-use)
                                        s.redis.Del(c.Context(), key)

                                        // Store user ID in context
                                        c.Locals("userID", uint(userID))
                                        // Sync to UserContext for logging and downstream services
                                        ctx := context.WithValue(c.UserContext(), middleware.UserIDKey, uint(userID))
                                        c.SetUserContext(ctx)
                                        return c.Next()
                                }</span>
                        }
                        // If ticket was provided but invalid/expired, we fail if it's a WS path
                        <span class="cov0" title="0">if isWSPath </span><span class="cov0" title="0">{
                                return models.RespondWithError(c, fiber.StatusUnauthorized,
                                        models.NewUnauthorizedError("Invalid or expired WebSocket ticket"))
                        }</span>
                }

                // 2. Fall back to JWT (Bearer token or query param)
                <span class="cov4" title="8">authHeader := c.Get("Authorization")
                tokenString := ""
                if authHeader != "" </span><span class="cov4" title="6">{
                        parts := strings.Split(authHeader, " ")
                        if len(parts) == 2 &amp;&amp; parts[0] == "Bearer" </span><span class="cov3" title="5">{
                                tokenString = parts[1]
                        }</span>
                }

                // Reject token in query param for WS routes (must use ticket)
                <span class="cov4" title="8">if tokenString == "" &amp;&amp; !isWSPath </span><span class="cov2" title="3">{
                        tokenString = c.Query("token")
                }</span>

                <span class="cov4" title="8">if tokenString == "" </span><span class="cov2" title="2">{
                        return models.RespondWithError(c, fiber.StatusUnauthorized,
                                models.NewUnauthorizedError("Authorization required"))
                }</span>

                // Parse and validate token
                <span class="cov4" title="6">token, err := jwt.Parse(tokenString, func(token *jwt.Token) (any, error) </span><span class="cov4" title="6">{
                        // Validate signing method
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fiber.NewError(fiber.StatusUnauthorized, "Invalid signing method")
                        }</span>
                        <span class="cov4" title="6">return []byte(s.config.JWTSecret), nil</span>
                })

                <span class="cov4" title="6">if err != nil || !token.Valid </span><span class="cov1" title="1">{
                        return models.RespondWithError(c, fiber.StatusUnauthorized,
                                models.NewUnauthorizedError("Invalid or expired token"))
                }</span>

                // Extract claims
                <span class="cov3" title="5">claims, ok := token.Claims.(jwt.MapClaims)
                if !ok </span><span class="cov0" title="0">{
                        return models.RespondWithError(c, fiber.StatusUnauthorized,
                                models.NewUnauthorizedError("Invalid token claims"))
                }</span>

                // Validate issuer and audience
                <span class="cov3" title="5">if issuer, issuerOk := claims["iss"].(string); !issuerOk || (issuer != "sanctum-api" &amp;&amp; issuer != "vibeshift-api") </span><span class="cov1" title="1">{
                        return models.RespondWithError(c, fiber.StatusUnauthorized,
                                models.NewUnauthorizedError("Invalid token issuer"))
                }</span>
                <span class="cov3" title="4">if audience, audienceOk := claims["aud"].(string); !audienceOk || (audience != "sanctum-client" &amp;&amp; audience != "vibeshift-client") </span><span class="cov1" title="1">{
                        return models.RespondWithError(c, fiber.StatusUnauthorized,
                                models.NewUnauthorizedError("Invalid token audience"))
                }</span>

                // Extract user ID from subject claim
                <span class="cov2" title="3">sub, ok := claims["sub"].(string)
                if !ok </span><span class="cov1" title="1">{
                        return models.RespondWithError(c, fiber.StatusUnauthorized,
                                models.NewUnauthorizedError("Invalid subject claim"))
                }</span>

                <span class="cov2" title="2">userID, err := strconv.ParseUint(sub, 10, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return models.RespondWithError(c, fiber.StatusUnauthorized,
                                models.NewUnauthorizedError("Invalid user ID in token"))
                }</span>

                // Check JTI for revocation
                <span class="cov2" title="2">if jti, exists := claims["jti"].(string); exists &amp;&amp; jti != "" </span><span class="cov2" title="2">{
                        if s.redis != nil </span><span class="cov0" title="0">{
                                isBlacklisted, err := s.redis.Exists(c.Context(), "blacklist:"+jti).Result()
                                if err == nil &amp;&amp; isBlacklisted &gt; 0 </span><span class="cov0" title="0">{
                                        return models.RespondWithError(c, fiber.StatusUnauthorized,
                                                models.NewUnauthorizedError("Token has been revoked"))
                                }</span>
                        }
                }

                // Store user ID in context
                <span class="cov2" title="2">c.Locals("userID", uint(userID))
                // Sync to UserContext for logging and downstream services
                ctx := context.WithValue(c.UserContext(), middleware.UserIDKey, uint(userID))
                c.SetUserContext(ctx)

                return c.Next()</span>
        }
}

// optionalUserID attempts to extract userID from Authorization header but does not enforce it.
func (s *Server) optionalUserID(c *fiber.Ctx) (uint, bool) <span class="cov0" title="0">{
        authHeader := c.Get("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov0" title="0">tokenString := parts[1]
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (any, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fiber.NewError(fiber.StatusUnauthorized, "Invalid signing method")
                }</span>
                <span class="cov0" title="0">return []byte(s.config.JWTSecret), nil</span>
        })
        <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov0" title="0">sub, ok := claims["sub"].(string)
        if !ok </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">userID, err := strconv.ParseUint(sub, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov0" title="0">return uint(userID), true</span>
}

// Start starts the server
func (s *Server) Start() error <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        s.shutdownCtx = ctx
        s.shutdownFn = cancel

        app := fiber.New(fiber.Config{
                AppName: "Social Media API",
                ErrorHandler: func(c *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                        // Custom error handler
                        log.Printf("Error: %v", err)
                        return models.RespondWithError(c, fiber.StatusInternalServerError,
                                models.NewInternalError(err))
                }</span>,
        })
        <span class="cov0" title="0">s.app = app

        s.SetupMiddleware(app)
        s.SetupRoutes(app)

        // Wire all hubs to Redis subscriber if available
        if s.notifier != nil </span><span class="cov0" title="0">{
                for _, h := range s.hubs </span><span class="cov0" title="0">{
                        h := h
                        go func() </span><span class="cov0" title="0">{
                                if err := h.StartWiring(s.shutdownCtx, s.notifier); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("failed to start %s wiring: %v", h.Name(), err)
                                }</span>
                        }()
                }
        }

        <span class="cov0" title="0">log.Printf("Server starting on port %s...", s.config.Port)
        return app.Listen(":" + s.config.Port)</span>
}

// Shutdown gracefully shuts down the server
func (s *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        // Cancel the server-scoped context to stop all wiring goroutines
        if s.shutdownFn != nil </span><span class="cov0" title="0">{
                s.shutdownFn()
        }</span>

        // Shutdown the HTTP/WS server
        <span class="cov0" title="0">if s.app != nil </span><span class="cov0" title="0">{
                if err := s.app.ShutdownWithContext(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("error shutting down HTTP server: %v", err)
                }</span>
        }

        // Close WebSocket connections gracefully
        <span class="cov0" title="0">for _, h := range s.hubs </span><span class="cov0" title="0">{
                if err := h.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("error shutting down %s: %v", h.Name(), err)
                }</span>
        }

        // Close database connection
        <span class="cov0" title="0">if sqlDB, err := s.db.DB(); err == nil </span><span class="cov0" title="0">{
                if cerr := sqlDB.Close(); cerr != nil </span><span class="cov0" title="0">{
                        log.Printf("error closing sql DB: %v", cerr)
                }</span>
        }

        // Close Redis connection
        <span class="cov0" title="0">if s.redis != nil </span><span class="cov0" title="0">{
                if rerr := s.redis.Close(); rerr != nil </span><span class="cov0" title="0">{
                        log.Printf("error closing redis: %v", rerr)
                }</span>
        }

        <span class="cov0" title="0">log.Println("Server shutdown complete")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Package server contains HTTP and WebSocket handlers for the application's API endpoints.
package server

import (
        "time"

        "sanctum/internal/models"

        "github.com/gofiber/fiber/v2"
)

// CreateStreamRequest represents the request body for creating a stream
type CreateStreamRequest struct {
        Title        string `json:"title" validate:"required,min=1,max=255"`
        Description  string `json:"description"`
        ThumbnailURL string `json:"thumbnail_url"`
        StreamURL    string `json:"stream_url" validate:"required"`
        StreamType   string `json:"stream_type" validate:"required,oneof=youtube twitch hls iframe"`
        Category     string `json:"category"`
        Tags         string `json:"tags"`
}

// UpdateStreamRequest represents the request body for updating a stream
type UpdateStreamRequest struct {
        Title        string `json:"title"`
        Description  string `json:"description"`
        ThumbnailURL string `json:"thumbnail_url"`
        StreamURL    string `json:"stream_url"`
        StreamType   string `json:"stream_type"`
        Category     string `json:"category"`
        Tags         string `json:"tags"`
}

// GetStreams returns all live streams with optional filtering
// @Summary Get live streams
// @Tags Streams
// @Produce json
// @Param category query string false "Filter by category"
// @Param limit query int false "Limit results" default(20)
// @Param offset query int false "Offset for pagination" default(0)
// @Success 200 {object} map[string]interface{}
// @Router /streams [get]
func (s *Server) GetStreams(c *fiber.Ctx) error <span class="cov0" title="0">{
        category := c.Query("category", "")
        page := parsePagination(c, 20)

        if page.Limit &gt; 50 </span><span class="cov0" title="0">{
                page.Limit = 50
        }</span>

        <span class="cov0" title="0">streams, total, err := s.streamRepo.GetLiveStreams(c.Context(), category, page.Limit, page.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        <span class="cov0" title="0">return c.JSON(fiber.Map{
                "streams": streams,
                "total":   total,
                "limit":   page.Limit,
                "offset":  page.Offset,
        })</span>
}

// GetStream returns a single stream by ID
// @Summary Get stream by ID
// @Tags Streams
// @Produce json
// @Param id path int true "Stream ID"
// @Success 200 {object} models.Stream
// @Router /streams/{id} [get]
func (s *Server) GetStream(c *fiber.Ctx) error <span class="cov0" title="0">{
        id, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">stream, err := s.streamRepo.GetStreamByID(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusNotFound,
                        models.NewNotFoundError("Stream", id))
        }</span>

        <span class="cov0" title="0">return c.JSON(stream)</span>
}

// CreateStream creates a new stream
// @Summary Create a new stream
// @Tags Streams
// @Accept json
// @Produce json
// @Param stream body CreateStreamRequest true "Stream data"
// @Success 201 {object} models.Stream
// @Router /streams [post]
func (s *Server) CreateStream(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uint)

        var req CreateStreamRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        <span class="cov0" title="0">if req.Title == "" </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Title is required"))
        }</span>

        <span class="cov0" title="0">if req.StreamURL == "" </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Stream URL is required"))
        }</span>

        <span class="cov0" title="0">stream := &amp;models.Stream{
                UserID:       userID,
                Title:        req.Title,
                Description:  req.Description,
                ThumbnailURL: req.ThumbnailURL,
                StreamURL:    req.StreamURL,
                StreamType:   req.StreamType,
                Category:     req.Category,
                Tags:         req.Tags,
                IsLive:       false,
        }

        if err := s.streamRepo.CreateStream(c.Context(), stream); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        // Fetch the complete stream with user
        <span class="cov0" title="0">stream, _ = s.streamRepo.GetStreamByID(c.Context(), stream.ID)

        return c.Status(fiber.StatusCreated).JSON(stream)</span>
}

// UpdateStream updates an existing stream
// @Summary Update a stream
// @Tags Streams
// @Accept json
// @Produce json
// @Param id path int true "Stream ID"
// @Param stream body UpdateStreamRequest true "Stream data"
// @Success 200 {object} models.Stream
// @Router /streams/{id} [put]
func (s *Server) UpdateStream(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uint)

        id, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">stream, err := s.streamRepo.GetStreamByID(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusNotFound,
                        models.NewNotFoundError("Stream", id))
        }</span>

        <span class="cov0" title="0">if stream.UserID != userID </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusForbidden,
                        models.NewForbiddenError("You can only update your own streams"))
        }</span>

        <span class="cov0" title="0">var req UpdateStreamRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        // Update only non-empty fields
        <span class="cov0" title="0">if req.Title != "" </span><span class="cov0" title="0">{
                stream.Title = req.Title
        }</span>
        <span class="cov0" title="0">if req.Description != "" </span><span class="cov0" title="0">{
                stream.Description = req.Description
        }</span>
        <span class="cov0" title="0">if req.ThumbnailURL != "" </span><span class="cov0" title="0">{
                stream.ThumbnailURL = req.ThumbnailURL
        }</span>
        <span class="cov0" title="0">if req.StreamURL != "" </span><span class="cov0" title="0">{
                stream.StreamURL = req.StreamURL
        }</span>
        <span class="cov0" title="0">if req.StreamType != "" </span><span class="cov0" title="0">{
                stream.StreamType = req.StreamType
        }</span>
        <span class="cov0" title="0">if req.Category != "" </span><span class="cov0" title="0">{
                stream.Category = req.Category
        }</span>
        <span class="cov0" title="0">if req.Tags != "" </span><span class="cov0" title="0">{
                stream.Tags = req.Tags
        }</span>

        <span class="cov0" title="0">if err := s.streamRepo.UpdateStream(c.Context(), stream); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        <span class="cov0" title="0">return c.JSON(stream)</span>
}

// DeleteStream deletes a stream
// @Summary Delete a stream
// @Tags Streams
// @Param id path int true "Stream ID"
// @Success 204
// @Router /streams/{id} [delete]
func (s *Server) DeleteStream(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uint)

        id, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">stream, err := s.streamRepo.GetStreamByID(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusNotFound,
                        models.NewNotFoundError("Stream", id))
        }</span>

        <span class="cov0" title="0">if stream.UserID != userID </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusForbidden,
                        models.NewForbiddenError("You can only delete your own streams"))
        }</span>

        <span class="cov0" title="0">if err := s.streamRepo.DeleteStream(c.Context(), id); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        <span class="cov0" title="0">return c.SendStatus(fiber.StatusNoContent)</span>
}

// GoLive starts a stream
// @Summary Start streaming (go live)
// @Tags Streams
// @Param id path int true "Stream ID"
// @Success 200 {object} models.Stream
// @Router /streams/{id}/go-live [post]
func (s *Server) GoLive(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uint)

        id, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">stream, err := s.streamRepo.GetStreamByID(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusNotFound,
                        models.NewNotFoundError("Stream", id))
        }</span>

        <span class="cov0" title="0">if stream.UserID != userID </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusForbidden,
                        models.NewForbiddenError("You can only go live on your own streams"))
        }</span>

        <span class="cov0" title="0">if stream.IsLive </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Stream is already live"))
        }</span>

        <span class="cov0" title="0">if err := s.streamRepo.SetStreamLive(c.Context(), id, true); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        // Fetch updated stream
        <span class="cov0" title="0">stream, _ = s.streamRepo.GetStreamByID(c.Context(), id)

        return c.JSON(stream)</span>
}

// EndStream ends a live stream
// @Summary End streaming
// @Tags Streams
// @Param id path int true "Stream ID"
// @Success 200 {object} models.Stream
// @Router /streams/{id}/end [post]
func (s *Server) EndStream(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uint)

        id, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">stream, err := s.streamRepo.GetStreamByID(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusNotFound,
                        models.NewNotFoundError("Stream", id))
        }</span>

        <span class="cov0" title="0">if stream.UserID != userID </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusForbidden,
                        models.NewForbiddenError("You can only end your own streams"))
        }</span>

        <span class="cov0" title="0">if !stream.IsLive </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Stream is not live"))
        }</span>

        <span class="cov0" title="0">if err := s.streamRepo.SetStreamLive(c.Context(), id, false); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        // Fetch updated stream
        <span class="cov0" title="0">stream, _ = s.streamRepo.GetStreamByID(c.Context(), id)

        return c.JSON(stream)</span>
}

// GetMyStreams returns all streams for the authenticated user
// @Summary Get my streams
// @Tags Streams
// @Produce json
// @Success 200 {array} models.Stream
// @Router /streams/me [get]
func (s *Server) GetMyStreams(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uint)

        streams, err := s.streamRepo.GetStreamsByUserID(c.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        <span class="cov0" title="0">return c.JSON(streams)</span>
}

// GetStreamMessages returns chat messages for a stream
// @Summary Get stream chat messages
// @Tags Streams
// @Produce json
// @Param id path int true "Stream ID"
// @Param limit query int false "Limit results" default(50)
// @Param offset query int false "Offset for pagination" default(0)
// @Success 200 {array} models.StreamMessage
// @Router /streams/{id}/messages [get]
func (s *Server) GetStreamMessages(c *fiber.Ctx) error <span class="cov0" title="0">{
        id, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">page := parsePagination(c, 50)

        if page.Limit &gt; 100 </span><span class="cov0" title="0">{
                page.Limit = 100
        }</span>

        <span class="cov0" title="0">messages, err := s.streamRepo.GetStreamMessages(c.Context(), id, page.Limit, page.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        <span class="cov0" title="0">return c.JSON(messages)</span>
}

// SendStreamMessage posts a chat message to a stream
// @Summary Send stream chat message
// @Tags Streams
// @Accept json
// @Produce json
// @Param id path int true "Stream ID"
// @Param message body map[string]string true "Message content"
// @Success 201 {object} models.StreamMessage
// @Router /streams/{id}/messages [post]
func (s *Server) SendStreamMessage(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uint)

        id, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Verify stream exists
        <span class="cov0" title="0">_, err = s.streamRepo.GetStreamByID(c.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusNotFound,
                        models.NewNotFoundError("Stream", id))
        }</span>

        <span class="cov0" title="0">var req struct {
                Content string `json:"content"`
        }
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        <span class="cov0" title="0">if req.Content == "" </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Message content is required"))
        }</span>

        <span class="cov0" title="0">msg := &amp;models.StreamMessage{
                StreamID:  id,
                UserID:    userID,
                Content:   req.Content,
                CreatedAt: time.Now(),
        }

        if err := s.streamRepo.CreateStreamMessage(c.Context(), msg); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusInternalServerError,
                        models.NewInternalError(err))
        }</span>

        // Fetch message with user
        <span class="cov0" title="0">user, _ := s.userRepo.GetByID(c.Context(), userID)
        if user != nil </span><span class="cov0" title="0">{
                msg.User = *user
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(msg)</span>
}

// GetStreamCategories returns available stream categories
// @Summary Get stream categories
// @Tags Streams
// @Produce json
// @Success 200 {array} string
// @Router /streams/categories [get]
func (s *Server) GetStreamCategories(c *fiber.Ctx) error <span class="cov0" title="0">{
        return c.JSON(models.StreamCategories)
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">// Package server contains HTTP and WebSocket handlers for the application's API endpoints.
package server

import (
        "context"
        "errors"
        "time"

        "sanctum/internal/models"
        "sanctum/internal/service"

        "github.com/gofiber/fiber/v2"
)

// GetAllUsers handles GET /api/users
func (s *Server) GetAllUsers(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(c.Context(), 5*time.Second)
        defer cancel()

        page := parsePagination(c, 100)

        users, err := s.userSvc().ListUsers(ctx, page.Limit, page.Offset)
        if err != nil </span><span class="cov0" title="0">{
                // Check for timeout
                if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusGatewayTimeout).JSON(fiber.Map{
                                "error": "Request timeout",
                        })
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, fiber.StatusInternalServerError, err)</span>
        }

        <span class="cov0" title="0">return c.JSON(users)</span>
}

// GetUserProfile handles GET /api/users/:id
func (s *Server) GetUserProfile(c *fiber.Ctx) error <span class="cov10" title="3">{
        id, err := s.parseID(c, "id")
        if err != nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov6" title="2">user, err := s.userSvc().GetUserByID(c.Context(), id)
        if err != nil </span><span class="cov1" title="1">{
                return models.RespondWithError(c, fiber.StatusNotFound, err)
        }</span>

        <span class="cov1" title="1">return c.JSON(user)</span>
}

// GetMyProfile handles GET /api/users/me
func (s *Server) GetMyProfile(c *fiber.Ctx) error <span class="cov1" title="1">{
        userID := c.Locals("userID").(uint)

        user, err := s.userSvc().GetUserByID(c.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusNotFound, err)
        }</span>

        <span class="cov1" title="1">return c.JSON(user)</span>
}

// UpdateMyProfile handles PUT /api/users/me
func (s *Server) UpdateMyProfile(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.Context()
        userID := c.Locals("userID").(uint)

        var req struct {
                Username string `json:"username"`
                Bio      string `json:"bio"`
                Avatar   string `json:"avatar"`
        }
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return models.RespondWithError(c, fiber.StatusBadRequest,
                        models.NewValidationError("Invalid request body"))
        }</span>

        <span class="cov0" title="0">user, err := s.userSvc().UpdateProfile(ctx, service.UpdateProfileInput{
                UserID:   userID,
                Username: req.Username,
                Bio:      req.Bio,
                Avatar:   req.Avatar,
        })
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok &amp;&amp; appErr.Code == "NOT_FOUND" </span><span class="cov0" title="0">{
                        status = fiber.StatusNotFound
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">return c.JSON(user)</span>
}

// PromoteToAdmin handles POST /api/users/:id/promote-admin (admin only)
// Admin check is enforced by AdminRequired middleware on the route.
func (s *Server) PromoteToAdmin(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.Context()
        targetID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">target, err := s.userSvc().SetAdmin(ctx, targetID, true)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok &amp;&amp; appErr.Code == "NOT_FOUND" </span><span class="cov0" title="0">{
                        status = fiber.StatusNotFound
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">return c.JSON(fiber.Map{"message": "User promoted to admin", "user": target})</span>
}

// DemoteFromAdmin handles POST /api/users/:id/demote-admin (admin only)
// Admin check is enforced by AdminRequired middleware on the route.
func (s *Server) DemoteFromAdmin(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.Context()
        targetID, err := s.parseID(c, "id")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">target, err := s.userSvc().SetAdmin(ctx, targetID, false)
        if err != nil </span><span class="cov0" title="0">{
                status := fiber.StatusInternalServerError
                if appErr, ok := err.(*models.AppError); ok &amp;&amp; appErr.Code == "NOT_FOUND" </span><span class="cov0" title="0">{
                        status = fiber.StatusNotFound
                }</span>
                <span class="cov0" title="0">return models.RespondWithError(c, status, err)</span>
        }

        <span class="cov0" title="0">return c.JSON(fiber.Map{"message": "User demoted from admin", "user": target})</span>
}

func (s *Server) userSvc() *service.UserService <span class="cov10" title="3">{
        if s.userService == nil </span><span class="cov6" title="2">{
                s.userService = service.NewUserService(s.userRepo)
        }</span>
        <span class="cov10" title="3">return s.userService</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Package server contains HTTP and WebSocket handlers for the application's API endpoints.
package server

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "time"

        "sanctum/internal/middleware"
        "sanctum/internal/models"
        "sanctum/internal/notifications"

        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/websocket/v2"
)

// WebSocketChatHandler handles WebSocket connections for real-time chat
func (s *Server) WebSocketChatHandler() fiber.Handler <span class="cov0" title="0">{
        return websocket.New(func(conn *websocket.Conn) </span><span class="cov0" title="0">{
                middleware.ActiveWebSockets.Inc()
                defer middleware.ActiveWebSockets.Dec()

                ctx := context.Background()

                // Get userID from context locals (set by AuthRequired middleware)
                userIDVal := conn.Locals("userID")
                if userIDVal == nil </span><span class="cov0" title="0">{
                        log.Printf("WebSocket Chat: Unauthenticated connection attempt")
                        _ = conn.WriteMessage(websocket.TextMessage, []byte(`{"error":"unauthorized"}`))
                        _ = conn.Close()
                        return
                }</span>
                <span class="cov0" title="0">userID := userIDVal.(uint)

                // Get user info for username
                user, err := s.userRepo.GetByID(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("WebSocket Chat: Failed to get user %d: %v", userID, err)
                        _ = conn.Close()
                        return
                }</span>
                <span class="cov0" title="0">username := user.Username

                log.Printf("WebSocket: User %d (%s) connected to chat", userID, username)

                // Register user with ChatHub
                if s.chatHub == nil </span><span class="cov0" title="0">{
                        _ = conn.Close()
                        return
                }</span>

                <span class="cov0" title="0">client, err := s.chatHub.Register(userID, conn)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("WebSocket Chat: Failed to register user %d: %v", userID, err)
                        _ = conn.WriteMessage(websocket.TextMessage, []byte(`{"error":"`+err.Error()+`"}`))
                        _ = conn.Close()
                        return
                }</span>

                // Define Incoming Message Handler
                <span class="cov0" title="0">client.IncomingHandler = func(c *notifications.Client, message []byte) </span><span class="cov0" title="0">{
                        // Parse incoming message
                        var incomingMsg map[string]interface{}
                        if err := json.Unmarshal(message, &amp;incomingMsg); err != nil </span><span class="cov0" title="0">{
                                log.Printf("WebSocket: Invalid message format from user %d", userID)
                                return
                        }</span>

                        <span class="cov0" title="0">msgType, ok := incomingMsg["type"].(string)
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // Handle different message types
                        <span class="cov0" title="0">switch msgType </span>{
                        case "join":<span class="cov0" title="0">
                                // Join a conversation
                                if convIDFloat, ok := incomingMsg["conversation_id"].(float64); ok </span><span class="cov0" title="0">{
                                        convID := uint(convIDFloat)
                                        if s.chatHub != nil </span><span class="cov0" title="0">{
                                                // Verify user is participant before joining
                                                if s.isUserParticipant(ctx, userID, convID) </span><span class="cov0" title="0">{
                                                        s.chatHub.JoinConversation(userID, convID)

                                                        // Send confirmation to user
                                                        response := notifications.ChatMessage{
                                                                Type:           "joined",
                                                                ConversationID: convID,
                                                                Payload:        map[string]interface{}{"conversation_id": convID},
                                                        }
                                                        responseJSON, _ := json.Marshal(response)
                                                        c.TrySend(responseJSON)
                                                }</span>
                                        }
                                }

                        case "leave":<span class="cov0" title="0">
                                // Leave a conversation
                                if convIDFloat, ok := incomingMsg["conversation_id"].(float64); ok </span><span class="cov0" title="0">{
                                        convID := uint(convIDFloat)
                                        if s.chatHub != nil </span><span class="cov0" title="0">{
                                                s.chatHub.LeaveConversation(userID, convID)
                                        }</span>
                                }

                        case "typing":<span class="cov0" title="0">
                                // Typing indicator - limit to 10 per 10 seconds to prevent spam
                                if convIDFloat, ok := incomingMsg["conversation_id"].(float64); ok </span><span class="cov0" title="0">{
                                        convID := uint(convIDFloat)
                                        isTyping, _ := incomingMsg["is_typing"].(bool)

                                        if s.notifier != nil &amp;&amp; s.isUserParticipant(ctx, userID, convID) </span><span class="cov0" title="0">{
                                                // Rate limit typing indicators
                                                id := fmt.Sprintf("user:%d", userID)
                                                allowed, _ := middleware.CheckRateLimit(ctx, s.redis, "typing", id, 10, 10*time.Second)
                                                if !allowed </span><span class="cov0" title="0">{
                                                        return // Silently drop spammy typing indicators
                                                }</span>

                                                <span class="cov0" title="0">if perr := s.notifier.PublishTypingIndicator(ctx, convID, userID, username, isTyping); perr != nil </span><span class="cov0" title="0">{
                                                        log.Printf("publish typing indicator error: %v", perr)
                                                }</span>
                                        }
                                }

                        case "message":<span class="cov0" title="0">
                                // Send a message (alternative to HTTP endpoint)
                                if convIDFloat, ok := incomingMsg["conversation_id"].(float64); ok </span><span class="cov0" title="0">{
                                        convID := uint(convIDFloat)
                                        content, _ := incomingMsg["content"].(string)

                                        if content != "" &amp;&amp; s.isUserParticipant(ctx, userID, convID) </span><span class="cov0" title="0">{
                                                // Rate limit messages - same as HTTP (15 per minute)
                                                id := fmt.Sprintf("user:%d", userID)
                                                allowed, _ := middleware.CheckRateLimit(ctx, s.redis, "send_chat", id, 15, time.Minute)
                                                if !allowed </span><span class="cov0" title="0">{
                                                        response := notifications.ChatMessage{
                                                                Type: "error",
                                                                Payload: map[string]string{
                                                                        "message": "Rate limit exceeded. Please wait a moment.",
                                                                },
                                                        }
                                                        if respJSON, err := json.Marshal(response); err == nil </span><span class="cov0" title="0">{
                                                                c.TrySend(respJSON)
                                                        }</span>
                                                        <span class="cov0" title="0">return</span>
                                                }

                                                // Create message in database
                                                <span class="cov0" title="0">message := &amp;models.Message{
                                                        ConversationID: convID,
                                                        SenderID:       userID,
                                                        Content:        content,
                                                        MessageType:    "text",
                                                }

                                                if err := s.chatRepo.CreateMessage(ctx, message); err != nil </span><span class="cov0" title="0">{
                                                        log.Printf("WebSocket: Failed to create message: %v", err)
                                                        return
                                                }</span>

                                                // Load sender info - best-effort attempt
                                                <span class="cov0" title="0">if sender, err := s.userRepo.GetByID(ctx, userID); err == nil </span><span class="cov0" title="0">{
                                                        message.Sender = sender
                                                }</span>

                                                // Broadcast via Redis
                                                <span class="cov0" title="0">if s.notifier != nil </span><span class="cov0" title="0">{
                                                        messageJSON, err := json.Marshal(notifications.ChatMessage{
                                                                Type:           "message",
                                                                ConversationID: convID,
                                                                UserID:         userID,
                                                                Username:       username,
                                                                Payload:        message,
                                                        })
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                log.Printf("marshal chat message error: %v", err)
                                                                return
                                                        }</span>
                                                        <span class="cov0" title="0">if perr := s.notifier.PublishChatMessage(ctx, convID, string(messageJSON)); perr != nil </span><span class="cov0" title="0">{
                                                                log.Printf("publish chat message error: %v", perr)
                                                        }</span>
                                                }

                                                <span class="cov0" title="0">if s.chatHub != nil &amp;&amp; s.isGroupConversation(ctx, convID) </span><span class="cov0" title="0">{
                                                        s.chatHub.BroadcastToAllUsers(notifications.ChatMessage{
                                                                Type:           "room_message",
                                                                ConversationID: convID,
                                                                UserID:         userID,
                                                                Username:       username,
                                                                Payload:        message,
                                                        })
                                                }</span>
                                        }
                                }

                        case "read":<span class="cov0" title="0">
                                // Mark conversation as read
                                if convIDFloat, ok := incomingMsg["conversation_id"].(float64); ok </span><span class="cov0" title="0">{
                                        convID := uint(convIDFloat)
                                        if s.isUserParticipant(ctx, userID, convID) </span><span class="cov0" title="0">{
                                                if uerr := s.chatRepo.UpdateLastRead(ctx, convID, userID); uerr != nil </span><span class="cov0" title="0">{
                                                        log.Printf("update last read error: %v", uerr)
                                                }</span>

                                                // Broadcast read receipt
                                                <span class="cov0" title="0">if s.notifier != nil </span><span class="cov0" title="0">{
                                                        readMsg := notifications.ChatMessage{
                                                                Type:           "read",
                                                                ConversationID: convID,
                                                                UserID:         userID,
                                                                Username:       username,
                                                                Payload:        map[string]interface{}{"conversation_id": convID, "user_id": userID},
                                                        }
                                                        readJSON, _ := json.Marshal(readMsg)
                                                        if perr := s.notifier.PublishChatMessage(ctx, convID, string(readJSON)); perr != nil </span><span class="cov0" title="0">{
                                                                log.Printf("publish read receipt error: %v", perr)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }

                // Send welcome message
                <span class="cov0" title="0">welcomeMsg := notifications.ChatMessage{
                        Type:    "connected",
                        Payload: map[string]interface{}{"user_id": userID, "username": username},
                }
                if welcomeJSON, err := json.Marshal(welcomeMsg); err == nil </span><span class="cov0" title="0">{
                        client.TrySend(welcomeJSON)
                }</span>

                // Start write pump in a goroutine
                <span class="cov0" title="0">go client.WritePump()

                // Read pump runs in the main handler goroutine (blocking)
                client.ReadPump()

                // Broadcast offline presence for any rooms the user was in
                if s.chatHub != nil &amp;&amp; !s.chatHub.IsUserOnline(userID) </span><span class="cov0" title="0">{
                        // User's last connection dropped ‚Äî broadcast offline status to their rooms
                        var roomIDs []uint
                        s.db.WithContext(ctx).
                                Table("conversation_participants AS cp").
                                Joins("JOIN conversations c ON c.id = cp.conversation_id").
                                Where("cp.user_id = ? AND c.is_group = ?", userID, true).
                                Pluck("cp.conversation_id", &amp;roomIDs)
                        for _, roomID := range roomIDs </span><span class="cov0" title="0">{
                                s.chatHub.LeaveConversation(userID, roomID)
                                s.broadcastChatroomPresenceSnapshot(ctx, roomID, userID, username, "offline")
                        }</span>
                }
        })
}

// isUserParticipant checks if a user is a participant in a conversation
func (s *Server) isUserParticipant(ctx context.Context, userID, conversationID uint) bool <span class="cov10" title="2">{
        conv, err := s.chatRepo.GetConversation(ctx, conversationID)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov10" title="2">for _, participant := range conv.Participants </span><span class="cov10" title="2">{
                if participant.ID == userID </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

func (s *Server) isGroupConversation(ctx context.Context, conversationID uint) bool <span class="cov0" title="0">{
        var conversation models.Conversation
        if err := s.db.WithContext(ctx).
                Select("id", "is_group").
                First(&amp;conversation, conversationID).Error; err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return conversation.IsGroup</span>
}

// removeUserFromAllGroupChatrooms is intentionally removed.
// Chatroom membership is now persistent ‚Äî users stay in rooms across sessions.

func (s *Server) broadcastChatroomPresenceSnapshot(
        ctx context.Context,
        conversationID uint,
        userID uint,
        username string,
        action string,
) <span class="cov0" title="0">{
        if s.chatHub == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">conv, err := s.chatRepo.GetConversation(ctx, conversationID)
        if err != nil || !conv.IsGroup </span><span class="cov0" title="0">{
                return
        }</span>

        // Compute which participants are currently online via the ChatHub
        <span class="cov0" title="0">onlineIDs := make([]uint, 0)
        for _, p := range conv.Participants </span><span class="cov0" title="0">{
                if s.chatHub.IsUserOnline(p.ID) </span><span class="cov0" title="0">{
                        onlineIDs = append(onlineIDs, p.ID)
                }</span>
        }

        <span class="cov0" title="0">s.chatHub.BroadcastToAllUsers(notifications.ChatMessage{
                Type:           "chatroom_presence",
                ConversationID: conversationID,
                UserID:         userID,
                Username:       username,
                Payload: map[string]interface{}{
                        "conversation_id": conversationID,
                        "user_id":         userID,
                        "username":        username,
                        "action":          action,
                        "participants":    conv.Participants,
                        "member_count":    len(conv.Participants),
                        "online_user_ids": onlineIDs,
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package server

import (
        "context"
        "encoding/json"
        "log"
        "time"

        "sanctum/internal/middleware"
        "sanctum/internal/notifications"

        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/websocket/v2"
)

const (
        // videoChatPingInterval is how often the server pings idle connections
        videoChatPingInterval = 30 * time.Second
        // videoChatPongTimeout is how long to wait for a pong before considering the peer dead
        videoChatPongTimeout = 40 * time.Second
        // videoChatMaxMessageSize allows for large SDP payloads
        videoChatMaxMessageSize = 16384
)

// WebSocketVideoChatHandler handles WebSocket connections for WebRTC video chat signaling.
// It authenticates via JWT, then manages join/leave/offer/answer/ice-candidate messages
// to coordinate peer-to-peer connections between users in a room.
func (s *Server) WebSocketVideoChatHandler() fiber.Handler <span class="cov0" title="0">{
        return websocket.New(func(conn *websocket.Conn) </span><span class="cov0" title="0">{
                middleware.ActiveWebSockets.Inc()
                defer middleware.ActiveWebSockets.Dec()

                // Get userID from context locals (set by AuthRequired middleware)
                userIDVal := conn.Locals("userID")
                if userIDVal == nil </span><span class="cov0" title="0">{
                        log.Printf("VideoChat WS: Unauthenticated connection attempt")
                        _ = conn.WriteMessage(websocket.TextMessage, []byte(`{"type":"error","payload":{"message":"unauthorized"}}`))
                        _ = conn.Close()
                        return
                }</span>
                <span class="cov0" title="0">userID := userIDVal.(uint)

                // Get user info for username
                user, err := s.userRepo.GetByID(context.Background(), userID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("VideoChat WS: Failed to get user %d: %v", userID, err)
                        _ = conn.Close()
                        return
                }</span>
                <span class="cov0" title="0">username := user.Username

                // Room ID from query parameter
                roomID := conn.Query("room")
                if roomID == "" </span><span class="cov0" title="0">{
                        _ = conn.WriteMessage(websocket.TextMessage, []byte(`{"type":"error","payload":{"message":"room parameter required"}}`))
                        _ = conn.Close()
                        return
                }</span>

                <span class="cov0" title="0">log.Printf("VideoChat WS: User %d (%s) connecting to room %s", userID, username, roomID)

                if s.videoChatHub == nil </span><span class="cov0" title="0">{
                        _ = conn.WriteMessage(websocket.TextMessage, []byte(`{"type":"error","payload":{"message":"video chat not available"}}`))
                        _ = conn.Close()
                        return
                }</span>

                // Register the client
                <span class="cov0" title="0">client, err := s.videoChatHub.Register(roomID, userID, conn)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("VideoChat WS: Failed to register user %d: %v", userID, err)
                        _ = conn.WriteMessage(websocket.TextMessage, []byte(`{"type":"error","payload":{"message":"`+err.Error()+`"}}`))
                        _ = conn.Close()
                        return
                }</span>

                // Ensure cleanup on disconnect - cleanup is performed by client.ReadPump's defer

                // Notify others of the new joiner and send room state to the joiner
                <span class="cov0" title="0">s.videoChatHub.BroadcastJoin(roomID, userID, username)

                client.IncomingHandler = func(c *notifications.Client, message []byte) </span><span class="cov0" title="0">{
                        var signal notifications.VideoChatSignal
                        if err := json.Unmarshal(message, &amp;signal); err != nil </span><span class="cov0" title="0">{
                                log.Printf("VideoChat WS: Invalid message from user %d: %v", userID, err)
                                return
                        }</span>

                        <span class="cov0" title="0">signal.UserID = userID
                        signal.Username = username
                        signal.RoomID = roomID

                        switch signal.Type </span>{
                        case "offer", "answer", "ice-candidate":<span class="cov0" title="0">
                                if signal.TargetID == 0 </span><span class="cov0" title="0">{
                                        log.Printf("VideoChat WS: %s from user %d missing target_id", signal.Type, userID)
                                        return
                                }</span>
                                <span class="cov0" title="0">s.videoChatHub.Relay(roomID, userID, signal.TargetID, signal)</span>

                        case "leave":<span class="cov0" title="0">
                                // Explicit leave handled by ReadPump closing
                                _ = c.Conn.Close()</span>

                        default:<span class="cov0" title="0">
                                log.Printf("VideoChat WS: Unknown signal type %q from user %d", signal.Type, userID)</span>
                        }
                }

                <span class="cov0" title="0">go client.WritePump()
                client.ReadPump()</span>
        })
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package server

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "time"

        "github.com/gofiber/fiber/v2"
)

// IssueWSTicket issues a short-lived ticket for WebSocket authentication.
// @Summary Issue WebSocket ticket
// @Description Generates a short-lived (60s), single-use ticket for WebSocket authentication to avoid sending JWTs in query parameters.
// @Tags websocket
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} map[string]interface{} "ticket: string, expires_in: int"
// @Failure 401 {object} map[string]string "error: unauthorized"
// @Failure 503 {object} map[string]string "error: Redis not available"
// @Router /ws/ticket [post]
func (s *Server) IssueWSTicket(c *fiber.Ctx) error <span class="cov0" title="0">{
        userID := c.Locals("userID").(uint)

        // Generate a random ticket
        ticket, err := generateRandomString(32)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "error": "Failed to generate ticket",
                })
        }</span>

        // Store ticket in Redis with short TTL (60 seconds)
        // Key format: ws_ticket:TICKET_STRING
        <span class="cov0" title="0">if s.redis == nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusServiceUnavailable).JSON(fiber.Map{
                        "error": "Redis not available for ticket storage",
                })
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        key := fmt.Sprintf("ws_ticket:%s", ticket)
        err = s.redis.Set(ctx, key, userID, 60*time.Second).Err()
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "error": "Failed to store ticket",
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(fiber.Map{
                "ticket":     ticket,
                "expires_in": 60,
        })</span>
}

// generateRandomString generates a secure random string of given length
func generateRandomString(n int) (string, error) <span class="cov0" title="0">{
        b := make([]byte, n)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(b), nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package service

import (
        "context"
        "encoding/json"
        "errors"

        "sanctum/internal/models"
        "sanctum/internal/repository"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

type ChatService struct {
        chatRepo repository.ChatRepository
        userRepo repository.UserRepository
        db       *gorm.DB
        isAdmin  func(ctx context.Context, userID uint) (bool, error)
}

type CreateConversationInput struct {
        UserID         uint
        Name           string
        IsGroup        bool
        ParticipantIDs []uint
}

type SendMessageInput struct {
        UserID         uint
        ConversationID uint
        Content        string
        MessageType    string
        Metadata       json.RawMessage
}

func NewChatService(
        chatRepo repository.ChatRepository,
        userRepo repository.UserRepository,
        db *gorm.DB,
        isAdmin func(ctx context.Context, userID uint) (bool, error),
) *ChatService <span class="cov8" title="6">{
        return &amp;ChatService{
                chatRepo: chatRepo,
                userRepo: userRepo,
                db:       db,
                isAdmin:  isAdmin,
        }
}</span>

type ChatroomWithJoined struct {
        Conversation *models.Conversation
        IsJoined     bool
}

func (s *ChatService) CreateConversation(ctx context.Context, in CreateConversationInput) (*models.Conversation, error) <span class="cov7" title="5">{
        if in.IsGroup &amp;&amp; in.Name == "" </span><span class="cov1" title="1">{
                return nil, models.NewValidationError("Group conversations require a name")
        }</span>
        <span class="cov6" title="4">if len(in.ParticipantIDs) == 0 </span><span class="cov1" title="1">{
                return nil, models.NewValidationError("At least one participant is required")
        }</span>

        <span class="cov5" title="3">if !in.IsGroup &amp;&amp; len(in.ParticipantIDs) == 1 &amp;&amp; in.ParticipantIDs[0] != in.UserID &amp;&amp; s.db != nil </span><span class="cov1" title="1">{
                otherUserID := in.ParticipantIDs[0]
                var existing models.Conversation
                findErr := s.db.WithContext(ctx).
                        Model(&amp;models.Conversation{}).
                        Joins(
                                "JOIN conversation_participants cp_self ON cp_self.conversation_id = conversations.id AND cp_self.user_id = ?",
                                in.UserID,
                        ).
                        Joins(
                                "JOIN conversation_participants cp_other ON cp_other.conversation_id = conversations.id AND cp_other.user_id = ?",
                                otherUserID,
                        ).
                        Where("conversations.is_group = ?", false).
                        Where(
                                "NOT EXISTS (SELECT 1 FROM conversation_participants cp_extra WHERE cp_extra.conversation_id = conversations.id AND cp_extra.user_id NOT IN (?, ?))",
                                in.UserID,
                                otherUserID,
                        ).
                        Order("conversations.updated_at DESC").
                        First(&amp;existing).Error
                switch </span>{
                case findErr == nil:<span class="cov0" title="0">
                        return s.chatRepo.GetConversation(ctx, existing.ID)</span>
                case errors.Is(findErr, gorm.ErrRecordNotFound):<span class="cov1" title="1"></span>
                        // Create a new DM below.
                default:<span class="cov0" title="0">
                        return nil, findErr</span>
                }
        }

        <span class="cov5" title="3">conv := &amp;models.Conversation{
                Name:      in.Name,
                IsGroup:   in.IsGroup,
                CreatedBy: in.UserID,
        }
        if err := s.chatRepo.CreateConversation(ctx, conv); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="3">if err := s.chatRepo.AddParticipant(ctx, conv.ID, in.UserID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="3">for _, participantID := range in.ParticipantIDs </span><span class="cov5" title="3">{
                if participantID == in.UserID </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="3">if err := s.chatRepo.AddParticipant(ctx, conv.ID, participantID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov5" title="3">return s.chatRepo.GetConversation(ctx, conv.ID)</span>
}

func (s *ChatService) GetConversations(ctx context.Context, userID uint) ([]*models.Conversation, error) <span class="cov1" title="1">{
        return s.chatRepo.GetUserConversations(ctx, userID)
}</span>

func (s *ChatService) GetConversationForUser(ctx context.Context, convID, userID uint) (*models.Conversation, error) <span class="cov3" title="2">{
        conv, err := s.chatRepo.GetConversation(ctx, convID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">if !isConversationParticipant(conv, userID) </span><span class="cov1" title="1">{
                return nil, models.NewUnauthorizedError("You are not a participant in this conversation")
        }</span>
        <span class="cov1" title="1">return conv, nil</span>
}

func (s *ChatService) SendMessage(ctx context.Context, in SendMessageInput) (*models.Message, *models.Conversation, error) <span class="cov3" title="2">{
        if in.Content == "" </span><span class="cov0" title="0">{
                return nil, nil, models.NewValidationError("Message content is required")
        }</span>
        <span class="cov3" title="2">if in.MessageType == "" </span><span class="cov3" title="2">{
                in.MessageType = "text"
        }</span>
        <span class="cov3" title="2">if in.Metadata == nil </span><span class="cov3" title="2">{
                in.Metadata = json.RawMessage("{}")
        }</span>

        <span class="cov3" title="2">conv, err := s.chatRepo.GetConversation(ctx, in.ConversationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov3" title="2">if !isConversationParticipant(conv, in.UserID) </span><span class="cov1" title="1">{
                return nil, nil, models.NewUnauthorizedError("You are not a participant in this conversation")
        }</span>

        <span class="cov1" title="1">message := &amp;models.Message{
                ConversationID: in.ConversationID,
                SenderID:       in.UserID,
                Content:        in.Content,
                MessageType:    in.MessageType,
                Metadata:       in.Metadata,
        }
        if err := s.chatRepo.CreateMessage(ctx, message); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">if sender, err := s.userRepo.GetByID(ctx, in.UserID); err == nil </span><span class="cov1" title="1">{
                message.Sender = sender
        }</span>

        <span class="cov1" title="1">return message, conv, nil</span>
}

func (s *ChatService) GetMessagesForUser(ctx context.Context, convID, userID uint, limit, offset int) ([]*models.Message, error) <span class="cov1" title="1">{
        conv, err := s.chatRepo.GetConversation(ctx, convID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if !isConversationParticipant(conv, userID) </span><span class="cov0" title="0">{
                return nil, models.NewUnauthorizedError("You are not a participant in this conversation")
        }</span>
        <span class="cov1" title="1">return s.chatRepo.GetMessages(ctx, convID, limit, offset)</span>
}

func (s *ChatService) AddParticipant(ctx context.Context, convID, actorUserID, participantUserID uint) error <span class="cov1" title="1">{
        conv, err := s.chatRepo.GetConversation(ctx, convID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if !isConversationParticipant(conv, actorUserID) </span><span class="cov0" title="0">{
                return models.NewUnauthorizedError("You are not a participant in this conversation")
        }</span>
        <span class="cov1" title="1">if !conv.IsGroup </span><span class="cov0" title="0">{
                return models.NewValidationError("Cannot add participants to 1-on-1 conversations")
        }</span>
        <span class="cov1" title="1">return s.chatRepo.AddParticipant(ctx, convID, participantUserID)</span>
}

func (s *ChatService) LeaveConversation(ctx context.Context, convID, userID uint) (*models.Conversation, error) <span class="cov1" title="1">{
        conv, err := s.chatRepo.GetConversation(ctx, convID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if !isConversationParticipant(conv, userID) </span><span class="cov0" title="0">{
                return nil, models.NewUnauthorizedError("You are not a participant in this conversation")
        }</span>
        <span class="cov1" title="1">if err := s.chatRepo.RemoveParticipant(ctx, convID, userID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return conv, nil</span>
}

func (s *ChatService) GetAllChatrooms(ctx context.Context, userID uint) ([]ChatroomWithJoined, error) <span class="cov1" title="1">{
        var chatrooms []*models.Conversation
        err := s.db.WithContext(ctx).
                Where("is_group = ?", true).
                Preload("Participants").
                Preload("Messages", func(db *gorm.DB) *gorm.DB </span><span class="cov1" title="1">{
                        return db.Order("created_at DESC").Limit(1)
                }</span>).
                Preload("Messages.Sender").
                Order("name ASC").
                Find(&amp;chatrooms).Error
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">result := make([]ChatroomWithJoined, 0, len(chatrooms))
        for _, room := range chatrooms </span><span class="cov1" title="1">{
                isJoined := false
                for _, p := range room.Participants </span><span class="cov1" title="1">{
                        if p.ID == userID </span><span class="cov1" title="1">{
                                isJoined = true
                                break</span>
                        }
                }
                <span class="cov1" title="1">result = append(result, ChatroomWithJoined{
                        Conversation: room,
                        IsJoined:     isJoined,
                })</span>
        }

        <span class="cov1" title="1">return result, nil</span>
}

func (s *ChatService) GetJoinedChatrooms(ctx context.Context, userID uint) ([]*models.Conversation, error) <span class="cov1" title="1">{
        var chatrooms []*models.Conversation
        err := s.db.WithContext(ctx).
                Joins("JOIN conversation_participants cp ON cp.conversation_id = conversations.id").
                Where("conversations.is_group = ? AND cp.user_id = ?", true, userID).
                Preload("Participants").
                Preload("Messages", func(db *gorm.DB) *gorm.DB </span><span class="cov1" title="1">{
                        return db.Order("created_at DESC").Limit(1)
                }</span>).
                Preload("Messages.Sender").
                Order("conversations.name ASC").
                Find(&amp;chatrooms).Error
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return chatrooms, nil</span>
}

func (s *ChatService) JoinChatroom(ctx context.Context, roomID, userID uint) (*models.Conversation, error) <span class="cov1" title="1">{
        var conv models.Conversation
        if err := s.db.WithContext(ctx).First(&amp;conv, roomID).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return nil, models.NewNotFoundError("Chatroom", roomID)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov1" title="1">if !conv.IsGroup </span><span class="cov0" title="0">{
                return nil, models.NewValidationError("Cannot join a 1-on-1 conversation")
        }</span>

        <span class="cov1" title="1">err := s.db.WithContext(ctx).Clauses(clause.OnConflict{DoNothing: true}).Create(&amp;models.ConversationParticipant{
                ConversationID: roomID,
                UserID:         userID,
        }).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;conv, nil</span>
}

func (s *ChatService) RemoveParticipant(ctx context.Context, roomID, actorUserID, participantUserID uint) (string, error) <span class="cov3" title="2">{
        var conv models.Conversation
        if err := s.db.WithContext(ctx).First(&amp;conv, roomID).Error; err != nil </span><span class="cov0" title="0">{
                if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return "", models.NewNotFoundError("Chatroom", roomID)
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }

        <span class="cov3" title="2">admin := false
        if s.isAdmin != nil </span><span class="cov3" title="2">{
                var err error
                admin, err = s.isAdmin(ctx, actorUserID)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov3" title="2">if !admin &amp;&amp; conv.CreatedBy != actorUserID </span><span class="cov1" title="1">{
                return "", models.NewUnauthorizedError("Only admins or room creator can remove participants")
        }</span>

        <span class="cov1" title="1">if err := s.db.WithContext(ctx).
                Where("conversation_id = ? AND user_id = ?", roomID, participantUserID).
                Delete(&amp;models.ConversationParticipant{}).Error; err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">username := ""
        if user, err := s.userRepo.GetByID(ctx, actorUserID); err == nil &amp;&amp; user != nil </span><span class="cov1" title="1">{
                username = user.Username
        }</span>

        <span class="cov1" title="1">return username, nil</span>
}

func isConversationParticipant(conv *models.Conversation, userID uint) bool <span class="cov8" title="7">{
        for _, participant := range conv.Participants </span><span class="cov10" title="10">{
                if participant.ID == userID </span><span class="cov7" title="5">{
                        return true
                }</span>
        }
        <span class="cov3" title="2">return false</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package service

import (
        "context"

        "sanctum/internal/models"
        "sanctum/internal/repository"
)

type CommentService struct {
        commentRepo repository.CommentRepository
        postRepo    repository.PostRepository
        isAdmin     func(ctx context.Context, userID uint) (bool, error)
}

type CreateCommentInput struct {
        UserID  uint
        PostID  uint
        Content string
}

type UpdateCommentInput struct {
        UserID    uint
        CommentID uint
        Content   string
}

type DeleteCommentInput struct {
        UserID    uint
        CommentID uint
}

func NewCommentService(
        commentRepo repository.CommentRepository,
        postRepo repository.PostRepository,
        isAdmin func(ctx context.Context, userID uint) (bool, error),
) *CommentService <span class="cov0" title="0">{
        return &amp;CommentService{
                commentRepo: commentRepo,
                postRepo:    postRepo,
                isAdmin:     isAdmin,
        }
}</span>

func (s *CommentService) CreateComment(ctx context.Context, in CreateCommentInput) (*models.Comment, error) <span class="cov0" title="0">{
        if _, err := s.postRepo.GetByID(ctx, in.PostID, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if in.Content == "" </span><span class="cov0" title="0">{
                return nil, models.NewValidationError("Content is required")
        }</span>

        <span class="cov0" title="0">comment := &amp;models.Comment{
                Content: in.Content,
                UserID:  in.UserID,
                PostID:  in.PostID,
        }
        if err := s.commentRepo.Create(ctx, comment); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.commentRepo.GetByID(ctx, comment.ID)</span>
}

func (s *CommentService) ListComments(ctx context.Context, postID uint) ([]*models.Comment, error) <span class="cov0" title="0">{
        if _, err := s.postRepo.GetByID(ctx, postID, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return s.commentRepo.ListByPost(ctx, postID)</span>
}

func (s *CommentService) UpdateComment(ctx context.Context, in UpdateCommentInput) (*models.Comment, error) <span class="cov0" title="0">{
        comment, err := s.commentRepo.GetByID(ctx, in.CommentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if comment.UserID != in.UserID </span><span class="cov0" title="0">{
                return nil, models.NewUnauthorizedError("You can only update your own comments")
        }</span>
        <span class="cov0" title="0">if in.Content == "" </span><span class="cov0" title="0">{
                return nil, models.NewValidationError("Content is required")
        }</span>

        <span class="cov0" title="0">comment.Content = in.Content
        if err := s.commentRepo.Update(ctx, comment); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.commentRepo.GetByID(ctx, comment.ID)</span>
}

func (s *CommentService) DeleteComment(ctx context.Context, in DeleteCommentInput) (*models.Comment, error) <span class="cov0" title="0">{
        comment, err := s.commentRepo.GetByID(ctx, in.CommentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if comment.UserID != in.UserID </span><span class="cov0" title="0">{
                if s.isAdmin == nil </span><span class="cov0" title="0">{
                        return nil, models.NewUnauthorizedError("You can only delete your own comments")
                }</span>
                <span class="cov0" title="0">admin, err := s.isAdmin(ctx, in.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if !admin </span><span class="cov0" title="0">{
                        return nil, models.NewUnauthorizedError("You can only delete your own comments")
                }</span>
        }

        <span class="cov0" title="0">if err := s.commentRepo.Delete(ctx, in.CommentID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return comment, nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package service

import (
        "context"

        "sanctum/internal/models"
        "sanctum/internal/repository"
)

type FriendService struct {
        friendRepo repository.FriendRepository
        userRepo   repository.UserRepository
}

func NewFriendService(friendRepo repository.FriendRepository, userRepo repository.UserRepository) *FriendService <span class="cov10" title="3">{
        return &amp;FriendService{
                friendRepo: friendRepo,
                userRepo:   userRepo,
        }
}</span>

func (s *FriendService) SendFriendRequest(ctx context.Context, userID, targetUserID uint) (*models.Friendship, error) <span class="cov1" title="1">{
        if userID == targetUserID </span><span class="cov1" title="1">{
                return nil, models.NewValidationError("Cannot send friend request to yourself")
        }</span>

        <span class="cov0" title="0">if _, err := s.userRepo.GetByID(ctx, targetUserID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">existing, err := s.friendRepo.GetFriendshipBetweenUsers(ctx, userID, targetUserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                switch existing.Status </span>{
                case models.FriendshipStatusAccepted:<span class="cov0" title="0">
                        return nil, models.NewValidationError("You are already friends")</span>
                case models.FriendshipStatusPending:<span class="cov0" title="0">
                        if existing.RequesterID == userID </span><span class="cov0" title="0">{
                                return nil, models.NewValidationError("Friend request already sent")
                        }</span>
                        <span class="cov0" title="0">return nil, models.NewValidationError("You already have a pending friend request from this user")</span>
                }
        }

        <span class="cov0" title="0">friendship := &amp;models.Friendship{
                RequesterID: userID,
                AddresseeID: targetUserID,
                Status:      models.FriendshipStatusPending,
        }
        if err := s.friendRepo.Create(ctx, friendship); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.friendRepo.GetByID(ctx, friendship.ID)</span>
}

func (s *FriendService) GetPendingRequests(ctx context.Context, userID uint) ([]models.Friendship, error) <span class="cov0" title="0">{
        return s.friendRepo.GetPendingRequests(ctx, userID)
}</span>

func (s *FriendService) GetSentRequests(ctx context.Context, userID uint) ([]models.Friendship, error) <span class="cov0" title="0">{
        return s.friendRepo.GetSentRequests(ctx, userID)
}</span>

func (s *FriendService) AcceptFriendRequest(ctx context.Context, userID, requestID uint) (*models.Friendship, error) <span class="cov1" title="1">{
        friendship, err := s.friendRepo.GetByID(ctx, requestID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if friendship.AddresseeID != userID </span><span class="cov1" title="1">{
                return nil, models.NewUnauthorizedError("You can only accept friend requests sent to you")
        }</span>
        <span class="cov0" title="0">if friendship.Status != models.FriendshipStatusPending </span><span class="cov0" title="0">{
                return nil, models.NewValidationError("Friend request is not pending")
        }</span>

        <span class="cov0" title="0">if err := s.friendRepo.UpdateStatus(ctx, requestID, models.FriendshipStatusAccepted); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.friendRepo.GetByID(ctx, requestID)</span>
}

func (s *FriendService) RejectFriendRequest(ctx context.Context, userID, requestID uint) (*models.Friendship, error) <span class="cov0" title="0">{
        friendship, err := s.friendRepo.GetByID(ctx, requestID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if friendship.AddresseeID != userID &amp;&amp; friendship.RequesterID != userID </span><span class="cov0" title="0">{
                return nil, models.NewUnauthorizedError("You can only reject or cancel your own pending requests")
        }</span>
        <span class="cov0" title="0">if friendship.Status != models.FriendshipStatusPending </span><span class="cov0" title="0">{
                return nil, models.NewValidationError("Friend request is not pending")
        }</span>

        <span class="cov0" title="0">if err := s.friendRepo.Delete(ctx, requestID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return friendship, nil</span>
}

func (s *FriendService) GetFriends(ctx context.Context, userID uint) ([]models.User, error) <span class="cov0" title="0">{
        return s.friendRepo.GetFriends(ctx, userID)
}</span>

func (s *FriendService) GetFriendshipStatus(ctx context.Context, userID, targetUserID uint) (string, uint, *models.Friendship, error) <span class="cov0" title="0">{
        if _, err := s.userRepo.GetByID(ctx, targetUserID); err != nil </span><span class="cov0" title="0">{
                return "", 0, nil, err
        }</span>

        <span class="cov0" title="0">friendship, err := s.friendRepo.GetFriendshipBetweenUsers(ctx, userID, targetUserID)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, nil, err
        }</span>

        <span class="cov0" title="0">status := "none"
        var requestID uint
        if friendship != nil </span><span class="cov0" title="0">{
                switch friendship.Status </span>{
                case models.FriendshipStatusAccepted:<span class="cov0" title="0">
                        status = "friends"</span>
                case models.FriendshipStatusPending:<span class="cov0" title="0">
                        requestID = friendship.ID
                        if friendship.RequesterID == userID </span><span class="cov0" title="0">{
                                status = "pending_sent"
                        }</span> else<span class="cov0" title="0"> {
                                status = "pending_received"
                        }</span>
                default:<span class="cov0" title="0">
                        status = string(friendship.Status)</span>
                }
        }

        <span class="cov0" title="0">return status, requestID, friendship, nil</span>
}

func (s *FriendService) RemoveFriend(ctx context.Context, userID, targetUserID uint) (*models.Friendship, error) <span class="cov1" title="1">{
        friendship, err := s.friendRepo.GetFriendshipBetweenUsers(ctx, userID, targetUserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if friendship == nil || friendship.Status != models.FriendshipStatusAccepted </span><span class="cov1" title="1">{
                return nil, models.NewNotFoundError("Friendship", 0)
        }</span>

        <span class="cov0" title="0">if err := s.friendRepo.RemoveFriendship(ctx, userID, targetUserID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return friendship, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package service

import (
        "context"
        "errors"
        "log"
        "time"

        "sanctum/internal/models"
        "sanctum/internal/repository"

        "gorm.io/gorm"
)

const pendingRoomMaxIdle = 10 * time.Minute

func isPendingRoomStale(room models.GameRoom, now time.Time) bool <span class="cov1" title="1">{
        if room.Status != models.GamePending </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov1" title="1">return now.Sub(room.UpdatedAt) &gt; pendingRoomMaxIdle</span>
}

type GameService struct {
        gameRepo repository.GameRepository
}

func NewGameService(gameRepo repository.GameRepository) *GameService <span class="cov10" title="5">{
        return &amp;GameService{gameRepo: gameRepo}
}</span>

func (s *GameService) CreateGameRoom(_ context.Context, userID uint, gameType models.GameType) (*models.GameRoom, bool, error) <span class="cov1" title="1">{
        existingRooms, err := s.gameRepo.GetActiveRooms(gameType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, models.NewInternalError(err)
        }</span>

        <span class="cov1" title="1">now := time.Now()
        for _, room := range existingRooms </span><span class="cov1" title="1">{
                if room.CreatorID == userID </span><span class="cov1" title="1">{
                        if isPendingRoomStale(room, now) </span><span class="cov0" title="0">{
                                room.Status = models.GameCancelled
                                room.OpponentID = nil
                                room.WinnerID = nil
                                room.NextTurnID = 0
                                if updateErr := s.gameRepo.UpdateRoom(&amp;room); updateErr != nil </span><span class="cov0" title="0">{
                                        log.Printf("failed to auto-cancel stale room %d: %v", room.ID, updateErr)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov1" title="1">return &amp;room, false, nil</span>
                }
        }

        <span class="cov0" title="0">room := &amp;models.GameRoom{
                Type:          gameType,
                Status:        models.GamePending,
                CreatorID:     userID,
                CurrentState:  "{}",
                Configuration: "{}",
        }
        if err := s.gameRepo.CreateRoom(room); err != nil </span><span class="cov0" title="0">{
                return nil, false, models.NewInternalError(err)
        }</span>

        <span class="cov0" title="0">return room, true, nil</span>
}

func (s *GameService) GetActiveGameRooms(_ context.Context, gameType *models.GameType) ([]models.GameRoom, error) <span class="cov1" title="1">{
        var (
                rooms []models.GameRoom
                err   error
        )

        if gameType == nil </span><span class="cov1" title="1">{
                rooms, err = s.gameRepo.GetAllActiveRooms()
        }</span> else<span class="cov0" title="0"> {
                rooms, err = s.gameRepo.GetActiveRooms(*gameType)
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov1" title="1">{
                return nil, models.NewInternalError(err)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        filtered := make([]models.GameRoom, 0, len(rooms))
        for _, room := range rooms </span><span class="cov0" title="0">{
                if isPendingRoomStale(room, now) </span><span class="cov0" title="0">{
                        room.Status = models.GameCancelled
                        room.OpponentID = nil
                        room.WinnerID = nil
                        room.NextTurnID = 0
                        if updateErr := s.gameRepo.UpdateRoom(&amp;room); updateErr != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to auto-cancel stale room %d: %v", room.ID, updateErr)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">filtered = append(filtered, room)</span>
        }

        <span class="cov0" title="0">return filtered, nil</span>
}

func (s *GameService) GetGameStats(_ context.Context, userID uint, gameType models.GameType) (*models.GameStats, error) <span class="cov0" title="0">{
        stats, err := s.gameRepo.GetStats(userID, gameType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, models.NewInternalError(err)
        }</span>
        <span class="cov0" title="0">return stats, nil</span>
}

func (s *GameService) GetGameRoom(_ context.Context, roomID uint) (*models.GameRoom, error) <span class="cov1" title="1">{
        room, err := s.gameRepo.GetRoom(roomID)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        return nil, models.NewNotFoundError("GameRoom", roomID)
                }</span>
                <span class="cov0" title="0">return nil, models.NewInternalError(err)</span>
        }
        <span class="cov0" title="0">return room, nil</span>
}

func (s *GameService) LeaveGameRoom(_ context.Context, userID, roomID uint) (*models.GameRoom, bool, error) <span class="cov4" title="2">{
        room, err := s.gameRepo.GetRoom(roomID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, false, models.NewNotFoundError("GameRoom", roomID)
                }</span>
                <span class="cov0" title="0">return nil, false, models.NewInternalError(err)</span>
        }

        <span class="cov4" title="2">isCreator := room.CreatorID == userID
        isOpponent := room.OpponentID != nil &amp;&amp; *room.OpponentID == userID
        if !isCreator &amp;&amp; !isOpponent </span><span class="cov1" title="1">{
                return nil, false, models.NewForbiddenError("Not a participant in this room")
        }</span>

        <span class="cov1" title="1">if room.Status == models.GameFinished || room.Status == models.GameCancelled </span><span class="cov1" title="1">{
                return room, true, nil
        }</span>

        <span class="cov0" title="0">room.Status = models.GameCancelled
        room.OpponentID = nil
        room.WinnerID = nil
        room.NextTurnID = 0

        if err := s.gameRepo.UpdateRoom(room); err != nil </span><span class="cov0" title="0">{
                return nil, false, models.NewInternalError(err)
        }</span>

        <span class="cov0" title="0">return room, false, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package service

import (
        "context"

        "sanctum/internal/models"
        "sanctum/internal/repository"
)

type PostService struct {
        postRepo repository.PostRepository
        isAdmin  func(ctx context.Context, userID uint) (bool, error)
}

type CreatePostInput struct {
        UserID    uint
        Title     string
        Content   string
        ImageURL  string
        SanctumID *uint
}

type ListPostsInput struct {
        Limit         int
        Offset        int
        CurrentUserID uint
        SanctumID     *uint
}

type UpdatePostInput struct {
        UserID   uint
        PostID   uint
        Title    string
        Content  string
        ImageURL string
}

type DeletePostInput struct {
        UserID uint
        PostID uint
}

func NewPostService(
        postRepo repository.PostRepository,
        isAdmin func(ctx context.Context, userID uint) (bool, error),
) *PostService <span class="cov0" title="0">{
        return &amp;PostService{
                postRepo: postRepo,
                isAdmin:  isAdmin,
        }
}</span>

func (s *PostService) SearchPosts(ctx context.Context, query string, limit, offset int, currentUserID uint) ([]*models.Post, error) <span class="cov0" title="0">{
        if query == "" </span><span class="cov0" title="0">{
                return nil, models.NewValidationError("Search query is required")
        }</span>
        <span class="cov0" title="0">return s.postRepo.Search(ctx, query, limit, offset, currentUserID)</span>
}

func (s *PostService) CreatePost(ctx context.Context, in CreatePostInput) (*models.Post, error) <span class="cov0" title="0">{
        if in.Title == "" || in.Content == "" </span><span class="cov0" title="0">{
                return nil, models.NewValidationError("Title and content are required")
        }</span>

        <span class="cov0" title="0">post := &amp;models.Post{
                Title:     in.Title,
                Content:   in.Content,
                ImageURL:  in.ImageURL,
                UserID:    in.UserID,
                SanctumID: in.SanctumID,
        }
        if err := s.postRepo.Create(ctx, post); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.postRepo.GetByID(ctx, post.ID, in.UserID)</span>
}

func (s *PostService) ListPosts(ctx context.Context, in ListPostsInput) ([]*models.Post, error) <span class="cov0" title="0">{
        if in.SanctumID != nil </span><span class="cov0" title="0">{
                return s.postRepo.GetBySanctumID(ctx, *in.SanctumID, in.Limit, in.Offset, in.CurrentUserID)
        }</span>
        <span class="cov0" title="0">return s.postRepo.List(ctx, in.Limit, in.Offset, in.CurrentUserID)</span>
}

func (s *PostService) GetPost(ctx context.Context, id uint, currentUserID uint) (*models.Post, error) <span class="cov0" title="0">{
        return s.postRepo.GetByID(ctx, id, currentUserID)
}</span>

func (s *PostService) GetUserPosts(ctx context.Context, userID uint, limit, offset int, currentUserID uint) ([]*models.Post, error) <span class="cov0" title="0">{
        return s.postRepo.GetByUserID(ctx, userID, limit, offset, currentUserID)
}</span>

func (s *PostService) UpdatePost(ctx context.Context, in UpdatePostInput) (*models.Post, error) <span class="cov0" title="0">{
        post, err := s.postRepo.GetByID(ctx, in.PostID, in.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if post.UserID != in.UserID </span><span class="cov0" title="0">{
                return nil, models.NewUnauthorizedError("You can only update your own posts")
        }</span>

        <span class="cov0" title="0">if in.Title != "" </span><span class="cov0" title="0">{
                post.Title = in.Title
        }</span>
        <span class="cov0" title="0">if in.Content != "" </span><span class="cov0" title="0">{
                post.Content = in.Content
        }</span>
        <span class="cov0" title="0">if in.ImageURL != "" </span><span class="cov0" title="0">{
                post.ImageURL = in.ImageURL
        }</span>

        <span class="cov0" title="0">if err := s.postRepo.Update(ctx, post); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return post, nil</span>
}

func (s *PostService) DeletePost(ctx context.Context, in DeletePostInput) error <span class="cov0" title="0">{
        post, err := s.postRepo.GetByID(ctx, in.PostID, in.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if post.UserID != in.UserID </span><span class="cov0" title="0">{
                if s.isAdmin == nil </span><span class="cov0" title="0">{
                        return models.NewUnauthorizedError("You can only delete your own posts")
                }</span>
                <span class="cov0" title="0">admin, err := s.isAdmin(ctx, in.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !admin </span><span class="cov0" title="0">{
                        return models.NewUnauthorizedError("You can only delete your own posts")
                }</span>
        }

        <span class="cov0" title="0">return s.postRepo.Delete(ctx, in.PostID)</span>
}

func (s *PostService) ToggleLike(ctx context.Context, userID, postID uint) (*models.Post, error) <span class="cov0" title="0">{
        isLiked, err := s.postRepo.IsLiked(ctx, userID, postID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if isLiked </span><span class="cov0" title="0">{
                if err := s.postRepo.Unlike(ctx, userID, postID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := s.postRepo.Like(ctx, userID, postID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return s.postRepo.GetByID(ctx, postID, userID)</span>
}

func (s *PostService) UnlikePost(ctx context.Context, userID, postID uint) (*models.Post, error) <span class="cov0" title="0">{
        if err := s.postRepo.Unlike(ctx, userID, postID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return s.postRepo.GetByID(ctx, postID, userID)</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package service

import (
        "context"

        "sanctum/internal/models"
        "sanctum/internal/repository"
)

type UserService struct {
        userRepo repository.UserRepository
}

type UpdateProfileInput struct {
        UserID   uint
        Username string
        Bio      string
        Avatar   string
}

func NewUserService(userRepo repository.UserRepository) *UserService <span class="cov0" title="0">{
        return &amp;UserService{userRepo: userRepo}
}</span>

func (s *UserService) ListUsers(ctx context.Context, limit, offset int) ([]models.User, error) <span class="cov0" title="0">{
        return s.userRepo.List(ctx, limit, offset)
}</span>

func (s *UserService) GetUserByID(ctx context.Context, id uint) (*models.User, error) <span class="cov0" title="0">{
        return s.userRepo.GetByID(ctx, id)
}</span>

func (s *UserService) UpdateProfile(ctx context.Context, in UpdateProfileInput) (*models.User, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(ctx, in.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if in.Username != "" </span><span class="cov0" title="0">{
                user.Username = in.Username
        }</span>
        <span class="cov0" title="0">if in.Bio != "" </span><span class="cov0" title="0">{
                user.Bio = in.Bio
        }</span>
        <span class="cov0" title="0">if in.Avatar != "" </span><span class="cov0" title="0">{
                user.Avatar = in.Avatar
        }</span>

        <span class="cov0" title="0">if err := s.userRepo.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (s *UserService) SetAdmin(ctx context.Context, targetID uint, isAdmin bool) (*models.User, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(ctx, targetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">user.IsAdmin = isAdmin
        if err := s.userRepo.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">// Package validation provides input validation utilities
package validation

import (
        "fmt"
        "regexp"
        "unicode"
)

// ValidatePassword checks if a password meets security requirements
func ValidatePassword(password string) error <span class="cov6" title="6">{
        // Check minimum length
        if len(password) &lt; 12 </span><span class="cov1" title="1">{
                return fmt.Errorf("password must be at least 12 characters long")
        }</span>

        // Check maximum length (prevent unreasonable inputs)
        <span class="cov5" title="5">if len(password) &gt; 128 </span><span class="cov0" title="0">{
                return fmt.Errorf("password must not exceed 128 characters")
        }</span>

        // Check for uppercase letter
        <span class="cov5" title="5">hasUpper := false
        for _, r := range password </span><span class="cov9" title="17">{
                if unicode.IsUpper(r) </span><span class="cov5" title="4">{
                        hasUpper = true
                        break</span>
                }
        }
        <span class="cov5" title="5">if !hasUpper </span><span class="cov1" title="1">{
                return fmt.Errorf("password must contain at least one uppercase letter")
        }</span>

        // Check for lowercase letter
        <span class="cov5" title="4">hasLower := false
        for _, r := range password </span><span class="cov10" title="19">{
                if unicode.IsLower(r) </span><span class="cov4" title="3">{
                        hasLower = true
                        break</span>
                }
        }
        <span class="cov5" title="4">if !hasLower </span><span class="cov1" title="1">{
                return fmt.Errorf("password must contain at least one lowercase letter")
        }</span>

        // Check for digit
        <span class="cov4" title="3">hasDigit := regexp.MustCompile(`[0-9]`).MatchString(password)
        if !hasDigit </span><span class="cov1" title="1">{
                return fmt.Errorf("password must contain at least one digit")
        }</span>

        // Check for special character
        <span class="cov3" title="2">hasSpecial := regexp.MustCompile(`[!@#$%^&amp;*()_+\-=\[\]{};':"\\|,.&lt;&gt;\/?]`).MatchString(password)
        if !hasSpecial </span><span class="cov1" title="1">{
                return fmt.Errorf("password must contain at least one special character (!@#$%%^&amp;*)")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ValidateUsername checks if a username meets requirements
func ValidateUsername(username string) error <span class="cov5" title="5">{
        if len(username) &lt; 3 </span><span class="cov1" title="1">{
                return fmt.Errorf("username must be at least 3 characters long")
        }</span>

        <span class="cov5" title="4">if len(username) &gt; 30 </span><span class="cov0" title="0">{
                return fmt.Errorf("username must not exceed 30 characters")
        }</span>

        // Only allow alphanumeric and underscores
        <span class="cov5" title="4">if !regexp.MustCompile(`^[a-zA-Z0-9_-]+$`).MatchString(username) </span><span class="cov1" title="1">{
                return fmt.Errorf("username can only contain letters, numbers, underscores, and hyphens")
        }</span>

        // Cannot start or end with underscore/hyphen
        <span class="cov4" title="3">if username[0] == '_' || username[0] == '-' || username[len(username)-1] == '_' || username[len(username)-1] == '-' </span><span class="cov3" title="2">{
                return fmt.Errorf("username cannot start or end with underscore or hyphen")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ValidateEmail checks basic email format
func ValidateEmail(email string) error <span class="cov4" title="3">{
        // Simple email validation - regex approach
        emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`)
        if !emailRegex.MatchString(email) </span><span class="cov3" title="2">{
                return fmt.Errorf("invalid email format")
        }</span>

        <span class="cov1" title="1">if len(email) &gt; 254 </span><span class="cov0" title="0">{
                return fmt.Errorf("email must not exceed 254 characters")
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package validation

import (
        "fmt"
        "regexp"
        "strings"
)

var sanctumSlugRegex = regexp.MustCompile(`^[a-z0-9-]{3,24}$`)

var reservedSanctumSlugs = map[string]struct{}{
        "admin":         {},
        "api":           {},
        "auth":          {},
        "chat":          {},
        "settings":      {},
        "sanctums":      {},
        "s":             {},
        "users":         {},
        "posts":         {},
        "comments":      {},
        "conversations": {},
        "chatrooms":     {},
        "friends":       {},
        "games":         {},
        "streams":       {},
        "ws":            {},
        "swagger":       {},
        "metrics":       {},
        "login":         {},
        "signup":        {},
}

// ValidateSanctumSlug validates sanctum slug format and reserved names.
func ValidateSanctumSlug(slug string) error <span class="cov10" title="17">{
        if !sanctumSlugRegex.MatchString(slug) </span><span class="cov7" title="7">{
                return fmt.Errorf("slug must be 3-24 characters and contain only lowercase letters, numbers, and hyphens")
        }</span>

        <span class="cov8" title="10">if strings.HasPrefix(slug, "-") || strings.HasSuffix(slug, "-") </span><span class="cov3" title="2">{
                return fmt.Errorf("slug cannot start or end with a hyphen")
        }</span>

        <span class="cov7" title="8">if _, exists := reservedSanctumSlugs[slug]; exists </span><span class="cov4" title="3">{
                return fmt.Errorf("slug is reserved")
        }</span>

        <span class="cov6" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package test

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "net/http/httptest"
        "os"
        "testing"
        "time"

        "sanctum/internal/config"
        "sanctum/internal/database"
        "sanctum/internal/server"

        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
)

type authUser struct {
        ID    uint
        Token string
}

func newSanctumTestApp(t *testing.T) *fiber.App <span class="cov6" title="9">{
        t.Helper()

        if err := os.Setenv("APP_ENV", "test"); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("set APP_ENV: %v", err)
        }</span>

        <span class="cov6" title="9">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("load config: %v", err)
        }</span>

        <span class="cov6" title="9">srv, err := server.NewServer(cfg)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("new server: %v", err)
        }</span>

        <span class="cov6" title="9">app := fiber.New()
        srv.SetupMiddleware(app)
        srv.SetupRoutes(app)
        return app</span>
}

func signupSanctumUser(t *testing.T, app *fiber.App, prefix string) authUser <span class="cov7" title="13">{
        t.Helper()

        suffix := time.Now().UnixNano()
        username := "u" + uuid.NewString()[:10]
        email := fmt.Sprintf("%s_%d@example.com", prefix, suffix)

        payload := map[string]string{
                "username": username,
                "email":    email,
                "password": "TestPass123!@#",
        }

        req := jsonReq(t, http.MethodPost, "/api/auth/signup", payload)
        resp, err := app.Test(req, -1)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("signup app.Test: %v", err)
        }</span>
        <span class="cov7" title="13">defer func() </span><span class="cov7" title="13">{ _ = resp.Body.Close() }</span>()

        <span class="cov7" title="13">if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                t.Fatalf("signup expected 201 got %d", resp.StatusCode)
        }</span>

        <span class="cov7" title="13">var body struct {
                Token string `json:"token"`
                User  struct {
                        ID uint `json:"id"`
                } `json:"user"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("decode signup response: %v", err)
        }</span>

        <span class="cov7" title="13">if body.Token == "" || body.User.ID == 0 </span><span class="cov0" title="0">{
                t.Fatalf("invalid signup response: %+v", body)
        }</span>

        <span class="cov7" title="13">return authUser{ID: body.User.ID, Token: body.Token}</span>
}

func makeSanctumAdmin(t *testing.T, userID uint) <span class="cov4" title="4">{
        t.Helper()
        if err := database.DB.Exec(`UPDATE users SET is_admin = TRUE WHERE id = ?`, userID).Error; err != nil </span><span class="cov0" title="0">{
                t.Fatalf("promote user to admin: %v", err)
        }</span>
}

func jsonReq(t *testing.T, method, path string, payload any) *http.Request <span class="cov10" title="44">{
        t.Helper()
        if payload == nil </span><span class="cov6" title="12">{
                return httptest.NewRequest(method, path, nil)
        }</span>
        <span class="cov9" title="32">body, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("marshal payload: %v", err)
        }</span>
        <span class="cov9" title="32">req := httptest.NewRequest(method, path, bytes.NewReader(body))
        req.Header.Set("Content-Type", "application/json")
        return req</span>
}

func authReq(t *testing.T, method, path, token string, payload any) *http.Request <span class="cov8" title="24">{
        t.Helper()
        req := jsonReq(t, method, path, payload)
        if token != "" </span><span class="cov8" title="24">{
                req.Header.Set("Authorization", "Bearer "+token)
        }</span>
        <span class="cov8" title="24">return req</span>
}

func uniqueSanctumSlug(prefix string) string <span class="cov5" title="7">{
        return fmt.Sprintf("%s-%s", prefix, uuid.NewString()[:8])
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
