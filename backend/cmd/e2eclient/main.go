package e2eclient

















































































































































































}	}		}			}				log.Printf("WS2 received: %s\n", string(msg2))			if err2 == nil {			_, msg2, err2 := c2.ReadMessage()			c2.SetReadDeadline(time.Now().Add(1 * time.Second))			}				log.Printf("WS1 received: %s\n", string(msg1))			if err1 == nil {			_, msg1, err1 := c1.ReadMessage()			c1.SetReadDeadline(time.Now().Add(1 * time.Second))		default:			return			log.Println("Finished reading messages")		case <-tmr.C:		select {	for {	tmr := time.NewTimer(5 * time.Second)	// Read a few messages from both sockets with a timeout	log.Println("User2 sent chat")	}		log.Fatalf("WS2 chat failed: %v", err)	if err := c2.WriteJSON(chatMsg); err != nil {	chatMsg := map[string]any{"type": "chat", "room_id": int(roomID), "payload": map[string]any{"text": "Hello from user2"}}	time.Sleep(500 * time.Millisecond)	// Wait a bit and send a chat from user2	log.Println("User2 sent join_room")	}		log.Fatalf("WS2 join failed: %v", err)	if err := c2.WriteJSON(joinMsg); err != nil {	joinMsg := map[string]any{"type": "join_room", "room_id": int(roomID)}	// Send join from user2	defer c2.Close()	}		log.Fatalf("WS2 connect failed: %v", err)	if err != nil {	c2, err := wsConnect(ws2)	log.Printf("Connecting WS2 %s\n", ws2)	ws2 := *wsBase + fmt.Sprintf("?room_id=%d&token=%s", int(roomID), token2)	// Connect second websocket (user2)	defer c1.Close()	}		log.Fatalf("WS1 connect failed: %v", err)	if err != nil {	c1, err := wsConnect(ws1)	log.Printf("Connecting WS1 %s\n", ws1)	ws1 := *wsBase + fmt.Sprintf("?room_id=%d&token=%s", int(roomID), token1)	// Connect first websocket (user1)	log.Printf("Room created: %v\n", roomID)	}		log.Fatalf("create room failed: %v", err)	if err != nil {	roomID, err := createRoom(ctx, *api, token1)	log.Println("Creating room as user1...")	log.Println("User2 token obtained")	}		log.Fatalf("signup user2 failed: %v", err)	if err != nil {	token2, err := signup(ctx, *api, t2, e2, password)	log.Println("User1 token obtained")	}		log.Fatalf("signup user1 failed: %v", err)	if err != nil {	token1, err := signup(ctx, *api, t1, e1, password)	log.Println("Signing up users...")	e2 := fmt.Sprintf("%s@example.com", t2)	t2 := fmt.Sprintf("e2e_user2_%d", time.Now().Unix())	e1 := fmt.Sprintf("%s@example.com", t1)	t1 := fmt.Sprintf("e2e_user1_%d", time.Now().Unix())	password := "Password123!"	ctx := context.Background()	flag.Parse()	wsBase := flag.String("ws", "ws://localhost:8375/api/ws/game", "WebSocket base URL")	api := flag.String("api", "http://localhost:8375/api", "API base URL")func main() {}	return conn, err	conn, _, err := dialer.Dial(u.String(), nil)	dialer := websocket.DefaultDialer	// Use default dialer	}		return nil, err	if err != nil {	u, err := url.Parse(wsURL)func wsConnect(wsURL string) (*websocket.Conn, error) {}	return id, nil	id, _ := resp["id"].(float64)	}		return 0, err	if err := json.Unmarshal(b, &resp); err != nil {	var resp map[string]any	}		return 0, fmt.Errorf("create room failed: %s", string(b))	if code < 200 || code >= 300 {	}		return 0, err	if err != nil {	b, code, err := httpPostJSON(ctx, url, body, headers)	headers := map[string]string{"Authorization": "Bearer " + token}	body := map[string]string{"type": "tictactoe"}	url := base + "/games/rooms"func createRoom(ctx context.Context, base string, token string) (float64, error) {}	return token, nil	token, _ := resp["token"].(string)	}		return "", err	if err := json.Unmarshal(b, &resp); err != nil {	var resp map[string]any	}		return "", fmt.Errorf("signup failed: %s", string(b))	if code < 200 || code >= 300 {	}		return "", err	if err != nil {	b, code, err := httpPostJSON(ctx, url, req, nil)	req := signupReq{Username: u, Email: e, Password: p}	url := base + "/auth/signup"func signup(ctx context.Context, base string, u, e, p string) (string, error) {}	return buf.Bytes(), resp.StatusCode, nil	_, _ = buf.ReadFrom(resp.Body)	var buf bytes.Buffer	defer resp.Body.Close()	}		return nil, 0, err	if err != nil {	resp, err := cli.Do(req)	cli := &http.Client{Timeout: 10 * time.Second}	}		req.Header.Set(k, v)	for k, v := range headers {	req.Header.Set("Content-Type", "application/json")	}		return nil, 0, err	if err != nil {	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(b))	b, _ := json.Marshal(body)func httpPostJSON(ctx context.Context, url string, body any, headers map[string]string) ([]byte, int, error) {}	Password string `json:"password"`	Email    string `json:"email"`	Username string `json:"username"`type signupReq struct {)	"github.com/gorilla/websocket"	"time"	"os"	"net/url"	"net/http"	"log"	"fmt"	"flag"	"encoding/json"	"context"	"bytes"import (package main